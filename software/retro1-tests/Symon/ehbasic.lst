ca65 V2.15 - Git a85ac88
Main file   : min_mon.asm
Current file: min_mon.asm

000000r 1               
000000r 1               ; minimal monitor for EhBASIC and 6502 simulator V1.05
000000r 1               
000000r 1               ; To run EhBASIC on the simulator load and assemble [F7] this file, start the simulator
000000r 1               ; running [F6] then start the code with the RESET [CTRL][SHIFT]R. Just selecting RUN
000000r 1               ; will do nothing, you'll still have to do a reset to run the code.
000000r 1               
000000r 1               	.feature labels_without_colons
000000r 1               	.include "basic.asm"
000000r 2               
000000r 2               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22
000000r 2               
000000r 2               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 2               
000000r 2               ; 2.00	new revision numbers start here
000000r 2               ; 2.01	fixed LCASE$() and UCASE$()
000000r 2               ; 2.02	new get value routine done
000000r 2               ; 2.03	changed RND() to galoise method
000000r 2               ; 2.04	fixed SPC()
000000r 2               ; 2.05	new get value routine fixed
000000r 2               ; 2.06	changed USR() code
000000r 2               ; 2.07	fixed STR$()
000000r 2               ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
000000r 2               ; 2.09	fixed RND()
000000r 2               ; 2.10	integrated missed changes from an earlier version
000000r 2               ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 2               ; 2.21	fixed IF .. THEN RETURN to not cause error
000000r 2               ; 2.22	fixed RND() breaking the get byte routine
000000r 2               
000000r 2               ; zero page use ..
000000r 2               
000000r 2               LAB_WARM 		= $00		; BASIC warm start entry point
000000r 2               Wrmjpl 		= LAB_WARM+1; BASIC warm start vector jump low byte
000000r 2               Wrmjph 		= LAB_WARM+2; BASIC warm start vector jump high byte
000000r 2               
000000r 2               Usrjmp		= $0A		; USR function JMP address
000000r 2               Usrjpl		= Usrjmp+1	; USR function JMP vector low byte
000000r 2               Usrjph		= Usrjmp+2	; USR function JMP vector high byte
000000r 2               Nullct		= $0D		; nulls output after each line
000000r 2               TPos			= $0E		; BASIC terminal position byte
000000r 2               TWidth		= $0F		; BASIC terminal width byte
000000r 2               Iclim			= $10		; input column limit
000000r 2               Itempl		= $11		; temporary integer low byte
000000r 2               Itemph		= Itempl+1	; temporary integer high byte
000000r 2               
000000r 2               nums_1		= Itempl	; number to bin/hex string convert MSB
000000r 2               nums_2		= nums_1+1	; number to bin/hex string convert
000000r 2               nums_3		= nums_1+2	; number to bin/hex string convert LSB
000000r 2               
000000r 2               Srchc			= $5B		; search character
000000r 2               Temp3			= Srchc	; temp byte used in number routines
000000r 2               Scnquo		= $5C		; scan-between-quotes flag
000000r 2               Asrch			= Scnquo	; alt search character
000000r 2               
000000r 2               XOAw_l		= Srchc	; eXclusive OR, OR and AND word low byte
000000r 2               XOAw_h		= Scnquo	; eXclusive OR, OR and AND word high byte
000000r 2               
000000r 2               Ibptr			= $5D		; input buffer pointer
000000r 2               Dimcnt		= Ibptr	; # of dimensions
000000r 2               Tindx			= Ibptr	; token index
000000r 2               
000000r 2               Defdim		= $5E		; default DIM flag
000000r 2               Dtypef		= $5F		; data type flag, $FF=string, $00=numeric
000000r 2               Oquote		= $60		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 2               Gclctd		= $60		; garbage collected flag
000000r 2               Sufnxf		= $61		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 2               Imode			= $62		; input mode flag, $00=INPUT, $80=READ
000000r 2               
000000r 2               Cflag			= $63		; comparison evaluation flag
000000r 2               
000000r 2               TabSiz		= $64		; TAB step size (was input flag)
000000r 2               
000000r 2               next_s		= $65		; next descriptor stack address
000000r 2               
000000r 2               					; these two bytes form a word pointer to the item
000000r 2               					; currently on top of the descriptor stack
000000r 2               last_sl		= $66		; last descriptor stack address low byte
000000r 2               last_sh		= $67		; last descriptor stack address high byte (always $00)
000000r 2               
000000r 2               des_sk		= $68		; descriptor stack start address (temp strings)
000000r 2               
000000r 2               ;			= $70		; End of descriptor stack
000000r 2               
000000r 2               ut1_pl		= $71		; utility pointer 1 low byte
000000r 2               ut1_ph		= ut1_pl+1	; utility pointer 1 high byte
000000r 2               ut2_pl		= $73		; utility pointer 2 low byte
000000r 2               ut2_ph		= ut2_pl+1	; utility pointer 2 high byte
000000r 2               
000000r 2               Temp_2		= ut1_pl	; temp byte for block move
000000r 2               
000000r 2               FACt_1		= $75		; FAC temp mantissa1
000000r 2               FACt_2		= FACt_1+1	; FAC temp mantissa2
000000r 2               FACt_3		= FACt_2+1	; FAC temp mantissa3
000000r 2               
000000r 2               dims_l		= FACt_2	; array dimension size low byte
000000r 2               dims_h		= FACt_3	; array dimension size high byte
000000r 2               
000000r 2               TempB			= $78		; temp page 0 byte
000000r 2               
000000r 2               Smeml			= $79		; start of mem low byte		(Start-of-Basic)
000000r 2               Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
000000r 2               Svarl			= $7B		; start of vars low byte	(Start-of-Variables)
000000r 2               Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
000000r 2               Sarryl		= $7D		; var mem end low byte		(Start-of-Arrays)
000000r 2               Sarryh		= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
000000r 2               Earryl		= $7F		; array mem end low byte	(End-of-Arrays)
000000r 2               Earryh		= Earryl+1	; array mem end high byte	(End-of-Arrays)
000000r 2               Sstorl		= $81		; string storage low byte	(String storage (moving down))
000000r 2               Sstorh		= Sstorl+1	; string storage high byte	(String storage (moving down))
000000r 2               Sutill		= $83		; string utility ptr low byte
000000r 2               Sutilh		= Sutill+1	; string utility ptr high byte
000000r 2               Ememl			= $85		; end of mem low byte		(Limit-of-memory)
000000r 2               Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
000000r 2               Clinel		= $87		; current line low byte		(Basic line number)
000000r 2               Clineh		= Clinel+1	; current line high byte	(Basic line number)
000000r 2               Blinel		= $89		; break line low byte		(Previous Basic line number)
000000r 2               Blineh		= Blinel+1	; break line high byte		(Previous Basic line number)
000000r 2               
000000r 2               Cpntrl		= $8B		; continue pointer low byte
000000r 2               Cpntrh		= Cpntrl+1	; continue pointer high byte
000000r 2               
000000r 2               Dlinel		= $8D		; current DATA line low byte
000000r 2               Dlineh		= Dlinel+1	; current DATA line high byte
000000r 2               
000000r 2               Dptrl			= $8F		; DATA pointer low byte
000000r 2               Dptrh			= Dptrl+1	; DATA pointer high byte
000000r 2               
000000r 2               Rdptrl		= $91		; read pointer low byte
000000r 2               Rdptrh		= Rdptrl+1	; read pointer high byte
000000r 2               
000000r 2               Varnm1		= $93		; current var name 1st byte
000000r 2               Varnm2		= Varnm1+1	; current var name 2nd byte
000000r 2               
000000r 2               Cvaral		= $95		; current var address low byte
000000r 2               Cvarah		= Cvaral+1	; current var address high byte
000000r 2               
000000r 2               Frnxtl		= $97		; var pointer for FOR/NEXT low byte
000000r 2               Frnxth		= Frnxtl+1	; var pointer for FOR/NEXT high byte
000000r 2               
000000r 2               Tidx1			= Frnxtl	; temp line index
000000r 2               
000000r 2               Lvarpl		= Frnxtl	; let var pointer low byte
000000r 2               Lvarph		= Frnxth	; let var pointer high byte
000000r 2               
000000r 2               prstk			= $99		; precedence stacked flag
000000r 2               
000000r 2               comp_f		= $9B		; compare function flag, bits 0,1 and 2 used
000000r 2               					; bit 2 set if >
000000r 2               					; bit 1 set if =
000000r 2               					; bit 0 set if <
000000r 2               
000000r 2               func_l		= $9C		; function pointer low byte
000000r 2               func_h		= func_l+1	; function pointer high byte
000000r 2               
000000r 2               garb_l		= func_l	; garbage collection working pointer low byte
000000r 2               garb_h		= func_h	; garbage collection working pointer high byte
000000r 2               
000000r 2               des_2l		= $9E		; string descriptor_2 pointer low byte
000000r 2               des_2h		= des_2l+1	; string descriptor_2 pointer high byte
000000r 2               
000000r 2               g_step		= $A0		; garbage collect step size
000000r 2               
000000r 2               Fnxjmp		= $A1		; jump vector for functions
000000r 2               Fnxjpl		= Fnxjmp+1	; functions jump vector low byte
000000r 2               Fnxjph		= Fnxjmp+2	; functions jump vector high byte
000000r 2               
000000r 2               g_indx		= Fnxjpl	; garbage collect temp index
000000r 2               
000000r 2               FAC2_r		= $A3		; FAC2 rounding byte
000000r 2               
000000r 2               Adatal		= $A4		; array data pointer low byte
000000r 2               Adatah		= Adatal+1	; array data pointer high  byte
000000r 2               
000000r 2               Nbendl		= Adatal	; new block end pointer low byte
000000r 2               Nbendh		= Adatah	; new block end pointer high  byte
000000r 2               
000000r 2               Obendl		= $A6		; old block end pointer low byte
000000r 2               Obendh		= Obendl+1	; old block end pointer high  byte
000000r 2               
000000r 2               numexp		= $A8		; string to float number exponent count
000000r 2               expcnt		= $A9		; string to float exponent count
000000r 2               
000000r 2               numbit		= numexp	; bit count for array element calculations
000000r 2               
000000r 2               numdpf		= $AA		; string to float decimal point flag
000000r 2               expneg		= $AB		; string to float eval exponent -ve flag
000000r 2               
000000r 2               Astrtl		= numdpf	; array start pointer low byte
000000r 2               Astrth		= expneg	; array start pointer high  byte
000000r 2               
000000r 2               Histrl		= numdpf	; highest string low byte
000000r 2               Histrh		= expneg	; highest string high  byte
000000r 2               
000000r 2               Baslnl		= numdpf	; BASIC search line pointer low byte
000000r 2               Baslnh		= expneg	; BASIC search line pointer high  byte
000000r 2               
000000r 2               Fvar_l		= numdpf	; find/found variable pointer low byte
000000r 2               Fvar_h		= expneg	; find/found variable pointer high  byte
000000r 2               
000000r 2               Ostrtl		= numdpf	; old block start pointer low byte
000000r 2               Ostrth		= expneg	; old block start pointer high  byte
000000r 2               
000000r 2               Vrschl		= numdpf	; variable search pointer low byte
000000r 2               Vrschh		= expneg	; variable search pointer high  byte
000000r 2               
000000r 2               FAC1_e		= $AC		; FAC1 exponent
000000r 2               FAC1_1		= FAC1_e+1	; FAC1 mantissa1
000000r 2               FAC1_2		= FAC1_e+2	; FAC1 mantissa2
000000r 2               FAC1_3		= FAC1_e+3	; FAC1 mantissa3
000000r 2               FAC1_s		= FAC1_e+4	; FAC1 sign (b7)
000000r 2               
000000r 2               str_ln		= FAC1_e	; string length
000000r 2               str_pl		= FAC1_1	; string pointer low byte
000000r 2               str_ph		= FAC1_2	; string pointer high byte
000000r 2               
000000r 2               des_pl		= FAC1_2	; string descriptor pointer low byte
000000r 2               des_ph		= FAC1_3	; string descriptor pointer high byte
000000r 2               
000000r 2               mids_l		= FAC1_3	; MID$ string temp length byte
000000r 2               
000000r 2               negnum		= $B1		; string to float eval -ve flag
000000r 2               numcon		= $B1		; series evaluation constant count
000000r 2               
000000r 2               FAC1_o		= $B2		; FAC1 overflow byte
000000r 2               
000000r 2               FAC2_e		= $B3		; FAC2 exponent
000000r 2               FAC2_1		= FAC2_e+1	; FAC2 mantissa1
000000r 2               FAC2_2		= FAC2_e+2	; FAC2 mantissa2
000000r 2               FAC2_3		= FAC2_e+3	; FAC2 mantissa3
000000r 2               FAC2_s		= FAC2_e+4	; FAC2 sign (b7)
000000r 2               
000000r 2               FAC_sc		= $B8		; FAC sign comparison, Acc#1 vs #2
000000r 2               FAC1_r		= $B9		; FAC1 rounding byte
000000r 2               
000000r 2               ssptr_l		= FAC_sc	; string start pointer low byte
000000r 2               ssptr_h		= FAC1_r	; string start pointer high byte
000000r 2               
000000r 2               sdescr		= FAC_sc	; string descriptor pointer
000000r 2               
000000r 2               csidx			= $BA		; line crunch save index
000000r 2               Asptl			= csidx	; array size/pointer low byte
000000r 2               Aspth			= $BB		; array size/pointer high byte
000000r 2               
000000r 2               Btmpl			= Asptl	; BASIC pointer temp low byte
000000r 2               Btmph			= Aspth	; BASIC pointer temp low byte
000000r 2               
000000r 2               Cptrl			= Asptl	; BASIC pointer temp low byte
000000r 2               Cptrh			= Aspth	; BASIC pointer temp low byte
000000r 2               
000000r 2               Sendl			= Asptl	; BASIC pointer temp low byte
000000r 2               Sendh			= Aspth	; BASIC pointer temp low byte
000000r 2               
000000r 2               LAB_IGBY		= $BC		; get next BASIC byte subroutine
000000r 2               
000000r 2               LAB_GBYT		= $C2		; get current BASIC byte subroutine
000000r 2               Bpntrl		= $C3		; BASIC execute (get byte) pointer low byte
000000r 2               Bpntrh		= Bpntrl+1	; BASIC execute (get byte) pointer high byte
000000r 2               
000000r 2               ;			= $D7		; end of get BASIC char subroutine
000000r 2               
000000r 2               Rbyte4		= $D8		; extra PRNG byte
000000r 2               Rbyte1		= Rbyte4+1	; most significant PRNG byte
000000r 2               Rbyte2		= Rbyte4+2	; middle PRNG byte
000000r 2               Rbyte3		= Rbyte4+3	; least significant PRNG byte
000000r 2               
000000r 2               NmiBase		= $DC		; NMI handler enabled/setup/triggered flags
000000r 2               					; bit	function
000000r 2               					; ===	========
000000r 2               					; 7	interrupt enabled
000000r 2               					; 6	interrupt setup
000000r 2               					; 5	interrupt happened
000000r 2               ;			= $DD		; NMI handler addr low byte
000000r 2               ;			= $DE		; NMI handler addr high byte
000000r 2               IrqBase		= $DF		; IRQ handler enabled/setup/triggered flags
000000r 2               ;			= $E0		; IRQ handler addr low byte
000000r 2               ;			= $E1		; IRQ handler addr high byte
000000r 2               
000000r 2               ;			= $DE		; unused
000000r 2               ;			= $DF		; unused
000000r 2               ;			= $E0		; unused
000000r 2               ;			= $E1		; unused
000000r 2               ;			= $E2		; unused
000000r 2               ;			= $E3		; unused
000000r 2               ;			= $E4		; unused
000000r 2               ;			= $E5		; unused
000000r 2               ;			= $E6		; unused
000000r 2               ;			= $E7		; unused
000000r 2               ;			= $E8		; unused
000000r 2               ;			= $E9		; unused
000000r 2               ;			= $EA		; unused
000000r 2               ;			= $EB		; unused
000000r 2               ;			= $EC		; unused
000000r 2               ;			= $ED		; unused
000000r 2               ;			= $EE		; unused
000000r 2               
000000r 2               Decss			= $EF		; number to decimal string start
000000r 2               Decssp1		= Decss+1	; number to decimal string start
000000r 2               
000000r 2               ;			= $FF		; decimal string end
000000r 2               
000000r 2               ; token values needed for BASIC
000000r 2               
000000r 2               ; primary command tokens (can start a statement)
000000r 2               
000000r 2               TK_END		= $80			; END token
000000r 2               TK_FOR		= TK_END+1		; FOR token
000000r 2               TK_NEXT		= TK_FOR+1		; NEXT token
000000r 2               TK_DATA		= TK_NEXT+1		; DATA token
000000r 2               TK_INPUT		= TK_DATA+1		; INPUT token
000000r 2               TK_DIM		= TK_INPUT+1	; DIM token
000000r 2               TK_READ		= TK_DIM+1		; READ token
000000r 2               TK_LET		= TK_READ+1		; LET token
000000r 2               TK_DEC		= TK_LET+1		; DEC token
000000r 2               TK_GOTO		= TK_DEC+1		; GOTO token
000000r 2               TK_RUN		= TK_GOTO+1		; RUN token
000000r 2               TK_IF			= TK_RUN+1		; IF token
000000r 2               TK_RESTORE		= TK_IF+1		; RESTORE token
000000r 2               TK_GOSUB		= TK_RESTORE+1	; GOSUB token
000000r 2               TK_RETIRQ		= TK_GOSUB+1	; RETIRQ token
000000r 2               TK_RETNMI		= TK_RETIRQ+1	; RETNMI token
000000r 2               TK_RETURN		= TK_RETNMI+1	; RETURN token
000000r 2               TK_REM		= TK_RETURN+1	; REM token
000000r 2               TK_STOP		= TK_REM+1		; STOP token
000000r 2               TK_ON			= TK_STOP+1		; ON token
000000r 2               TK_NULL		= TK_ON+1		; NULL token
000000r 2               TK_INC		= TK_NULL+1		; INC token
000000r 2               TK_WAIT		= TK_INC+1		; WAIT token
000000r 2               TK_LOAD		= TK_WAIT+1		; LOAD token
000000r 2               TK_SAVE		= TK_LOAD+1		; SAVE token
000000r 2               TK_DEF		= TK_SAVE+1		; DEF token
000000r 2               TK_POKE		= TK_DEF+1		; POKE token
000000r 2               TK_DOKE		= TK_POKE+1		; DOKE token
000000r 2               TK_CALL		= TK_DOKE+1		; CALL token
000000r 2               TK_DO			= TK_CALL+1		; DO token
000000r 2               TK_LOOP		= TK_DO+1		; LOOP token
000000r 2               TK_PRINT		= TK_LOOP+1		; PRINT token
000000r 2               TK_CONT		= TK_PRINT+1	; CONT token
000000r 2               TK_LIST		= TK_CONT+1		; LIST token
000000r 2               TK_CLEAR		= TK_LIST+1		; CLEAR token
000000r 2               TK_NEW		= TK_CLEAR+1	; NEW token
000000r 2               TK_WIDTH		= TK_NEW+1		; WIDTH token
000000r 2               TK_GET		= TK_WIDTH+1	; GET token
000000r 2               TK_SWAP		= TK_GET+1		; SWAP token
000000r 2               TK_BITSET		= TK_SWAP+1		; BITSET token
000000r 2               TK_BITCLR		= TK_BITSET+1	; BITCLR token
000000r 2               TK_IRQ		= TK_BITCLR+1	; IRQ token
000000r 2               TK_NMI		= TK_IRQ+1		; NMI token
000000r 2               
000000r 2               ; secondary command tokens, can't start a statement
000000r 2               
000000r 2               TK_TAB		= TK_NMI+1		; TAB token
000000r 2               TK_ELSE		= TK_TAB+1		; ELSE token
000000r 2               TK_TO			= TK_ELSE+1		; TO token
000000r 2               TK_FN			= TK_TO+1		; FN token
000000r 2               TK_SPC		= TK_FN+1		; SPC token
000000r 2               TK_THEN		= TK_SPC+1		; THEN token
000000r 2               TK_NOT		= TK_THEN+1		; NOT token
000000r 2               TK_STEP		= TK_NOT+1		; STEP token
000000r 2               TK_UNTIL		= TK_STEP+1		; UNTIL token
000000r 2               TK_WHILE		= TK_UNTIL+1	; WHILE token
000000r 2               TK_OFF		= TK_WHILE+1	; OFF token
000000r 2               
000000r 2               ; opperator tokens
000000r 2               
000000r 2               TK_PLUS		= TK_OFF+1		; + token
000000r 2               TK_MINUS		= TK_PLUS+1		; - token
000000r 2               TK_MUL		= TK_MINUS+1	; * token
000000r 2               TK_DIV		= TK_MUL+1		; / token
000000r 2               TK_POWER		= TK_DIV+1		; ^ token
000000r 2               TK_AND		= TK_POWER+1	; AND token
000000r 2               TK_EOR		= TK_AND+1		; EOR token
000000r 2               TK_OR			= TK_EOR+1		; OR token
000000r 2               TK_RSHIFT		= TK_OR+1		; RSHIFT token
000000r 2               TK_LSHIFT		= TK_RSHIFT+1	; LSHIFT token
000000r 2               TK_GT			= TK_LSHIFT+1	; > token
000000r 2               TK_EQUAL		= TK_GT+1		; = token
000000r 2               TK_LT			= TK_EQUAL+1	; < token
000000r 2               
000000r 2               ; functions tokens
000000r 2               
000000r 2               TK_SGN		= TK_LT+1		; SGN token
000000r 2               TK_INT		= TK_SGN+1		; INT token
000000r 2               TK_ABS		= TK_INT+1		; ABS token
000000r 2               TK_USR		= TK_ABS+1		; USR token
000000r 2               TK_FRE		= TK_USR+1		; FRE token
000000r 2               TK_POS		= TK_FRE+1		; POS token
000000r 2               TK_SQR		= TK_POS+1		; SQR token
000000r 2               TK_RND		= TK_SQR+1		; RND token
000000r 2               TK_LOG		= TK_RND+1		; LOG token
000000r 2               TK_EXP		= TK_LOG+1		; EXP token
000000r 2               TK_COS		= TK_EXP+1		; COS token
000000r 2               TK_SIN		= TK_COS+1		; SIN token
000000r 2               TK_TAN		= TK_SIN+1		; TAN token
000000r 2               TK_ATN		= TK_TAN+1		; ATN token
000000r 2               TK_PEEK		= TK_ATN+1		; PEEK token
000000r 2               TK_DEEK		= TK_PEEK+1		; DEEK token
000000r 2               TK_SADD		= TK_DEEK+1		; SADD token
000000r 2               TK_LEN		= TK_SADD+1		; LEN token
000000r 2               TK_STRS		= TK_LEN+1		; STR$ token
000000r 2               TK_VAL		= TK_STRS+1		; VAL token
000000r 2               TK_ASC		= TK_VAL+1		; ASC token
000000r 2               TK_UCASES		= TK_ASC+1		; UCASE$ token
000000r 2               TK_LCASES		= TK_UCASES+1	; LCASE$ token
000000r 2               TK_CHRS		= TK_LCASES+1	; CHR$ token
000000r 2               TK_HEXS		= TK_CHRS+1		; HEX$ token
000000r 2               TK_BINS		= TK_HEXS+1		; BIN$ token
000000r 2               TK_BITTST		= TK_BINS+1		; BITTST token
000000r 2               TK_MAX		= TK_BITTST+1	; MAX token
000000r 2               TK_MIN		= TK_MAX+1		; MIN token
000000r 2               TK_PI			= TK_MIN+1		; PI token
000000r 2               TK_TWOPI		= TK_PI+1		; TWOPI token
000000r 2               TK_VPTR		= TK_TWOPI+1	; VARPTR token
000000r 2               TK_LEFTS		= TK_VPTR+1		; LEFT$ token
000000r 2               TK_RIGHTS		= TK_LEFTS+1	; RIGHT$ token
000000r 2               TK_MIDS		= TK_RIGHTS+1	; MID$ token
000000r 2               
000000r 2               ; offsets from a base of X or Y
000000r 2               
000000r 2               PLUS_0		= $00		; X or Y plus 0
000000r 2               PLUS_1		= $01		; X or Y plus 1
000000r 2               PLUS_2		= $02		; X or Y plus 2
000000r 2               PLUS_3		= $03		; X or Y plus 3
000000r 2               
000000r 2               LAB_STAK		= $0100	; stack bottom, no offset
000000r 2               
000000r 2               LAB_SKFE		= LAB_STAK+$FE
000000r 2               					; flushed stack address
000000r 2               LAB_SKFF		= LAB_STAK+$FF
000000r 2               					; flushed stack address
000000r 2               
000000r 2               ccflag		= $0200	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 2               ccbyte		= ccflag+1	; BASIC CTRL-C byte
000000r 2               ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
000000r 2               
000000r 2               VEC_CC		= ccnull+1	; ctrl c check vector
000000r 2               
000000r 2               VEC_IN		= VEC_CC+2	; input vector
000000r 2               VEC_OUT		= VEC_IN+2	; output vector
000000r 2               VEC_LD		= VEC_OUT+2	; load vector
000000r 2               VEC_SV		= VEC_LD+2	; save vector
000000r 2               
000000r 2               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
000000r 2               
000000r 2               Ibuffs		= IRQ_vec+$14
000000r 2               					; start of input buffer after IRQ/NMI code
000000r 2               Ibuffe		= Ibuffs+$47; end of input buffer
000000r 2               
000000r 2               Ram_base		= $0300	; start of user RAM (set as needed, should be page aligned)
000000r 2               Ram_top		= $8000	; end of user RAM+1 (set as needed, should be page aligned)
000000r 2               
000000r 2               ; This start can be changed to suit your system
000000r 2               
000000r 2               	.org	$C000
00C000  2               
00C000  2               ; BASIC cold start entry point
00C000  2               
00C000  2               ; new page 2 initialisation, copy block to ccflag on
00C000  2               
00C000  2               LAB_COLD
00C000  2  A0 04        	LDY	#PG2_TABE-PG2_TABS-1
00C002  2               					; byte count-1
00C002  2               LAB_2D13
00C002  2  B9 F6 E0     	LDA	PG2_TABS,Y		; get byte
00C005  2  99 00 02     	STA	ccflag,Y		; store in page 2
00C008  2  88           	DEY				; decrement count
00C009  2  10 F7        	BPL	LAB_2D13		; loop if not done
00C00B  2               
00C00B  2  A2 FF        	LDX	#$FF			; set byte
00C00D  2  86 88        	STX	Clineh		; set current line high byte (set immediate mode)
00C00F  2  9A           	TXS				; reset stack pointer
00C010  2               
00C010  2  A9 4C        	LDA	#$4C			; code for JMP
00C012  2  85 A1        	STA	Fnxjmp		; save for jump vector for functions
00C014  2               
00C014  2               ; copy block from LAB_2CEE to $00BC - $00D3
00C014  2               
00C014  2  A2 1C        	LDX	#StrTab-LAB_2CEE	; set byte count
00C016  2               LAB_2D4E
00C016  2  BD FA E0     	LDA	LAB_2CEE-1,X	; get byte from table
00C019  2  95 BB        	STA	LAB_IGBY-1,X	; save byte in page zero
00C01B  2  CA           	DEX				; decrement count
00C01C  2  D0 F8        	BNE	LAB_2D4E		; loop if not all done
00C01E  2               
00C01E  2               ; copy block from StrTab to $0000 - $0012
00C01E  2               
00C01E  2               LAB_GMEM
00C01E  2  A2 12        	LDX	#EndTab-StrTab-1	; set byte count-1
00C020  2               TabLoop
00C020  2  BD 17 E1     	LDA	StrTab,X		; get byte from table
00C023  2  95 00        	STA	PLUS_0,X		; save byte in page zero
00C025  2  CA           	DEX				; decrement count
00C026  2  10 F8        	BPL	TabLoop		; loop if not all done
00C028  2               
00C028  2               ; set-up start values
00C028  2               
00C028  2  A9 00        	LDA	#$00			; clear A
00C02A  2  85 DC        	STA	NmiBase		; clear NMI handler enabled flag
00C02C  2  85 DF        	STA	IrqBase		; clear IRQ handler enabled flag
00C02E  2  85 B2        	STA	FAC1_o		; clear FAC1 overflow byte
00C030  2  85 67        	STA	last_sh		; clear descriptor stack top item pointer high byte
00C032  2               
00C032  2  A9 0E        	LDA	#$0E			; set default tab size
00C034  2  85 64        	STA	TabSiz		; save it
00C036  2  A9 03        	LDA	#$03			; set garbage collect step size for descriptor stack
00C038  2  85 A0        	STA	g_step		; save it
00C03A  2  A2 68        	LDX	#des_sk		; descriptor stack start
00C03C  2  86 65        	STX	next_s		; set descriptor stack pointer
00C03E  2  20 92 C8     	JSR	LAB_CRLF		; print CR/LF
00C041  2  A9 2A        	LDA	#<LAB_MSZM		; point to memory size message (low addr)
00C043  2  A0 E1        	LDY	#>LAB_MSZM		; point to memory size message (high addr)
00C045  2  20 D3 C8     	JSR	LAB_18C3		; print null terminated string from memory
00C048  2  20 40 C2     	JSR	LAB_INLN		; print "? " and get BASIC input
00C04B  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00C04D  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00C04F  2  20 C2 00     	JSR	LAB_GBYT		; get last byte back
00C052  2               
00C052  2  D0 1F        	BNE	LAB_2DAA		; branch if not null (user typed something)
00C054  2               
00C054  2  A0 00        	LDY	#$00			; else clear Y
00C056  2               					; character was null so get memory size the hard way
00C056  2               					; we get here with Y=0 and Itempl/h = Ram_base
00C056  2               LAB_2D93
00C056  2  E6 11        	INC	Itempl		; increment temporary integer low byte
00C058  2  D0 08        	BNE	LAB_2D99		; branch if no overflow
00C05A  2               
00C05A  2  E6 12        	INC	Itemph		; increment temporary integer high byte
00C05C  2  A5 12        	LDA	Itemph		; get high byte
00C05E  2  C9 80        	CMP	#>Ram_top		; compare with top of RAM+1
00C060  2  F0 1D        	BEQ	LAB_2DB6		; branch if match (end of user RAM)
00C062  2               
00C062  2               LAB_2D99
00C062  2  A9 55        	LDA	#$55			; set test byte
00C064  2  91 11        	STA	(Itempl),Y		; save via temporary integer
00C066  2  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
00C068  2  D0 15        	BNE	LAB_2DB6		; branch if fail
00C06A  2               
00C06A  2  0A           	ASL				; shift test byte left (now $AA)
00C06B  2  91 11        	STA	(Itempl),Y		; save via temporary integer
00C06D  2  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
00C06F  2  F0 E5        	BEQ	LAB_2D93		; if ok go do next byte
00C071  2               
00C071  2  D0 0C        	BNE	LAB_2DB6		; branch if fail
00C073  2               
00C073  2               LAB_2DAA
00C073  2  20 A6 D9     	JSR	LAB_2887		; get FAC1 from string
00C076  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00C078  2  C9 98        	CMP	#$98			; compare with exponent = 2^24
00C07A  2  B0 A2        	BCS	LAB_GMEM		; if too large go try again
00C07C  2               
00C07C  2  20 F7 D4     	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
00C07F  2               					; (no range check)
00C07F  2               
00C07F  2               LAB_2DB6
00C07F  2  A5 11        	LDA	Itempl		; get temporary integer low byte
00C081  2  A4 12        	LDY	Itemph		; get temporary integer high byte
00C083  2  C0 01        	CPY	#<Ram_base+1	; compare with start of RAM+$100 high byte
00C085  2  90 97        	BCC	LAB_GMEM		; if too small go try again
00C087  2               
00C087  2               
00C087  2               ; uncomment these lines if you want to check on the high limit of memory. Note if
00C087  2               ; Ram_top is set too low then this will fail. default is ignore it and assume the
00C087  2               ; users know what they're doing!
00C087  2               
00C087  2               ;	CPY	#>Ram_top		; compare with top of RAM high byte
00C087  2               ;	BCC	MEM_OK		; branch if < RAM top
00C087  2               
00C087  2               ;	BNE	LAB_GMEM		; if too large go try again
00C087  2               					; else was = so compare low bytes
00C087  2               ;	CMP	#<Ram_top		; compare with top of RAM low byte
00C087  2               ;	BEQ	MEM_OK		; branch if = RAM top
00C087  2               
00C087  2               ;	BCS	LAB_GMEM		; if too large go try again
00C087  2               
00C087  2               ;MEM_OK
00C087  2  85 85        	STA	Ememl			; set end of mem low byte
00C089  2  84 86        	STY	Ememh			; set end of mem high byte
00C08B  2  85 81        	STA	Sstorl		; set bottom of string space low byte
00C08D  2  84 82        	STY	Sstorh		; set bottom of string space high byte
00C08F  2               
00C08F  2  A0 00        	LDY	#<Ram_base		; set start addr low byte
00C091  2  A2 03        	LDX	#>Ram_base		; set start addr high byte
00C093  2  84 79        	STY	Smeml			; save start of mem low byte
00C095  2  86 7A        	STX	Smemh			; save start of mem high byte
00C097  2               
00C097  2               ; this line is only needed if Ram_base is not $xx00
00C097  2               
00C097  2               ;	LDY	#$00			; clear Y
00C097  2  98           	TYA				; clear A
00C098  2  91 79        	STA	(Smeml),Y		; clear first byte
00C09A  2  E6 79        	INC	Smeml			; increment start of mem low byte
00C09C  2               
00C09C  2               ; these two lines are only needed if Ram_base is $xxFF
00C09C  2               
00C09C  2               ;	BNE	LAB_2E05		; branch if no rollover
00C09C  2               
00C09C  2               ;	INC	Smemh			; increment start of mem high byte
00C09C  2               LAB_2E05
00C09C  2  20 92 C8     	JSR	LAB_CRLF		; print CR/LF
00C09F  2  20 50 C3     	JSR	LAB_1463		; do "NEW" and "CLEAR"
00C0A2  2  A5 85        	LDA	Ememl			; get end of mem low byte
00C0A4  2  38           	SEC				; set carry for subtract
00C0A5  2  E5 79        	SBC	Smeml			; subtract start of mem low byte
00C0A7  2  AA           	TAX				; copy to X
00C0A8  2  A5 86        	LDA	Ememh			; get end of mem high byte
00C0AA  2  E5 7A        	SBC	Smemh			; subtract start of mem high byte
00C0AC  2  20 82 DA     	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
00C0AF  2  A9 39        	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
00C0B1  2  A0 E1        	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
00C0B3  2  20 D3 C8     	JSR	LAB_18C3		; print null terminated string from memory
00C0B6  2  A9 5A        	LDA	#<LAB_1274		; warm start vector low byte
00C0B8  2  A0 C1        	LDY	#>LAB_1274		; warm start vector high byte
00C0BA  2  85 01        	STA	Wrmjpl		; save warm start vector low byte
00C0BC  2  84 02        	STY	Wrmjph		; save warm start vector high byte
00C0BE  2  6C 01 00     	JMP	(Wrmjpl)		; go do warm start
00C0C1  2               
00C0C1  2               ; open up space in memory
00C0C1  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00C0C1  2               
00C0C1  2               ; Nbendl,Nbendh - new block end address (A/Y)
00C0C1  2               ; Obendl,Obendh - old block end address
00C0C1  2               ; Ostrtl,Ostrth - old block start address
00C0C1  2               
00C0C1  2               ; returns with ..
00C0C1  2               
00C0C1  2               ; Nbendl,Nbendh - new block start address (high byte - $100)
00C0C1  2               ; Obendl,Obendh - old block start address (high byte - $100)
00C0C1  2               ; Ostrtl,Ostrth - old block start address (unchanged)
00C0C1  2               
00C0C1  2               LAB_11CF
00C0C1  2  20 0B C1     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
00C0C4  2               					; addr to check is in AY (low/high)
00C0C4  2  85 7F        	STA	Earryl		; save new array mem end low byte
00C0C6  2  84 80        	STY	Earryh		; save new array mem end high byte
00C0C8  2               
00C0C8  2               ; open up space in memory
00C0C8  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00C0C8  2               ; don't set array end
00C0C8  2               
00C0C8  2               LAB_11D6
00C0C8  2  38           	SEC				; set carry for subtract
00C0C9  2  A5 A6        	LDA	Obendl		; get block end low byte
00C0CB  2  E5 AA        	SBC	Ostrtl		; subtract block start low byte
00C0CD  2  A8           	TAY				; copy MOD(block length/$100) byte to Y
00C0CE  2  A5 A7        	LDA	Obendh		; get block end high byte
00C0D0  2  E5 AB        	SBC	Ostrth		; subtract block start high byte
00C0D2  2  AA           	TAX				; copy block length high byte to X
00C0D3  2  E8           	INX				; +1 to allow for count=0 exit
00C0D4  2  98           	TYA				; copy block length low byte to A
00C0D5  2  F0 24        	BEQ	LAB_120A		; branch if length low byte=0
00C0D7  2               
00C0D7  2               					; block is (X-1)*256+Y bytes, do the Y bytes first
00C0D7  2               
00C0D7  2  38           	SEC				; set carry for add + 1, two's complement
00C0D8  2  49 FF        	EOR	#$FF			; invert low byte for subtract
00C0DA  2  65 A6        	ADC	Obendl		; add block end low byte
00C0DC  2               
00C0DC  2  85 A6        	STA	Obendl		; save corrected old block end low byte
00C0DE  2  B0 03        	BCS	LAB_11F3		; branch if no underflow
00C0E0  2               
00C0E0  2  C6 A7        	DEC	Obendh		; else decrement block end high byte
00C0E2  2  38           	SEC				; set carry for add + 1, two's complement
00C0E3  2               LAB_11F3
00C0E3  2  98           	TYA				; get MOD(block length/$100) byte
00C0E4  2  49 FF        	EOR	#$FF			; invert low byte for subtract
00C0E6  2  65 A4        	ADC	Nbendl		; add destination end low byte
00C0E8  2  85 A4        	STA	Nbendl		; save modified new block end low byte
00C0EA  2  B0 08        	BCS	LAB_1203		; branch if no underflow
00C0EC  2               
00C0EC  2  C6 A5        	DEC	Nbendh		; else decrement block end high byte
00C0EE  2  90 04        	BCC	LAB_1203		; branch always
00C0F0  2               
00C0F0  2               LAB_11FF
00C0F0  2  B1 A6        	LDA	(Obendl),Y		; get byte from source
00C0F2  2  91 A4        	STA	(Nbendl),Y		; copy byte to destination
00C0F4  2               LAB_1203
00C0F4  2  88           	DEY				; decrement index
00C0F5  2  D0 F9        	BNE	LAB_11FF		; loop until Y=0
00C0F7  2               
00C0F7  2               					; now do Y=0 indexed byte
00C0F7  2  B1 A6        	LDA	(Obendl),Y		; get byte from source
00C0F9  2  91 A4        	STA	(Nbendl),Y		; save byte to destination
00C0FB  2               LAB_120A
00C0FB  2  C6 A7        	DEC	Obendh		; decrement source pointer high byte
00C0FD  2  C6 A5        	DEC	Nbendh		; decrement destination pointer high byte
00C0FF  2  CA           	DEX				; decrement block count
00C100  2  D0 F2        	BNE	LAB_1203		; loop until count = $0
00C102  2               
00C102  2  60           	RTS
00C103  2               
00C103  2               ; check room on stack for A bytes
00C103  2               ; stack too deep? do OM error
00C103  2               
00C103  2               LAB_1212
00C103  2  85 78        	STA	TempB			; save result in temp byte
00C105  2  BA           	TSX				; copy stack
00C106  2  E4 78        	CPX	TempB			; compare new "limit" with stack
00C108  2  90 30        	BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
00C10A  2               
00C10A  2  60           	RTS
00C10B  2               
00C10B  2               ; check available memory, "Out of memory" error if no room
00C10B  2               ; addr to check is in AY (low/high)
00C10B  2               
00C10B  2               LAB_121F
00C10B  2  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
00C10D  2  90 2A        	BCC	LAB_124B		; if less then exit (is ok)
00C10F  2               
00C10F  2  D0 04        	BNE	LAB_1229		; skip next test if greater (tested <)
00C111  2               
00C111  2               					; high byte was =, now do low byte
00C111  2  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
00C113  2  90 24        	BCC	LAB_124B		; if less then exit (is ok)
00C115  2               
00C115  2               					; addr is > string storage ptr (oops!)
00C115  2               LAB_1229
00C115  2  48           	PHA				; push addr low byte
00C116  2  A2 08        	LDX	#$08			; set index to save Adatal to expneg inclusive
00C118  2  98           	TYA				; copy addr high byte (to push on stack)
00C119  2               
00C119  2               					; save misc numeric work area
00C119  2               LAB_122D
00C119  2  48           	PHA				; push byte
00C11A  2  B5 A3        	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
00C11C  2  CA           	DEX				; decrement index
00C11D  2  10 FA        	BPL	LAB_122D		; loop until all done
00C11F  2               
00C11F  2  20 DF D1     	JSR	LAB_GARB		; garbage collection routine
00C122  2               
00C122  2               					; restore misc numeric work area
00C122  2  A2 00        	LDX	#$00			; clear the index to restore bytes
00C124  2               LAB_1238
00C124  2  68           	PLA				; pop byte
00C125  2  95 A4        	STA	Adatal,X		; save byte to Adatal to expneg
00C127  2  E8           	INX				; increment index
00C128  2  E0 08        	CPX	#$08			; compare with end + 1
00C12A  2  30 F8        	BMI	LAB_1238		; loop if more to do
00C12C  2               
00C12C  2  68           	PLA				; pop addr high byte
00C12D  2  A8           	TAY				; copy back to Y
00C12E  2  68           	PLA				; pop addr low byte
00C12F  2  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
00C131  2  90 06        	BCC	LAB_124B		; if less then exit (is ok)
00C133  2               
00C133  2  D0 05        	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
00C135  2               
00C135  2               					; high byte was =, now do low byte
00C135  2  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
00C137  2  B0 01        	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
00C139  2               
00C139  2               					; ok exit, carry clear
00C139  2               LAB_124B
00C139  2  60           	RTS
00C13A  2               
00C13A  2               ; do "Out of memory" error then warm start
00C13A  2               
00C13A  2               LAB_OMER
00C13A  2  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
00C13C  2               
00C13C  2               ; do error #X, then warm start
00C13C  2               
00C13C  2               LAB_XERR
00C13C  2  20 92 C8     	JSR	LAB_CRLF		; print CR/LF
00C13F  2               
00C13F  2  BD A9 E6     	LDA	LAB_BAER,X		; get error message pointer low byte
00C142  2  BC AA E6     	LDY	LAB_BAER+1,X	; get error message pointer high byte
00C145  2  20 D3 C8     	JSR	LAB_18C3		; print null terminated string from memory
00C148  2               
00C148  2  20 89 C3     	JSR	LAB_1491		; flush stack and clear continue flag
00C14B  2  A9 E6        	LDA	#<LAB_EMSG		; point to " Error" low addr
00C14D  2  A0 E7        	LDY	#>LAB_EMSG		; point to " Error" high addr
00C14F  2               LAB_1269
00C14F  2  20 D3 C8     	JSR	LAB_18C3		; print null terminated string from memory
00C152  2  A4 88        	LDY	Clineh		; get current line high byte
00C154  2  C8           	INY				; increment it
00C155  2  F0 03        	BEQ	LAB_1274		; go do warm start (was immediate mode)
00C157  2               
00C157  2               					; else print line number
00C157  2  20 77 DA     	JSR	LAB_2953		; print " in line [LINE #]"
00C15A  2               
00C15A  2               ; BASIC warm start entry point
00C15A  2               ; wait for Basic command
00C15A  2               
00C15A  2               LAB_1274
00C15A  2               					; clear ON IRQ/NMI bytes
00C15A  2  A9 00        	LDA	#$00			; clear A
00C15C  2  85 DF        	STA	IrqBase		; clear enabled byte
00C15E  2  85 DC        	STA	NmiBase		; clear enabled byte
00C160  2  A9 F7        	LDA	#<LAB_RMSG		; point to "Ready" message low byte
00C162  2  A0 E7        	LDY	#>LAB_RMSG		; point to "Ready" message high byte
00C164  2               
00C164  2  20 D3 C8     	JSR	LAB_18C3		; go do print string
00C167  2               
00C167  2               ; wait for Basic command (no "Ready")
00C167  2               
00C167  2               LAB_127D
00C167  2  20 4D C2     	JSR	LAB_1357		; call for BASIC input
00C16A  2               LAB_1280
00C16A  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00C16C  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00C16E  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C171  2  F0 F4        	BEQ	LAB_127D		; loop while null
00C173  2               
00C173  2               ; got to interpret input line now ..
00C173  2               
00C173  2  A2 FF        	LDX	#$FF			; current line to null value
00C175  2  86 88        	STX	Clineh		; set current line high byte
00C177  2  90 06        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
00C179  2               
00C179  2               					; no line number .. immediate mode
00C179  2  20 7E C2     	JSR	LAB_13A6		; crunch keywords into Basic tokens
00C17C  2  4C F3 C4     	JMP	LAB_15F6		; go scan and interpret code
00C17F  2               
00C17F  2               ; handle new BASIC line
00C17F  2               
00C17F  2               LAB_1295
00C17F  2  20 55 C7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
00C182  2  20 7E C2     	JSR	LAB_13A6		; crunch keywords into Basic tokens
00C185  2  84 5D        	STY	Ibptr			; save index pointer to end of crunched line
00C187  2  20 24 C3     	JSR	LAB_SSLN		; search BASIC for temp integer line number
00C18A  2  90 44        	BCC	LAB_12E6		; branch if not found
00C18C  2               
00C18C  2               					; aroooogah! line # already exists! delete it
00C18C  2  A0 01        	LDY	#$01			; set index to next line pointer high byte
00C18E  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
00C190  2  85 72        	STA	ut1_ph		; save it
00C192  2  A5 7B        	LDA	Svarl			; get start of vars low byte
00C194  2  85 71        	STA	ut1_pl		; save it
00C196  2  A5 AB        	LDA	Baslnh		; get found line pointer high byte
00C198  2  85 74        	STA	ut2_ph		; save it
00C19A  2  A5 AA        	LDA	Baslnl		; get found line pointer low byte
00C19C  2  88           	DEY				; decrement index
00C19D  2  F1 AA        	SBC	(Baslnl),Y		; subtract next line pointer low byte
00C19F  2  18           	CLC				; clear carry for add
00C1A0  2  65 7B        	ADC	Svarl			; add start of vars low byte
00C1A2  2  85 7B        	STA	Svarl			; save new start of vars low byte
00C1A4  2  85 73        	STA	ut2_pl		; save destination pointer low byte
00C1A6  2  A5 7C        	LDA	Svarh			; get start of vars high byte
00C1A8  2  69 FF        	ADC	#$FF			; -1 + carry
00C1AA  2  85 7C        	STA	Svarh			; save start of vars high byte
00C1AC  2  E5 AB        	SBC	Baslnh		; subtract found line pointer high byte
00C1AE  2  AA           	TAX				; copy to block count
00C1AF  2  38           	SEC				; set carry for subtract
00C1B0  2  A5 AA        	LDA	Baslnl		; get found line pointer low byte
00C1B2  2  E5 7B        	SBC	Svarl			; subtract start of vars low byte
00C1B4  2  A8           	TAY				; copy to bytes in first block count
00C1B5  2  B0 03        	BCS	LAB_12D0		; branch if overflow
00C1B7  2               
00C1B7  2  E8           	INX				; increment block count (correct for =0 loop exit)
00C1B8  2  C6 74        	DEC	ut2_ph		; decrement destination high byte
00C1BA  2               LAB_12D0
00C1BA  2  18           	CLC				; clear carry for add
00C1BB  2  65 71        	ADC	ut1_pl		; add source pointer low byte
00C1BD  2  90 03        	BCC	LAB_12D8		; branch if no overflow
00C1BF  2               
00C1BF  2  C6 72        	DEC	ut1_ph		; else decrement source pointer high byte
00C1C1  2  18           	CLC				; clear carry
00C1C2  2               
00C1C2  2               					; close up memory to delete old line
00C1C2  2               LAB_12D8
00C1C2  2  B1 71        	LDA	(ut1_pl),Y		; get byte from source
00C1C4  2  91 73        	STA	(ut2_pl),Y		; copy to destination
00C1C6  2  C8           	INY				; increment index
00C1C7  2  D0 F9        	BNE	LAB_12D8		; while <> 0 do this block
00C1C9  2               
00C1C9  2  E6 72        	INC	ut1_ph		; increment source pointer high byte
00C1CB  2  E6 74        	INC	ut2_ph		; increment destination pointer high byte
00C1CD  2  CA           	DEX				; decrement block count
00C1CE  2  D0 F2        	BNE	LAB_12D8		; loop until all done
00C1D0  2               
00C1D0  2               					; got new line in buffer and no existing same #
00C1D0  2               LAB_12E6
00C1D0  2  AD 21 02     	LDA	Ibuffs		; get byte from start of input buffer
00C1D3  2  F0 3F        	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
00C1D5  2               
00C1D5  2               					; got new line and it isn't empty line
00C1D5  2  A5 85        	LDA	Ememl			; get end of mem low byte
00C1D7  2  A4 86        	LDY	Ememh			; get end of mem high byte
00C1D9  2  85 81        	STA	Sstorl		; set bottom of string space low byte
00C1DB  2  84 82        	STY	Sstorh		; set bottom of string space high byte
00C1DD  2  A5 7B        	LDA	Svarl			; get start of vars low byte	(end of BASIC)
00C1DF  2  85 A6        	STA	Obendl		; save old block end low byte
00C1E1  2  A4 7C        	LDY	Svarh			; get start of vars high byte	(end of BASIC)
00C1E3  2  84 A7        	STY	Obendh		; save old block end high byte
00C1E5  2  65 5D        	ADC	Ibptr			; add input buffer pointer	(also buffer length)
00C1E7  2  90 01        	BCC	LAB_1301		; branch if no overflow from add
00C1E9  2               
00C1E9  2  C8           	INY				; else increment high byte
00C1EA  2               LAB_1301
00C1EA  2  85 A4        	STA	Nbendl		; save new block end low byte	(move to, low byte)
00C1EC  2  84 A5        	STY	Nbendh		; save new block end high byte
00C1EE  2  20 C1 C0     	JSR	LAB_11CF		; open up space in memory
00C1F1  2               					; old start pointer Ostrtl,Ostrth set by the find line call
00C1F1  2  A5 7F        	LDA	Earryl		; get array mem end low byte
00C1F3  2  A4 80        	LDY	Earryh		; get array mem end high byte
00C1F5  2  85 7B        	STA	Svarl			; save start of vars low byte
00C1F7  2  84 7C        	STY	Svarh			; save start of vars high byte
00C1F9  2  A4 5D        	LDY	Ibptr			; get input buffer pointer	(also buffer length)
00C1FB  2  88           	DEY				; adjust for loop type
00C1FC  2               LAB_1311
00C1FC  2  B9 1D 02     	LDA	Ibuffs-4,Y		; get byte from crunched line
00C1FF  2  91 AA        	STA	(Baslnl),Y		; save it to program memory
00C201  2  88           	DEY				; decrement count
00C202  2  C0 03        	CPY	#$03			; compare with first byte-1
00C204  2  D0 F6        	BNE	LAB_1311		; continue while count <> 3
00C206  2               
00C206  2  A5 12        	LDA	Itemph		; get line # high byte
00C208  2  91 AA        	STA	(Baslnl),Y		; save it to program memory
00C20A  2  88           	DEY				; decrement count
00C20B  2  A5 11        	LDA	Itempl		; get line # low byte
00C20D  2  91 AA        	STA	(Baslnl),Y		; save it to program memory
00C20F  2  88           	DEY				; decrement count
00C210  2  A9 FF        	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
00C212  2               					; byte then a zero already here would stop the chain rebuild
00C212  2               					; as it would think it was the [EOT] marker.
00C212  2  91 AA        	STA	(Baslnl),Y		; save it to program memory
00C214  2               
00C214  2               LAB_1319
00C214  2  20 65 C3     	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
00C217  2  A6 79        	LDX	Smeml			; get start of mem low byte
00C219  2  A5 7A        	LDA	Smemh			; get start of mem high byte
00C21B  2  A0 01        	LDY	#$01			; index to high byte of next line pointer
00C21D  2               LAB_1325
00C21D  2  86 71        	STX	ut1_pl		; set line start pointer low byte
00C21F  2  85 72        	STA	ut1_ph		; set line start pointer high byte
00C221  2  B1 71        	LDA	(ut1_pl),Y		; get it
00C223  2  F0 18        	BEQ	LAB_133E		; exit if end of program
00C225  2               
00C225  2               ; rebuild chaining of Basic lines
00C225  2               
00C225  2  A0 04        	LDY	#$04			; point to first code byte of line
00C227  2               					; there is always 1 byte + [EOL] as null entries are deleted
00C227  2               LAB_1330
00C227  2  C8           	INY				; next code byte
00C228  2  B1 71        	LDA	(ut1_pl),Y		; get byte
00C22A  2  D0 FB        	BNE	LAB_1330		; loop if not [EOL]
00C22C  2               
00C22C  2  38           	SEC				; set carry for add + 1
00C22D  2  98           	TYA				; copy end index
00C22E  2  65 71        	ADC	ut1_pl		; add to line start pointer low byte
00C230  2  AA           	TAX				; copy to X
00C231  2  A0 00        	LDY	#$00			; clear index, point to this line's next line pointer
00C233  2  91 71        	STA	(ut1_pl),Y		; set next line pointer low byte
00C235  2  98           	TYA				; clear A
00C236  2  65 72        	ADC	ut1_ph		; add line start pointer high byte + carry
00C238  2  C8           	INY				; increment index to high byte
00C239  2  91 71        	STA	(ut1_pl),Y		; save next line pointer low byte
00C23B  2  90 E0        	BCC	LAB_1325		; go do next line, branch always, carry clear
00C23D  2               
00C23D  2               
00C23D  2               LAB_133E
00C23D  2  4C 67 C1     	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
00C240  2               
00C240  2               ; print "? " and get BASIC input
00C240  2               
00C240  2               LAB_INLN
00C240  2  20 EB C8     	JSR	LAB_18E3		; print "?" character
00C243  2  20 E8 C8     	JSR	LAB_18E0		; print " "
00C246  2  D0 05        	BNE	LAB_1357		; call for BASIC input and return
00C248  2               
00C248  2               ; receive line from keyboard
00C248  2               
00C248  2               					; $08 as delete key (BACKSPACE on standard keyboard)
00C248  2               LAB_134B
00C248  2  20 ED C8     	JSR	LAB_PRNA		; go print the character
00C24B  2  CA           	DEX				; decrement the buffer counter (delete)
00C24C  2  2C           	.byte	$2C			; make LDX into BIT abs
00C24D  2               
00C24D  2               ; call for BASIC input (main entry point)
00C24D  2               
00C24D  2               LAB_1357
00C24D  2  A2 00        	LDX	#$00			; clear BASIC line buffer pointer
00C24F  2               LAB_1359
00C24F  2  20 EA E0     	JSR	V_INPT		; call scan input device
00C252  2  90 FB        	BCC	LAB_1359		; loop if no byte
00C254  2               
00C254  2  F0 F9        	BEQ	LAB_1359		; loop until valid input (ignore NULLs)
00C256  2               
00C256  2  C9 07        	CMP	#$07			; compare with [BELL]
00C258  2  F0 10        	BEQ	LAB_1378		; branch if [BELL]
00C25A  2               
00C25A  2  C9 0D        	CMP	#$0D			; compare with [CR]
00C25C  2  F0 19        	BEQ	LAB_1384		; do CR/LF exit if [CR]
00C25E  2               
00C25E  2  E0 00        	CPX	#$00			; compare pointer with $00
00C260  2  D0 04        	BNE	LAB_1374		; branch if not empty
00C262  2               
00C262  2               ; next two lines ignore any non print character and [SPACE] if input buffer empty
00C262  2               
00C262  2  C9 21        	CMP	#$21			; compare with [SP]+1
00C264  2  90 E9        	BCC	LAB_1359		; if < ignore character
00C266  2               
00C266  2               LAB_1374
00C266  2  C9 08        	CMP	#$08			; compare with [BACKSPACE] (delete last character)
00C268  2  F0 DE        	BEQ	LAB_134B		; go delete last character
00C26A  2               
00C26A  2               LAB_1378
00C26A  2  E0 47        	CPX	#Ibuffe-Ibuffs	; compare character count with max
00C26C  2  B0 0C        	BCS	LAB_138E		; skip store and do [BELL] if buffer full
00C26E  2               
00C26E  2  9D 21 02     	STA	Ibuffs,X		; else store in buffer
00C271  2  E8           	INX				; increment pointer
00C272  2               LAB_137F
00C272  2  20 ED C8     	JSR	LAB_PRNA		; go print the character
00C275  2  D0 D8        	BNE	LAB_1359		; always loop for next character
00C277  2               
00C277  2               LAB_1384
00C277  2  4C 89 C8     	JMP	LAB_1866		; do CR/LF exit to BASIC
00C27A  2               
00C27A  2               ; announce buffer full
00C27A  2               
00C27A  2               LAB_138E
00C27A  2  A9 07        	LDA	#$07			; [BELL] character into A
00C27C  2  D0 F4        	BNE	LAB_137F		; go print the [BELL] but ignore input character
00C27E  2               					; branch always
00C27E  2               
00C27E  2               ; crunch keywords into Basic tokens
00C27E  2               ; position independent buffer version ..
00C27E  2               ; faster, dictionary search version ....
00C27E  2               
00C27E  2               LAB_13A6
00C27E  2  A0 FF        	LDY	#$FF			; set save index (makes for easy math later)
00C280  2               
00C280  2  38           	SEC				; set carry for subtract
00C281  2  A5 C3        	LDA	Bpntrl		; get basic execute pointer low byte
00C283  2  E9 21        	SBC	#<Ibuffs		; subtract input buffer start pointer
00C285  2  AA           	TAX				; copy result to X (index past line # if any)
00C286  2               
00C286  2  86 60        	STX	Oquote		; clear open quote/DATA flag
00C288  2               LAB_13AC
00C288  2  BD 21 02     	LDA	Ibuffs,X		; get byte from input buffer
00C28B  2  F0 51        	BEQ	LAB_13EC		; if null save byte then exit
00C28D  2               
00C28D  2  C9 5F        	CMP	#'_'			; compare with "_"
00C28F  2  B0 4D        	BCS	LAB_13EC		; if >= go save byte then continue crunching
00C291  2               
00C291  2  C9 3C        	CMP	#'<'			; compare with "<"
00C293  2  B0 0E        	BCS	LAB_13CC		; if >= go crunch now
00C295  2               
00C295  2  C9 30        	CMP	#'0'			; compare with "0"
00C297  2  B0 45        	BCS	LAB_13EC		; if >= go save byte then continue crunching
00C299  2               
00C299  2  85 5C        	STA	Scnquo		; save buffer byte as search character
00C29B  2  C9 22        	CMP	#$22			; is it quote character?
00C29D  2  F0 61        	BEQ	LAB_1410		; branch if so (copy quoted string)
00C29F  2               
00C29F  2  C9 2A        	CMP	#'*'			; compare with "*"
00C2A1  2  90 3B        	BCC	LAB_13EC		; if < go save byte then continue crunching
00C2A3  2               
00C2A3  2               					; else crunch now
00C2A3  2               LAB_13CC
00C2A3  2  24 60        	BIT	Oquote		; get open quote/DATA token flag
00C2A5  2  70 37        	BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
00C2A7  2               					; go save byte then continue crunching
00C2A7  2               
00C2A7  2  86 78        	STX	TempB			; save buffer read index
00C2A9  2  84 BA        	STY	csidx			; copy buffer save index
00C2AB  2  A0 10        	LDY	#<TAB_1STC		; get keyword first character table low address
00C2AD  2  84 73        	STY	ut2_pl		; save pointer low byte
00C2AF  2  A0 E3        	LDY	#>TAB_1STC		; get keyword first character table high address
00C2B1  2  84 74        	STY	ut2_ph		; save pointer high byte
00C2B3  2  A0 00        	LDY	#$00			; clear table pointer
00C2B5  2               
00C2B5  2               LAB_13D0
00C2B5  2  D1 73        	CMP	(ut2_pl),Y		; compare with keyword first character table byte
00C2B7  2  F0 05        	BEQ	LAB_13D1		; go do word_table_chr if match
00C2B9  2               
00C2B9  2  90 21        	BCC	LAB_13EA		; if < keyword first character table byte go restore
00C2BB  2               					; Y and save to crunched
00C2BB  2               
00C2BB  2  C8           	INY				; else increment pointer
00C2BC  2  D0 F7        	BNE	LAB_13D0		; and loop (branch always)
00C2BE  2               
00C2BE  2               ; have matched first character of some keyword
00C2BE  2               
00C2BE  2               LAB_13D1
00C2BE  2  98           	TYA				; copy matching index
00C2BF  2  0A           	ASL				; *2 (bytes per pointer)
00C2C0  2  AA           	TAX				; copy to new index
00C2C1  2  BD 2E E3     	LDA	TAB_CHRT,X		; get keyword table pointer low byte
00C2C4  2  85 73        	STA	ut2_pl		; save pointer low byte
00C2C6  2  BD 2F E3     	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
00C2C9  2  85 74        	STA	ut2_ph		; save pointer high byte
00C2CB  2               
00C2CB  2  A0 FF        	LDY	#$FF			; clear table pointer (make -1 for start)
00C2CD  2               
00C2CD  2  A6 78        	LDX	TempB			; restore buffer read index
00C2CF  2               
00C2CF  2               LAB_13D6
00C2CF  2  C8           	INY				; next table byte
00C2D0  2  B1 73        	LDA	(ut2_pl),Y		; get byte from table
00C2D2  2               LAB_13D8
00C2D2  2  30 08        	BMI	LAB_13EA		; all bytes matched so go save token
00C2D4  2               
00C2D4  2  E8           	INX				; next buffer byte
00C2D5  2  DD 21 02     	CMP	Ibuffs,X		; compare with byte from input buffer
00C2D8  2  F0 F5        	BEQ	LAB_13D6		; go compare next if match
00C2DA  2               
00C2DA  2  D0 2B        	BNE	LAB_1417		; branch if >< (not found keyword)
00C2DC  2               
00C2DC  2               LAB_13EA
00C2DC  2  A4 BA        	LDY	csidx			; restore save index
00C2DE  2               
00C2DE  2               					; save crunched to output
00C2DE  2               LAB_13EC
00C2DE  2  E8           	INX				; increment buffer index (to next input byte)
00C2DF  2  C8           	INY				; increment save index (to next output byte)
00C2E0  2  99 21 02     	STA	Ibuffs,Y		; save byte to output
00C2E3  2  C9 00        	CMP	#$00			; set the flags, set carry
00C2E5  2  F0 32        	BEQ	LAB_142A		; do exit if was null [EOL]
00C2E7  2               
00C2E7  2               					; A holds token or byte here
00C2E7  2  E9 3A        	SBC	#':'			; subtract ":" (carry set by CMP #00)
00C2E9  2  F0 04        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
00C2EB  2               
00C2EB  2               					; A now holds token-$3A
00C2EB  2  C9 49        	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
00C2ED  2  D0 02        	BNE	LAB_1401		; branch if not DATA
00C2EF  2               
00C2EF  2               					; token was : or DATA
00C2EF  2               LAB_13FF
00C2EF  2  85 60        	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
00C2F1  2               LAB_1401
00C2F1  2  49 57        	EOR	#TK_REM-$3A		; effectively subtract REM token offset
00C2F3  2  D0 93        	BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
00C2F5  2               
00C2F5  2  85 5C        	STA	Asrch			; else was REM so set search for [EOL]
00C2F7  2               
00C2F7  2               					; loop for REM, "..." etc.
00C2F7  2               LAB_1408
00C2F7  2  BD 21 02     	LDA	Ibuffs,X		; get byte from input buffer
00C2FA  2  F0 E2        	BEQ	LAB_13EC		; branch if null [EOL]
00C2FC  2               
00C2FC  2  C5 5C        	CMP	Asrch			; compare with stored character
00C2FE  2  F0 DE        	BEQ	LAB_13EC		; branch if match (end quote)
00C300  2               
00C300  2               					; entry for copy string in quotes, don't crunch
00C300  2               LAB_1410
00C300  2  C8           	INY				; increment buffer save index
00C301  2  99 21 02     	STA	Ibuffs,Y		; save byte to output
00C304  2  E8           	INX				; increment buffer read index
00C305  2  D0 F0        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
00C307  2               
00C307  2               					; not found keyword this go
00C307  2               LAB_1417
00C307  2  A6 78        	LDX	TempB			; compare has failed, restore buffer index (start byte!)
00C309  2               
00C309  2               					; now find the end of this word in the table
00C309  2               LAB_141B
00C309  2  B1 73        	LDA	(ut2_pl),Y		; get table byte
00C30B  2  08           	PHP				; save status
00C30C  2  C8           	INY				; increment table index
00C30D  2  28           	PLP				; restore byte status
00C30E  2  10 F9        	BPL	LAB_141B		; if not end of keyword go do next
00C310  2               
00C310  2  B1 73        	LDA	(ut2_pl),Y		; get byte from keyword table
00C312  2  D0 BE        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
00C314  2               
00C314  2               					; reached end of table with no match
00C314  2  BD 21 02     	LDA	Ibuffs,X		; restore byte from input buffer
00C317  2  10 C3        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
00C319  2               					; go save byte in output and continue crunching
00C319  2               
00C319  2               					; reached [EOL]
00C319  2               LAB_142A
00C319  2  C8           	INY				; increment pointer
00C31A  2  C8           	INY				; increment pointer (makes it next line pointer high byte)
00C31B  2  99 21 02     	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
00C31E  2  C8           	INY				; adjust for line copy
00C31F  2  C8           	INY				; adjust for line copy
00C320  2  C8           	INY				; adjust for line copy
00C321  2  C6 C3        	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
00C323  2  60           	RTS
00C324  2               
00C324  2               ; search Basic for temp integer line number from start of mem
00C324  2               
00C324  2               LAB_SSLN
00C324  2  A5 79        	LDA	Smeml			; get start of mem low byte
00C326  2  A6 7A        	LDX	Smemh			; get start of mem high byte
00C328  2               
00C328  2               ; search Basic for temp integer line number from AX
00C328  2               ; returns carry set if found
00C328  2               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
00C328  2               
00C328  2               ; old 541 new 507
00C328  2               
00C328  2               LAB_SHLN
00C328  2  A0 01        	LDY	#$01			; set index
00C32A  2  85 AA        	STA	Baslnl		; save low byte as current
00C32C  2  86 AB        	STX	Baslnh		; save high byte as current
00C32E  2  B1 AA        	LDA	(Baslnl),Y		; get pointer high byte from addr
00C330  2  F0 1A        	BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
00C332  2               
00C332  2  A0 03        	LDY	#$03			; set index to line # high byte
00C334  2  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
00C336  2  88           	DEY				; decrement index (point to low byte)
00C337  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00C339  2  D0 04        	BNE	LAB_1455		; if <> skip low byte check
00C33B  2               
00C33B  2  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
00C33D  2  C5 11        	CMP	Itempl		; compare with temporary integer low byte
00C33F  2               LAB_1455
00C33F  2  B0 09        	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
00C341  2               
00C341  2               LAB_1456
00C341  2  88           	DEY				; decrement index to next line ptr high byte
00C342  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
00C344  2  AA           	TAX				; copy to X
00C345  2  88           	DEY				; decrement index to next line ptr low byte
00C346  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
00C348  2  90 DE        	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
00C34A  2               					; (carry always clear)
00C34A  2               
00C34A  2               LAB_145E
00C34A  2  F0 01        	BEQ	LAB_1460		; exit if temp = found line #, carry is set
00C34C  2               
00C34C  2               LAB_145F
00C34C  2  18           	CLC				; clear found flag
00C34D  2               LAB_1460
00C34D  2  60           	RTS
00C34E  2               
00C34E  2               ; perform NEW
00C34E  2               
00C34E  2               LAB_NEW
00C34E  2  D0 FD        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
00C350  2               
00C350  2               LAB_1463
00C350  2  A9 00        	LDA	#$00			; clear A
00C352  2  A8           	TAY				; clear Y
00C353  2  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, low byte
00C355  2  C8           	INY				; increment index
00C356  2  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, high byte
00C358  2  18           	CLC				; clear carry
00C359  2  A5 79        	LDA	Smeml			; get start of mem low byte
00C35B  2  69 02        	ADC	#$02			; calculate end of BASIC low byte
00C35D  2  85 7B        	STA	Svarl			; save start of vars low byte
00C35F  2  A5 7A        	LDA	Smemh			; get start of mem high byte
00C361  2  69 00        	ADC	#$00			; add any carry
00C363  2  85 7C        	STA	Svarh			; save start of vars high byte
00C365  2               
00C365  2               ; reset execution to start, clear vars and flush stack
00C365  2               
00C365  2               LAB_1477
00C365  2  18           	CLC				; clear carry
00C366  2  A5 79        	LDA	Smeml			; get start of mem low byte
00C368  2  69 FF        	ADC	#$FF			; -1
00C36A  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00C36C  2  A5 7A        	LDA	Smemh			; get start of mem high byte
00C36E  2  69 FF        	ADC	#$FF			; -1+carry
00C370  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00C372  2               
00C372  2               ; "CLEAR" command gets here
00C372  2               
00C372  2               LAB_147A
00C372  2  A5 85        	LDA	Ememl			; get end of mem low byte
00C374  2  A4 86        	LDY	Ememh			; get end of mem high byte
00C376  2  85 81        	STA	Sstorl		; set bottom of string space low byte
00C378  2  84 82        	STY	Sstorh		; set bottom of string space high byte
00C37A  2  A5 7B        	LDA	Svarl			; get start of vars low byte
00C37C  2  A4 7C        	LDY	Svarh			; get start of vars high byte
00C37E  2  85 7D        	STA	Sarryl		; save var mem end low byte
00C380  2  84 7E        	STY	Sarryh		; save var mem end high byte
00C382  2  85 7F        	STA	Earryl		; save array mem end low byte
00C384  2  84 80        	STY	Earryh		; save array mem end high byte
00C386  2  20 44 C5     	JSR	LAB_161A		; perform RESTORE command
00C389  2               
00C389  2               ; flush stack and clear continue flag
00C389  2               
00C389  2               LAB_1491
00C389  2  A2 68        	LDX	#des_sk		; set descriptor stack pointer
00C38B  2  86 65        	STX	next_s		; save descriptor stack pointer
00C38D  2  68           	PLA				; pull return address low byte
00C38E  2  AA           	TAX				; copy return address low byte
00C38F  2  68           	PLA				; pull return address high byte
00C390  2  8E FE 01     	STX	LAB_SKFE		; save to cleared stack
00C393  2  8D FF 01     	STA	LAB_SKFF		; save to cleared stack
00C396  2  A2 FD        	LDX	#$FD			; new stack pointer
00C398  2  9A           	TXS				; reset stack
00C399  2  A9 00        	LDA	#$00			; clear byte
00C39B  2  85 8C        	STA	Cpntrh		; clear continue pointer high byte
00C39D  2  85 61        	STA	Sufnxf		; clear subscript/FNX flag
00C39F  2               LAB_14A6
00C39F  2  60           	RTS
00C3A0  2               
00C3A0  2               ; perform CLEAR
00C3A0  2               
00C3A0  2               LAB_CLEAR
00C3A0  2  F0 D0        	BEQ	LAB_147A		; if no following token go do "CLEAR"
00C3A2  2               
00C3A2  2               					; else there was a following token (go do syntax error)
00C3A2  2  60           	RTS
00C3A3  2               
00C3A3  2               ; perform LIST [n][-m]
00C3A3  2               ; bigger, faster version (a _lot_ faster)
00C3A3  2               
00C3A3  2               LAB_LIST
00C3A3  2  90 06        	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
00C3A5  2               
00C3A5  2  F0 04        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
00C3A7  2               
00C3A7  2  C9 B7        	CMP	#TK_MINUS		; compare with token for -
00C3A9  2  D0 F4        	BNE	LAB_14A6		; exit if not - (LIST -m)
00C3AB  2               
00C3AB  2               					; LIST [[n][-m]]
00C3AB  2               					; this bit sets the n , if present, as the start and end
00C3AB  2               LAB_14BD
00C3AB  2  20 55 C7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
00C3AE  2  20 24 C3     	JSR	LAB_SSLN		; search BASIC for temp integer line number
00C3B1  2               					; (pointer in Baslnl/Baslnh)
00C3B1  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C3B4  2  F0 0C        	BEQ	LAB_14D4		; branch if no more characters
00C3B6  2               
00C3B6  2               					; this bit checks the - is present
00C3B6  2  C9 B7        	CMP	#TK_MINUS		; compare with token for -
00C3B8  2  D0 93        	BNE	LAB_1460		; return if not "-" (will be Syntax error)
00C3BA  2               
00C3BA  2               					; LIST [n]-m
00C3BA  2               					; the - was there so set m as the end value
00C3BA  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C3BD  2  20 55 C7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
00C3C0  2  D0 8B        	BNE	LAB_1460		; exit if not ok
00C3C2  2               
00C3C2  2               LAB_14D4
00C3C2  2  A5 11        	LDA	Itempl		; get temporary integer low byte
00C3C4  2  05 12        	ORA	Itemph		; OR temporary integer high byte
00C3C6  2  D0 06        	BNE	LAB_14E2		; branch if start set
00C3C8  2               
00C3C8  2  A9 FF        	LDA	#$FF			; set for -1
00C3CA  2  85 11        	STA	Itempl		; set temporary integer low byte
00C3CC  2  85 12        	STA	Itemph		; set temporary integer high byte
00C3CE  2               LAB_14E2
00C3CE  2  A0 01        	LDY	#$01			; set index for line
00C3D0  2  84 60        	STY	Oquote		; clear open quote flag
00C3D2  2  20 92 C8     	JSR	LAB_CRLF		; print CR/LF
00C3D5  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
00C3D7  2               					; pointer initially set by search at LAB_14BD
00C3D7  2  F0 3E        	BEQ	LAB_152B		; if null all done so exit
00C3D9  2  20 14 C5     	JSR	LAB_1629		; do CRTL-C check vector
00C3DC  2               
00C3DC  2  C8           	INY				; increment index for line
00C3DD  2  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
00C3DF  2  AA           	TAX				; copy to X
00C3E0  2  C8           	INY				; increment index
00C3E1  2  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
00C3E3  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00C3E5  2  D0 04        	BNE	LAB_14FF		; branch if no high byte match
00C3E7  2               
00C3E7  2  E4 11        	CPX	Itempl		; compare with temporary integer low byte
00C3E9  2  F0 02        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
00C3EB  2               
00C3EB  2               LAB_14FF				; else ..
00C3EB  2  B0 2A        	BCS	LAB_152B		; if greater all done so exit
00C3ED  2               
00C3ED  2               LAB_1501
00C3ED  2  84 97        	STY	Tidx1			; save index for line
00C3EF  2  20 82 DA     	JSR	LAB_295E		; print XA as unsigned integer
00C3F2  2  A9 20        	LDA	#$20			; space is the next character
00C3F4  2               LAB_1508
00C3F4  2  A4 97        	LDY	Tidx1			; get index for line
00C3F6  2  29 7F        	AND	#$7F			; mask top out bit of character
00C3F8  2               LAB_150C
00C3F8  2  20 ED C8     	JSR	LAB_PRNA		; go print the character
00C3FB  2  C9 22        	CMP	#$22			; was it " character
00C3FD  2  D0 06        	BNE	LAB_1519		; branch if not
00C3FF  2               
00C3FF  2               					; we are either entering or leaving a pair of quotes
00C3FF  2  A5 60        	LDA	Oquote		; get open quote flag
00C401  2  49 FF        	EOR	#$FF			; toggle it
00C403  2  85 60        	STA	Oquote		; save it back
00C405  2               LAB_1519
00C405  2  C8           	INY				; increment index
00C406  2  B1 AA        	LDA	(Baslnl),Y		; get next byte
00C408  2  D0 0E        	BNE	LAB_152E		; branch if not [EOL] (go print character)
00C40A  2  A8           	TAY				; else clear index
00C40B  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
00C40D  2  AA           	TAX				; copy to X
00C40E  2  C8           	INY				; increment index
00C40F  2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
00C411  2  86 AA        	STX	Baslnl		; set pointer to line low byte
00C413  2  85 AB        	STA	Baslnh		; set pointer to line high byte
00C415  2  D0 B7        	BNE	LAB_14E2		; go do next line if not [EOT]
00C417  2               					; else ..
00C417  2               LAB_152B
00C417  2  60           	RTS
00C418  2               
00C418  2               LAB_152E
00C418  2  10 DE        	BPL	LAB_150C		; just go print it if not token byte
00C41A  2               
00C41A  2               					; else was token byte so uncrunch it (maybe)
00C41A  2  24 60        	BIT	Oquote		; test the open quote flag
00C41C  2  30 DA        	BMI	LAB_150C		; just go print character if open quote set
00C41E  2               
00C41E  2  A2 E5        	LDX	#>LAB_KEYT		; get table address high byte
00C420  2  0A           	ASL				; *2
00C421  2  0A           	ASL				; *4
00C422  2  90 02        	BCC	LAB_152F		; branch if no carry
00C424  2               
00C424  2  E8           	INX				; else increment high byte
00C425  2  18           	CLC				; clear carry for add
00C426  2               LAB_152F
00C426  2  69 11        	ADC	#<LAB_KEYT		; add low byte
00C428  2  90 01        	BCC	LAB_1530		; branch if no carry
00C42A  2               
00C42A  2  E8           	INX				; else increment high byte
00C42B  2               LAB_1530
00C42B  2  85 73        	STA	ut2_pl		; save table pointer low byte
00C42D  2  86 74        	STX	ut2_ph		; save table pointer high byte
00C42F  2  84 97        	STY	Tidx1			; save index for line
00C431  2  A0 00        	LDY	#$00			; clear index
00C433  2  B1 73        	LDA	(ut2_pl),Y		; get length
00C435  2  AA           	TAX				; copy length
00C436  2  C8           	INY				; increment index
00C437  2  B1 73        	LDA	(ut2_pl),Y		; get 1st character
00C439  2  CA           	DEX				; decrement length
00C43A  2  F0 B8        	BEQ	LAB_1508		; if no more characters exit and print
00C43C  2               
00C43C  2  20 ED C8     	JSR	LAB_PRNA		; go print the character
00C43F  2  C8           	INY				; increment index
00C440  2  B1 73        	LDA	(ut2_pl),Y		; get keyword address low byte
00C442  2  48           	PHA				; save it for now
00C443  2  C8           	INY				; increment index
00C444  2  B1 73        	LDA	(ut2_pl),Y		; get keyword address high byte
00C446  2  A0 00        	LDY	#$00
00C448  2  85 74        	STA	ut2_ph		; save keyword pointer high byte
00C44A  2  68           	PLA				; pull low byte
00C44B  2  85 73        	STA	ut2_pl		; save keyword pointer low byte
00C44D  2               LAB_1540
00C44D  2  B1 73        	LDA	(ut2_pl),Y		; get character
00C44F  2  CA           	DEX				; decrement character count
00C450  2  F0 A2        	BEQ	LAB_1508		; if last character exit and print
00C452  2               
00C452  2  20 ED C8     	JSR	LAB_PRNA		; go print the character
00C455  2  C8           	INY				; increment index
00C456  2  D0 F5        	BNE	LAB_1540		; loop for next character
00C458  2               
00C458  2               ; perform FOR
00C458  2               
00C458  2               LAB_FOR
00C458  2  A9 80        	LDA	#$80			; set FNX
00C45A  2  85 61        	STA	Sufnxf		; set subscript/FNX flag
00C45C  2  20 B4 C7     	JSR	LAB_LET		; go do LET
00C45F  2  68           	PLA				; pull return address
00C460  2  68           	PLA				; pull return address
00C461  2  A9 10        	LDA	#$10			; we need 16d bytes !
00C463  2  20 03 C1     	JSR	LAB_1212		; check room on stack for A bytes
00C466  2  20 9D C6     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
00C469  2  18           	CLC				; clear carry for add
00C46A  2  98           	TYA				; copy index to A
00C46B  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00C46D  2  48           	PHA				; push onto stack
00C46E  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00C470  2  69 00        	ADC	#$00			; add carry
00C472  2  48           	PHA				; push onto stack
00C473  2  A5 88        	LDA	Clineh		; get current line high byte
00C475  2  48           	PHA				; push onto stack
00C476  2  A5 87        	LDA	Clinel		; get current line low byte
00C478  2  48           	PHA				; push onto stack
00C479  2  A9 AD        	LDA	#TK_TO		; get "TO" token
00C47B  2  20 F1 CB     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
00C47E  2  20 D0 CA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00C481  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00C484  2               					; else do type mismatch
00C484  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00C486  2  09 7F        	ORA	#$7F			; set all non sign bits
00C488  2  25 AD        	AND	FAC1_1		; and FAC1 mantissa1
00C48A  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00C48C  2  A9 97        	LDA	#<LAB_159F		; set return address low byte
00C48E  2  A0 C4        	LDY	#>LAB_159F		; set return address high byte
00C490  2  85 71        	STA	ut1_pl		; save return address low byte
00C492  2  84 72        	STY	ut1_ph		; save return address high byte
00C494  2  4C 84 CB     	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
00C497  2               
00C497  2               LAB_159F
00C497  2  A9 E0        	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
00C499  2  A0 E1        	LDY	#>LAB_259C		; set 1 pointer high addr
00C49B  2  20 7D D8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
00C49E  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C4A1  2  C9 B2        	CMP	#TK_STEP		; compare with STEP token
00C4A3  2  D0 06        	BNE	LAB_15B3		; jump if not "STEP"
00C4A5  2               
00C4A5  2               					;.was step so ..
00C4A5  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C4A8  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00C4AB  2               					; else do type mismatch
00C4AB  2               LAB_15B3
00C4AB  2  20 E9 D8     	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
00C4AE  2  85 B0        	STA	FAC1_s		; set FAC1 sign (b7)
00C4B0  2               					; this is +1 for +ve step and -1 for -ve step, in NEXT we
00C4B0  2               					; compare the FOR value and the TO value and return +1 if
00C4B0  2               					; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
00C4B0  2               					; here (+/-1) is then compared to that result and if they
00C4B0  2               					; are the same (+ve and FOR > TO or -ve and FOR < TO) then
00C4B0  2               					; the loop is done
00C4B0  2  20 79 CB     	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
00C4B3  2  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
00C4B5  2  48           	PHA				; push on stack
00C4B6  2  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
00C4B8  2  48           	PHA				; push on stack
00C4B9  2  A9 81        	LDA	#TK_FOR		; get FOR token
00C4BB  2  48           	PHA				; push on stack
00C4BC  2               
00C4BC  2               ; interpreter inner loop
00C4BC  2               
00C4BC  2               LAB_15C2
00C4BC  2  20 14 C5     	JSR	LAB_1629		; do CRTL-C check vector
00C4BF  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00C4C1  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00C4C3  2               
00C4C3  2  A6 88        	LDX	Clineh		; continue line is $FFxx for immediate mode
00C4C5  2               					; ($00xx for RUN from immediate mode)
00C4C5  2  E8           	INX				; increment it (now $00 if immediate mode)
00C4C6  2  F0 04        	BEQ	LAB_15D1		; branch if null (immediate mode)
00C4C8  2               
00C4C8  2  85 8B        	STA	Cpntrl		; save continue pointer low byte
00C4CA  2  84 8C        	STY	Cpntrh		; save continue pointer high byte
00C4CC  2               LAB_15D1
00C4CC  2  A0 00        	LDY	#$00			; clear index
00C4CE  2  B1 C3        	LDA	(Bpntrl),Y		; get next byte
00C4D0  2  F0 07        	BEQ	LAB_15DC		; branch if null [EOL]
00C4D2  2               
00C4D2  2  C9 3A        	CMP	#':'			; compare with ":"
00C4D4  2  F0 1D        	BEQ	LAB_15F6		; branch if = (statement separator)
00C4D6  2               
00C4D6  2               LAB_15D9
00C4D6  2  4C 02 CC     	JMP	LAB_SNER		; else syntax error then warm start
00C4D9  2               
00C4D9  2               					; have reached [EOL]
00C4D9  2               LAB_15DC
00C4D9  2  A0 02        	LDY	#$02			; set index
00C4DB  2  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
00C4DD  2  18           	CLC				; clear carry for no "BREAK" message
00C4DE  2  F0 56        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
00C4E0  2               					; marker)
00C4E0  2               
00C4E0  2  C8           	INY				; increment index
00C4E1  2  B1 C3        	LDA	(Bpntrl),Y		; get line # low byte
00C4E3  2  85 87        	STA	Clinel		; save current line low byte
00C4E5  2  C8           	INY				; increment index
00C4E6  2  B1 C3        	LDA	(Bpntrl),Y		; get line # high byte
00C4E8  2  85 88        	STA	Clineh		; save current line high byte
00C4EA  2  98           	TYA				; A now = 4
00C4EB  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00C4ED  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00C4EF  2  90 02        	BCC	LAB_15F6		; branch if no overflow
00C4F1  2               
00C4F1  2  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
00C4F3  2               LAB_15F6
00C4F3  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C4F6  2               
00C4F6  2               LAB_15F9
00C4F6  2  20 FC C4     	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
00C4F9  2               
00C4F9  2               LAB_15FC
00C4F9  2  4C BC C4     	JMP	LAB_15C2		; loop
00C4FC  2               
00C4FC  2               ; interpret BASIC code from (Bpntrl)
00C4FC  2               
00C4FC  2               LAB_15FF
00C4FC  2  F0 54        	BEQ	LAB_1628		; exit if zero [EOL]
00C4FE  2               
00C4FE  2               LAB_1602
00C4FE  2  0A           	ASL				; *2 bytes per vector and normalise token
00C4FF  2  B0 03        	BCS	LAB_1609		; branch if was token
00C501  2               
00C501  2  4C B4 C7     	JMP	LAB_LET		; else go do implied LET
00C504  2               
00C504  2               LAB_1609
00C504  2  C9 56        	CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
00C506  2  B0 CE        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
00C508  2               					; only tokens before TAB can start a line
00C508  2  A8           	TAY				; copy to index
00C509  2  B9 08 E2     	LDA	LAB_CTBL+1,Y	; get vector high byte
00C50C  2  48           	PHA				; onto stack
00C50D  2  B9 07 E2     	LDA	LAB_CTBL,Y		; get vector low byte
00C510  2  48           	PHA				; onto stack
00C511  2  4C BC 00     	JMP	LAB_IGBY		; jump to increment and scan memory
00C514  2               					; then "return" to vector
00C514  2               
00C514  2               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
00C514  2               ; key press is detected.
00C514  2               
00C514  2               LAB_1629
00C514  2  6C 03 02     	JMP	(VEC_CC)		; ctrl c check vector
00C517  2               
00C517  2               ; if there was a key press it gets back here ..
00C517  2               
00C517  2               LAB_1636
00C517  2  C9 03        	CMP	#$03			; compare with CTRL-C
00C519  2               
00C519  2               ; perform STOP
00C519  2               
00C519  2               LAB_STOP
00C519  2  B0 01        	BCS	LAB_163B		; branch if token follows STOP
00C51B  2               					; else just END
00C51B  2               ; END
00C51B  2               
00C51B  2               LAB_END
00C51B  2  18           	CLC				; clear the carry, indicate a normal program end
00C51C  2               LAB_163B
00C51C  2  D0 67        	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
00C51E  2               
00C51E  2  A5 C4        	LDA	Bpntrh		; get the BASIC execute pointer high byte
00C520  2  49 02        	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
00C522  2  F0 10        	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
00C524  2               					; (can't continue in immediate mode)
00C524  2               
00C524  2               					; else ..
00C524  2  49 02        	EOR	#>Ibuffs		; correct the bits
00C526  2  A4 C3        	LDY	Bpntrl		; get BASIC execute pointer low byte
00C528  2  84 8B        	STY	Cpntrl		; save continue pointer low byte
00C52A  2  85 8C        	STA	Cpntrh		; save continue pointer high byte
00C52C  2               LAB_1647
00C52C  2  A5 87        	LDA	Clinel		; get current line low byte
00C52E  2  A4 88        	LDY	Clineh		; get current line high byte
00C530  2  85 89        	STA	Blinel		; save break line low byte
00C532  2  84 8A        	STY	Blineh		; save break line high byte
00C534  2               LAB_164F
00C534  2  68           	PLA				; pull return address low
00C535  2  68           	PLA				; pull return address high
00C536  2               LAB_1651
00C536  2  90 07        	BCC	LAB_165E		; if was program end just do warm start
00C538  2               
00C538  2               					; else ..
00C538  2  A9 DE        	LDA	#<LAB_BMSG		; point to "Break" low byte
00C53A  2  A0 E7        	LDY	#>LAB_BMSG		; point to "Break" high byte
00C53C  2  4C 4F C1     	JMP	LAB_1269		; print "Break" and do warm start
00C53F  2               
00C53F  2               LAB_165E
00C53F  2  4C 5A C1     	JMP	LAB_1274		; go do warm start
00C542  2               
00C542  2               ; perform RESTORE
00C542  2               
00C542  2               LAB_RESTORE
00C542  2  D0 0F        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
00C544  2               
00C544  2               LAB_161A
00C544  2  38           	SEC				; set carry for subtract
00C545  2  A5 79        	LDA	Smeml			; get start of mem low byte
00C547  2  E9 01        	SBC	#$01			; -1
00C549  2  A4 7A        	LDY	Smemh			; get start of mem high byte
00C54B  2  B0 01        	BCS	LAB_1624		; branch if no underflow
00C54D  2               
00C54D  2               LAB_uflow
00C54D  2  88           	DEY				; else decrement high byte
00C54E  2               LAB_1624
00C54E  2  85 8F        	STA	Dptrl			; save DATA pointer low byte
00C550  2  84 90        	STY	Dptrh			; save DATA pointer high byte
00C552  2               LAB_1628
00C552  2  60           	RTS
00C553  2               
00C553  2               					; is RESTORE n
00C553  2               LAB_RESTOREn
00C553  2  20 55 C7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
00C556  2  20 A0 C6     	JSR	LAB_SNBL		; scan for next BASIC line
00C559  2  A5 88        	LDA	Clineh		; get current line high byte
00C55B  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00C55D  2  B0 0B        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
00C55F  2               
00C55F  2  98           	TYA				; else copy line index to A
00C560  2  38           	SEC				; set carry (+1)
00C561  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00C563  2  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
00C565  2  90 07        	BCC	LAB_go_search	; branch if no overflow to high byte
00C567  2               
00C567  2  E8           	INX				; increment high byte
00C568  2  B0 04        	BCS	LAB_go_search	; branch always (can never be carry clear)
00C56A  2               
00C56A  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00C56A  2               
00C56A  2               LAB_reset_search
00C56A  2  A5 79        	LDA	Smeml			; get start of mem low byte
00C56C  2  A6 7A        	LDX	Smemh			; get start of mem high byte
00C56E  2               
00C56E  2               ; search for line # in temp (Itempl/Itemph) from (AX)
00C56E  2               
00C56E  2               LAB_go_search
00C56E  2               
00C56E  2  20 28 C3     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
00C571  2  B0 03        	BCS	LAB_line_found	; if carry set go set pointer
00C573  2               
00C573  2  4C 72 C6     	JMP	LAB_16F7		; else go do "Undefined statement" error
00C576  2               
00C576  2               LAB_line_found
00C576  2               					; carry already set for subtract
00C576  2  A5 AA        	LDA	Baslnl		; get pointer low byte
00C578  2  E9 01        	SBC	#$01			; -1
00C57A  2  A4 AB        	LDY	Baslnh		; get pointer high byte
00C57C  2  B0 D0        	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
00C57E  2               
00C57E  2  90 CD        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
00C580  2               					; return (branch always)
00C580  2               
00C580  2               ; perform NULL
00C580  2               
00C580  2               LAB_NULL
00C580  2  20 8C D4     	JSR	LAB_GTBY		; get byte parameter
00C583  2  86 0D        	STX	Nullct		; save new NULL count
00C585  2               LAB_167A
00C585  2  60           	RTS
00C586  2               
00C586  2               ; perform CONT
00C586  2               
00C586  2               LAB_CONT
00C586  2  D0 FD        	BNE	LAB_167A		; if following byte exit to do syntax error
00C588  2               
00C588  2  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
00C58A  2  D0 05        	BNE	LAB_166C		; go do continue if we can
00C58C  2               
00C58C  2  A2 1E        	LDX	#$1E			; error code $1E ("Can't continue" error)
00C58E  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00C591  2               
00C591  2               					; we can continue so ..
00C591  2               LAB_166C
00C591  2  A9 93        	LDA	#TK_ON		; set token for ON
00C593  2  20 14 DF     	JSR	LAB_IRQ		; set IRQ flags
00C596  2  A9 93        	LDA	#TK_ON		; set token for ON
00C598  2  20 17 DF     	JSR	LAB_NMI		; set NMI flags
00C59B  2               
00C59B  2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
00C59D  2  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
00C59F  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00C5A1  2  A5 89        	LDA	Blinel		; get break line low byte
00C5A3  2  A4 8A        	LDY	Blineh		; get break line high byte
00C5A5  2  85 87        	STA	Clinel		; set current line low byte
00C5A7  2  84 88        	STY	Clineh		; set current line high byte
00C5A9  2  60           	RTS
00C5AA  2               
00C5AA  2               ; perform RUN
00C5AA  2               
00C5AA  2               LAB_RUN
00C5AA  2  D0 03        	BNE	LAB_1696		; branch if RUN n
00C5AC  2  4C 65 C3     	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
00C5AF  2               					; return
00C5AF  2               
00C5AF  2               ; does RUN n
00C5AF  2               
00C5AF  2               LAB_1696
00C5AF  2  20 72 C3     	JSR	LAB_147A		; go do "CLEAR"
00C5B2  2  F0 2E        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
00C5B4  2               
00C5B4  2               ; perform DO
00C5B4  2               
00C5B4  2               LAB_DO
00C5B4  2  A9 05        	LDA	#$05			; need 5 bytes for DO
00C5B6  2  20 03 C1     	JSR	LAB_1212		; check room on stack for A bytes
00C5B9  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00C5BB  2  48           	PHA				; push on stack
00C5BC  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00C5BE  2  48           	PHA				; push on stack
00C5BF  2  A5 88        	LDA	Clineh		; get current line high byte
00C5C1  2  48           	PHA				; push on stack
00C5C2  2  A5 87        	LDA	Clinel		; get current line low byte
00C5C4  2  48           	PHA				; push on stack
00C5C5  2  A9 9D        	LDA	#TK_DO		; token for DO
00C5C7  2  48           	PHA				; push on stack
00C5C8  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C5CB  2  4C BC C4     	JMP	LAB_15C2		; go do interpreter inner loop
00C5CE  2               
00C5CE  2               ; perform GOSUB
00C5CE  2               
00C5CE  2               LAB_GOSUB
00C5CE  2  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
00C5D0  2  20 03 C1     	JSR	LAB_1212		; check room on stack for A bytes
00C5D3  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00C5D5  2  48           	PHA				; push on stack
00C5D6  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00C5D8  2  48           	PHA				; push on stack
00C5D9  2  A5 88        	LDA	Clineh		; get current line high byte
00C5DB  2  48           	PHA				; push on stack
00C5DC  2  A5 87        	LDA	Clinel		; get current line low byte
00C5DE  2  48           	PHA				; push on stack
00C5DF  2  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
00C5E1  2  48           	PHA				; push on stack
00C5E2  2               LAB_16B0
00C5E2  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C5E5  2  20 EB C5     	JSR	LAB_GOTO		; perform GOTO n
00C5E8  2  4C BC C4     	JMP	LAB_15C2		; go do interpreter inner loop
00C5EB  2               					; (can't RTS, we used the stack!)
00C5EB  2               
00C5EB  2               ; perform GOTO
00C5EB  2               
00C5EB  2               LAB_GOTO
00C5EB  2  20 55 C7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
00C5EE  2  20 A0 C6     	JSR	LAB_SNBL		; scan for next BASIC line
00C5F1  2  A5 88        	LDA	Clineh		; get current line high byte
00C5F3  2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00C5F5  2  B0 0B        	BCS	LAB_16D0		; branch if >= (start search from beginning)
00C5F7  2               
00C5F7  2  98           	TYA				; else copy line index to A
00C5F8  2  38           	SEC				; set carry (+1)
00C5F9  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00C5FB  2  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
00C5FD  2  90 07        	BCC	LAB_16D4		; branch if no overflow to high byte
00C5FF  2               
00C5FF  2  E8           	INX				; increment high byte
00C600  2  B0 04        	BCS	LAB_16D4		; branch always (can never be carry)
00C602  2               
00C602  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00C602  2               
00C602  2               LAB_16D0
00C602  2  A5 79        	LDA	Smeml			; get start of mem low byte
00C604  2  A6 7A        	LDX	Smemh			; get start of mem high byte
00C606  2               
00C606  2               ; search for line # in temp (Itempl/Itemph) from (AX)
00C606  2               
00C606  2               LAB_16D4
00C606  2  20 28 C3     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
00C609  2  90 67        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
00C60B  2               					; (unspecified statement)
00C60B  2               
00C60B  2               					; carry already set for subtract
00C60B  2  A5 AA        	LDA	Baslnl		; get pointer low byte
00C60D  2  E9 01        	SBC	#$01			; -1
00C60F  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00C611  2  A5 AB        	LDA	Baslnh		; get pointer high byte
00C613  2  E9 00        	SBC	#$00			; subtract carry
00C615  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00C617  2               LAB_16E5
00C617  2  60           	RTS
00C618  2               
00C618  2               LAB_DONOK
00C618  2  A2 22        	LDX	#$22			; error code $22 ("LOOP without DO" error)
00C61A  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00C61D  2               
00C61D  2               ; perform LOOP
00C61D  2               
00C61D  2               LAB_LOOP
00C61D  2  A8           	TAY				; save following token
00C61E  2  BA           	TSX				; copy stack pointer
00C61F  2  BD 03 01     	LDA	LAB_STAK+3,X	; get token byte from stack
00C622  2  C9 9D        	CMP	#TK_DO		; compare with DO token
00C624  2  D0 F2        	BNE	LAB_DONOK		; branch if no matching DO
00C626  2               
00C626  2  E8           	INX				; dump calling routine return address
00C627  2  E8           	INX				; dump calling routine return address
00C628  2  9A           	TXS				; correct stack
00C629  2  98           	TYA				; get saved following token back
00C62A  2  F0 20        	BEQ	LoopAlways		; if no following token loop forever
00C62C  2               					; (stack pointer in X)
00C62C  2               
00C62C  2  C9 3A        	CMP	#':'			; could be ':'
00C62E  2  F0 1C        	BEQ	LoopAlways		; if :... loop forever
00C630  2               
00C630  2  E9 B3        	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
00C632  2  AA           	TAX				; copy to X (if it was UNTIL then Y will be correct)
00C633  2  F0 04        	BEQ	DoRest		; branch if was UNTIL
00C635  2               
00C635  2  CA           	DEX				; decrement result
00C636  2  D0 62        	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
00C638  2               					; only if the token was WHILE will this fail
00C638  2               
00C638  2  CA           	DEX				; set invert result byte
00C639  2               DoRest
00C639  2  86 98        	STX	Frnxth		; save invert result byte
00C63B  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C63E  2  20 E1 CA     	JSR	LAB_EVEX		; evaluate expression
00C641  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00C643  2  F0 02        	BEQ	DoCmp			; if =0 go do straight compare
00C645  2               
00C645  2  A9 FF        	LDA	#$FF			; else set all bits
00C647  2               DoCmp
00C647  2  BA           	TSX				; copy stack pointer
00C648  2  45 98        	EOR	Frnxth		; EOR with invert byte
00C64A  2  D0 1A        	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
00C64C  2               
00C64C  2               					; loop condition wasn't met so do it again
00C64C  2               LoopAlways
00C64C  2  BD 02 01     	LDA	LAB_STAK+2,X	; get current line low byte
00C64F  2  85 87        	STA	Clinel		; save current line low byte
00C651  2  BD 03 01     	LDA	LAB_STAK+3,X	; get current line high byte
00C654  2  85 88        	STA	Clineh		; save current line high byte
00C656  2  BD 04 01     	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
00C659  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00C65B  2  BD 05 01     	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
00C65E  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00C660  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C663  2  4C BC C4     	JMP	LAB_15C2		; go do interpreter inner loop
00C666  2               
00C666  2               					; clear stack and back to interpreter loop
00C666  2               LoopDone
00C666  2  E8           	INX				; dump DO token
00C667  2  E8           	INX				; dump current line low byte
00C668  2  E8           	INX				; dump current line high byte
00C669  2  E8           	INX				; dump BASIC execute pointer low byte
00C66A  2  E8           	INX				; dump BASIC execute pointer high byte
00C66B  2  9A           	TXS				; correct stack
00C66C  2  4C 8C C6     	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
00C66F  2               
00C66F  2               ; do the return without gosub error
00C66F  2               
00C66F  2               LAB_16F4
00C66F  2  A2 04        	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)
00C671  2  2C           	.byte	$2C			; makes next line BIT LAB_0EA2
00C672  2               
00C672  2               LAB_16F7				; do undefined statement error
00C672  2  A2 0E        	LDX	#$0E			; error code $0E ("Undefined statement" error)
00C674  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00C677  2               
00C677  2               ; perform RETURN
00C677  2               
00C677  2               LAB_RETURN
00C677  2  D0 9E        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
00C679  2               
00C679  2               LAB_16E8
00C679  2  68           	PLA				; dump calling routine return address
00C67A  2  68           	PLA				; dump calling routine return address
00C67B  2  68           	PLA				; pull token
00C67C  2  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
00C67E  2  D0 EF        	BNE	LAB_16F4		; branch if no matching GOSUB
00C680  2               
00C680  2               LAB_16FF
00C680  2  68           	PLA				; pull current line low byte
00C681  2  85 87        	STA	Clinel		; save current line low byte
00C683  2  68           	PLA				; pull current line high byte
00C684  2  85 88        	STA	Clineh		; save current line high byte
00C686  2  68           	PLA				; pull BASIC execute pointer low byte
00C687  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00C689  2  68           	PLA				; pull BASIC execute pointer high byte
00C68A  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00C68C  2               
00C68C  2               					; now do the DATA statement as we could be returning into
00C68C  2               					; the middle of an ON <var> GOSUB n,m,p,q line
00C68C  2               					; (the return address used by the DATA statement is the one
00C68C  2               					; pushed before the GOSUB was executed!)
00C68C  2               
00C68C  2               ; perform DATA
00C68C  2               
00C68C  2               LAB_DATA
00C68C  2  20 9D C6     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
00C68F  2               
00C68F  2               					; set BASIC execute pointer
00C68F  2               LAB_170F
00C68F  2  98           	TYA				; copy index to A
00C690  2  18           	CLC				; clear carry for add
00C691  2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00C693  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00C695  2  90 02        	BCC	LAB_1719		; skip next if no carry
00C697  2               
00C697  2  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
00C699  2               LAB_1719
00C699  2  60           	RTS
00C69A  2               
00C69A  2               LAB_16FC
00C69A  2  4C 02 CC     	JMP	LAB_SNER		; do syntax error then warm start
00C69D  2               
00C69D  2               ; scan for next BASIC statement ([:] or [EOL])
00C69D  2               ; returns Y as index to [:] or [EOL]
00C69D  2               
00C69D  2               LAB_SNBS
00C69D  2  A2 3A        	LDX	#':'			; set look for character = ":"
00C69F  2  2C           	.byte	$2C			; makes next line BIT $00A2
00C6A0  2               
00C6A0  2               ; scan for next BASIC line
00C6A0  2               ; returns Y as index to [EOL]
00C6A0  2               
00C6A0  2               LAB_SNBL
00C6A0  2  A2 00        	LDX	#$00			; set alt search character = [EOL]
00C6A2  2  A0 00        	LDY	#$00			; set search character = [EOL]
00C6A4  2  84 5C        	STY	Asrch			; store search character
00C6A6  2               LAB_1725
00C6A6  2  8A           	TXA				; get alt search character
00C6A7  2  45 5C        	EOR	Asrch			; toggle search character, effectively swap with $00
00C6A9  2  85 5C        	STA	Asrch			; save swapped search character
00C6AB  2               LAB_172D
00C6AB  2  B1 C3        	LDA	(Bpntrl),Y		; get next byte
00C6AD  2  F0 EA        	BEQ	LAB_1719		; exit if null [EOL]
00C6AF  2               
00C6AF  2  C5 5C        	CMP	Asrch			; compare with search character
00C6B1  2  F0 E6        	BEQ	LAB_1719		; exit if found
00C6B3  2               
00C6B3  2  C8           	INY				; increment index
00C6B4  2  C9 22        	CMP	#$22			; compare current character with open quote
00C6B6  2  D0 F3        	BNE	LAB_172D		; if not open quote go get next character
00C6B8  2               
00C6B8  2  F0 EC        	BEQ	LAB_1725		; if found go swap search character for alt search character
00C6BA  2               
00C6BA  2               ; perform IF
00C6BA  2               
00C6BA  2               LAB_IF
00C6BA  2  20 E1 CA     	JSR	LAB_EVEX		; evaluate the expression
00C6BD  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C6C0  2  C9 B0        	CMP	#TK_THEN		; compare with THEN token
00C6C2  2  F0 11        	BEQ	LAB_174B		; if it was THEN go do IF
00C6C4  2               
00C6C4  2               					; wasn't IF .. THEN so must be IF .. GOTO
00C6C4  2  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
00C6C6  2  D0 D2        	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
00C6C8  2               
00C6C8  2  A6 C3        	LDX	Bpntrl		; save the basic pointer low byte
00C6CA  2  A4 C4        	LDY	Bpntrh		; save the basic pointer high byte
00C6CC  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C6CF  2  B0 C9        	BCS	LAB_16FC		; if not numeric go do syntax error
00C6D1  2               
00C6D1  2  86 C3        	STX	Bpntrl		; restore the basic pointer low byte
00C6D3  2  84 C4        	STY	Bpntrh		; restore the basic pointer high byte
00C6D5  2               LAB_174B
00C6D5  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00C6D7  2  F0 1B        	BEQ	LAB_174E		; if the result was zero go look for an ELSE
00C6D9  2               
00C6D9  2  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
00C6DC  2  B0 03        	BCS	LAB_174D		; if not numeric go do var or keyword
00C6DE  2               
00C6DE  2               LAB_174C
00C6DE  2  4C EB C5     	JMP	LAB_GOTO		; else was numeric so do GOTO n
00C6E1  2               
00C6E1  2               					; is var or keyword
00C6E1  2               LAB_174D
00C6E1  2  C9 90        	CMP	#TK_RETURN		; compare the byte with the token for RETURN
00C6E3  2  D0 03        	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
00C6E5  2               					; and return to this code to process any following code
00C6E5  2               
00C6E5  2  4C FE C4     	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
00C6E8  2               					; but don't return here
00C6E8  2               
00C6E8  2               LAB_174G
00C6E8  2  20 FC C4     	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
00C6EB  2               
00C6EB  2               ; the IF was executed and there may be a following ELSE so the code needs to return
00C6EB  2               ; here to check and ignore the ELSE if present
00C6EB  2               
00C6EB  2  A0 00        	LDY	#$00			; clear the index
00C6ED  2  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
00C6EF  2  C9 AC        	CMP	#TK_ELSE		; compare it with the token for ELSE
00C6F1  2  F0 99        	BEQ	LAB_DATA		; if ELSE ignore the following statement
00C6F3  2               
00C6F3  2               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00C6F3  2               ; following ELSE will, correctly, cause a syntax error
00C6F3  2               
00C6F3  2  60           	RTS				; else return to the interpreter inner loop
00C6F4  2               
00C6F4  2               ; perform ELSE after IF
00C6F4  2               
00C6F4  2               LAB_174E
00C6F4  2  A0 00        	LDY	#$00			; clear the BASIC byte index
00C6F6  2  A2 01        	LDX	#$01			; clear the nesting depth
00C6F8  2               LAB_1750
00C6F8  2  C8           	INY				; increment the BASIC byte index
00C6F9  2  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
00C6FB  2  F0 0F        	BEQ	LAB_1753		; if EOL go add the pointer and return
00C6FD  2               
00C6FD  2  C9 8B        	CMP	#TK_IF		; compare the byte with the token for IF
00C6FF  2  D0 03        	BNE	LAB_1752		; if not IF token skip the depth increment
00C701  2               
00C701  2  E8           	INX				; else increment the nesting depth ..
00C702  2  D0 F4        	BNE	LAB_1750		; .. and continue looking
00C704  2               
00C704  2               LAB_1752
00C704  2  C9 AC        	CMP	#TK_ELSE		; compare the byte with the token for ELSE
00C706  2  D0 F0        	BNE	LAB_1750		; if not ELSE token continue looking
00C708  2               
00C708  2  CA           	DEX				; was ELSE so decrement the nesting depth
00C709  2  D0 ED        	BNE	LAB_1750		; loop if still nested
00C70B  2               
00C70B  2  C8           	INY				; increment the BASIC byte index past the ELSE
00C70C  2               
00C70C  2               ; found the matching ELSE, now do <{n|statement}>
00C70C  2               
00C70C  2               LAB_1753
00C70C  2  98           	TYA				; else copy line index to A
00C70D  2  18           	CLC				; clear carry for add
00C70E  2  65 C3        	ADC	Bpntrl		; add the BASIC execute pointer low byte
00C710  2  85 C3        	STA	Bpntrl		; save the BASIC execute pointer low byte
00C712  2  90 02        	BCC	LAB_1754		; branch if no overflow to high byte
00C714  2               
00C714  2  E6 C4        	INC	Bpntrh		; else increment the BASIC execute pointer high byte
00C716  2               LAB_1754
00C716  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C719  2  90 C3        	BCC	LAB_174C		; if numeric do GOTO n
00C71B  2               					; the code will return to the interpreter loop at the
00C71B  2               					; tail end of the GOTO <n>
00C71B  2               
00C71B  2  4C FC C4     	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
00C71E  2               					; the code will return to the interpreter loop at the
00C71E  2               					; tail end of the <statement>
00C71E  2               
00C71E  2               ; perform REM, skip (rest of) line
00C71E  2               
00C71E  2               LAB_REM
00C71E  2  20 A0 C6     	JSR	LAB_SNBL		; scan for next BASIC line
00C721  2  4C 8F C6     	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
00C724  2               
00C724  2               LAB_16FD
00C724  2  4C 02 CC     	JMP	LAB_SNER		; do syntax error then warm start
00C727  2               
00C727  2               ; perform ON
00C727  2               
00C727  2               LAB_ON
00C727  2  C9 A9        	CMP	#TK_IRQ		; was it IRQ token ?
00C729  2  D0 03        	BNE	LAB_NOIN		; if not go check NMI
00C72B  2               
00C72B  2  4C 38 DF     	JMP	LAB_SIRQ		; else go set-up IRQ
00C72E  2               
00C72E  2               LAB_NOIN
00C72E  2  C9 AA        	CMP	#TK_NMI		; was it NMI token ?
00C730  2  D0 03        	BNE	LAB_NONM		; if not go do normal ON command
00C732  2               
00C732  2  4C 3C DF     	JMP	LAB_SNMI		; else go set-up NMI
00C735  2               
00C735  2               LAB_NONM
00C735  2  20 8C D4     	JSR	LAB_GTBY		; get byte parameter
00C738  2  48           	PHA				; push GOTO/GOSUB token
00C739  2  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
00C73B  2  F0 04        	BEQ	LAB_176B		; branch if GOSUB
00C73D  2               
00C73D  2  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
00C73F  2               LAB_1767
00C73F  2  D0 E3        	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
00C741  2               
00C741  2               
00C741  2               ; next character was GOTO or GOSUB
00C741  2               
00C741  2               LAB_176B
00C741  2  C6 AF        	DEC	FAC1_3		; decrement index (byte value)
00C743  2  D0 04        	BNE	LAB_1773		; branch if not zero
00C745  2               
00C745  2  68           	PLA				; pull GOTO/GOSUB token
00C746  2  4C FE C4     	JMP	LAB_1602		; go execute it
00C749  2               
00C749  2               LAB_1773
00C749  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C74C  2  20 55 C7     	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
00C74F  2               					; (we could LDX #',' and JSR LAB_SNBL+2, then we
00C74F  2               					; just BNE LAB_176B for the loop. should be quicker ..
00C74F  2               					; no we can't, what if we meet a colon or [EOL]?)
00C74F  2  C9 2C        	CMP	#$2C			; compare next character with ","
00C751  2  F0 EE        	BEQ	LAB_176B		; loop if ","
00C753  2               
00C753  2               LAB_177E
00C753  2  68           	PLA				; else pull keyword token (run out of options)
00C754  2               					; also dump +/-1 pointer low byte and exit
00C754  2               LAB_177F
00C754  2  60           	RTS
00C755  2               
00C755  2               ; takes n * 106 + 11 cycles where n is the number of digits
00C755  2               
00C755  2               ; get fixed-point number into temp integer
00C755  2               
00C755  2               LAB_GFPN
00C755  2  A2 00        	LDX	#$00			; clear reg
00C757  2  86 11        	STX	Itempl		; clear temporary integer low byte
00C759  2               LAB_1785
00C759  2  86 12        	STX	Itemph		; save temporary integer high byte
00C75B  2  B0 F7        	BCS	LAB_177F		; return if carry set, end of scan, character was
00C75D  2               					; not 0-9
00C75D  2               
00C75D  2  E0 19        	CPX	#$19			; compare high byte with $19
00C75F  2  A8           	TAY				; ensure Zb = 0 if the branch is taken
00C760  2  B0 DD        	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
00C762  2               					; bit does *$0A, = 64000, compare at target will fail
00C762  2               					; and do syntax error
00C762  2               
00C762  2  E9 2F        	SBC	#'0'-1		; subtract "0", $2F + carry, from byte
00C764  2  A8           	TAY				; copy binary digit
00C765  2  A5 11        	LDA	Itempl		; get temporary integer low byte
00C767  2  0A           	ASL				; *2 low byte
00C768  2  26 12        	ROL	Itemph		; *2 high byte
00C76A  2  0A           	ASL				; *2 low byte
00C76B  2  26 12        	ROL	Itemph		; *2 high byte, *4
00C76D  2  65 11        	ADC	Itempl		; + low byte, *5
00C76F  2  85 11        	STA	Itempl		; save it
00C771  2  8A           	TXA				; get high byte copy to A
00C772  2  65 12        	ADC	Itemph		; + high byte, *5
00C774  2  06 11        	ASL	Itempl		; *2 low byte, *10d
00C776  2  2A           	ROL				; *2 high byte, *10d
00C777  2  AA           	TAX				; copy high byte back to X
00C778  2  98           	TYA				; get binary digit back
00C779  2  65 11        	ADC	Itempl		; add number low byte
00C77B  2  85 11        	STA	Itempl		; save number low byte
00C77D  2  90 01        	BCC	LAB_17B3		; if no overflow to high byte get next character
00C77F  2               
00C77F  2  E8           	INX				; else increment high byte
00C780  2               LAB_17B3
00C780  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C783  2  4C 59 C7     	JMP	LAB_1785		; loop for next character
00C786  2               
00C786  2               ; perform DEC
00C786  2               
00C786  2               LAB_DEC
00C786  2  A9 E4        	LDA	#<LAB_2AFD		; set -1 pointer low byte
00C788  2  2C           	.byte	$2C			; BIT abs to skip the LDA below
00C789  2               
00C789  2               ; perform INC
00C789  2               
00C789  2               LAB_INC
00C789  2  A9 E0        	LDA	#<LAB_259C		; set 1 pointer low byte
00C78B  2               LAB_17B5
00C78B  2  48           	PHA				; save +/-1 pointer low byte
00C78C  2               LAB_17B7
00C78C  2  20 AA CD     	JSR	LAB_GVAR		; get var address
00C78F  2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
00C791  2  30 1E        	BMI	IncrErr		; exit if string
00C793  2               
00C793  2  85 97        	STA	Lvarpl		; save var address low byte
00C795  2  84 98        	STY	Lvarph		; save var address high byte
00C797  2  20 7D D8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
00C79A  2  68           	PLA				; get +/-1 pointer low byte
00C79B  2  48           	PHA				; save +/-1 pointer low byte
00C79C  2  A0 E1        	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
00C79E  2  20 BE D5     	JSR	LAB_246C		; add (AY) to FAC1
00C7A1  2  20 A3 D8     	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
00C7A4  2               
00C7A4  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C7A7  2  C9 2C        	CMP	#','			; compare with ","
00C7A9  2  D0 A8        	BNE	LAB_177E		; exit if not "," (either end or error)
00C7AB  2               
00C7AB  2               					; was "," so another INCR variable to do
00C7AB  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C7AE  2  4C 8C C7     	JMP	LAB_17B7		; go do next var
00C7B1  2               
00C7B1  2               IncrErr
00C7B1  2  4C DC CA     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
00C7B4  2               
00C7B4  2               ; perform LET
00C7B4  2               
00C7B4  2               LAB_LET
00C7B4  2  20 AA CD     	JSR	LAB_GVAR		; get var address
00C7B7  2  85 97        	STA	Lvarpl		; save var address low byte
00C7B9  2  84 98        	STY	Lvarph		; save var address high byte
00C7BB  2  A9 C1        	LDA	#TK_EQUAL		; get = token
00C7BD  2  20 F1 CB     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
00C7C0  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00C7C2  2  48           	PHA				; push data type flag
00C7C3  2  20 E1 CA     	JSR	LAB_EVEX		; evaluate expression
00C7C6  2  68           	PLA				; pop data type flag
00C7C7  2  2A           	ROL				; set carry if type = string
00C7C8  2  20 D3 CA     	JSR	LAB_CKTM		; type match check, set C for string
00C7CB  2  D0 03        	BNE	LAB_17D5		; branch if string
00C7CD  2               
00C7CD  2  4C A3 D8     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
00C7D0  2               
00C7D0  2               ; string LET
00C7D0  2               
00C7D0  2               LAB_17D5
00C7D0  2  A0 02        	LDY	#$02			; set index to pointer high byte
00C7D2  2  B1 AE        	LDA	(des_pl),Y		; get string pointer high byte
00C7D4  2  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
00C7D6  2  90 17        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
00C7D8  2               
00C7D8  2  D0 07        	BNE	LAB_17E6		; branch if >
00C7DA  2               					; else was equal so compare low bytes
00C7DA  2  88           	DEY				; decrement index
00C7DB  2  B1 AE        	LDA	(des_pl),Y		; get pointer low byte
00C7DD  2  C5 81        	CMP	Sstorl		; compare bottom of string space low byte
00C7DF  2  90 0E        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
00C7E1  2               
00C7E1  2               					; pointer was >= to bottom of string space pointer
00C7E1  2               LAB_17E6
00C7E1  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
00C7E3  2  C4 7C        	CPY	Svarh			; compare start of vars high byte
00C7E5  2  90 08        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
00C7E7  2               
00C7E7  2  D0 0D        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
00C7E9  2               
00C7E9  2               					; else high bytes were equal so ..
00C7E9  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00C7EB  2  C5 7B        	CMP	Svarl			; compare start of vars low byte
00C7ED  2  B0 07        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
00C7EF  2               
00C7EF  2               LAB_17F4
00C7EF  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00C7F1  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
00C7F3  2  4C 0C C8     	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
00C7F6  2               
00C7F6  2               					; make space and copy string
00C7F6  2               LAB_17FB
00C7F6  2  A0 00        	LDY	#$00			; index to length
00C7F8  2  B1 AE        	LDA	(des_pl),Y		; get string length
00C7FA  2  20 32 D1     	JSR	LAB_209C		; copy string
00C7FD  2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
00C7FF  2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
00C801  2  85 B8        	STA	ssptr_l		; save descriptor pointer low byte
00C803  2  84 B9        	STY	ssptr_h		; save descriptor pointer high byte
00C805  2  20 11 D3     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
00C808  2  A9 AC        	LDA	#<FAC1_e		; set descriptor pointer low byte
00C80A  2  A0 00        	LDY	#>FAC1_e		; get descriptor pointer high byte
00C80C  2               
00C80C  2               					; clean stack and assign value to string variable
00C80C  2               LAB_1811
00C80C  2  85 9E        	STA	des_2l		; save descriptor_2 pointer low byte
00C80E  2  84 9F        	STY	des_2h		; save descriptor_2 pointer high byte
00C810  2  20 73 D3     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
00C813  2  A0 00        	LDY	#$00			; index to length
00C815  2  B1 9E        	LDA	(des_2l),Y		; get string length
00C817  2  91 97        	STA	(Lvarpl),Y		; copy to let string variable
00C819  2  C8           	INY				; index to string pointer low byte
00C81A  2  B1 9E        	LDA	(des_2l),Y		; get string pointer low byte
00C81C  2  91 97        	STA	(Lvarpl),Y		; copy to let string variable
00C81E  2  C8           	INY				; index to string pointer high byte
00C81F  2  B1 9E        	LDA	(des_2l),Y		; get string pointer high byte
00C821  2  91 97        	STA	(Lvarpl),Y		; copy to let string variable
00C823  2  60           	RTS
00C824  2               
00C824  2               ; perform GET
00C824  2               
00C824  2               LAB_GET
00C824  2  20 AA CD     	JSR	LAB_GVAR		; get var address
00C827  2  85 97        	STA	Lvarpl		; save var address low byte
00C829  2  84 98        	STY	Lvarph		; save var address high byte
00C82B  2  20 00 DF     	JSR	INGET			; get input byte
00C82E  2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
00C830  2  30 07        	BMI	LAB_GETS		; go get string character
00C832  2               
00C832  2               					; was numeric get
00C832  2  A8           	TAY				; copy character to Y
00C833  2  20 66 D0     	JSR	LAB_1FD0		; convert Y to byte in FAC1
00C836  2  4C A3 D8     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
00C839  2               
00C839  2               LAB_GETS
00C839  2  48           	PHA				; save character
00C83A  2  A9 01        	LDA	#$01			; string is single byte
00C83C  2  B0 01        	BCS	LAB_IsByte		; branch if byte received
00C83E  2               
00C83E  2  68           	PLA				; string is null
00C83F  2               LAB_IsByte
00C83F  2  20 3A D1     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
00C842  2               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00C842  2  F0 05        	BEQ	LAB_NoSt		; skip store if null string
00C844  2               
00C844  2  68           	PLA				; get character back
00C845  2  A0 00        	LDY	#$00			; clear index
00C847  2  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
00C849  2               LAB_NoSt
00C849  2  20 85 D1     	JSR	LAB_RTST		; check for space on descriptor stack then put address
00C84C  2               					; and length on descriptor stack and update stack pointers
00C84C  2               
00C84C  2  4C D0 C7     	JMP	LAB_17D5		; do string LET and return
00C84F  2               
00C84F  2               ; perform PRINT
00C84F  2               
00C84F  2               LAB_1829
00C84F  2  20 D6 C8     	JSR	LAB_18C6		; print string from Sutill/Sutilh
00C852  2               LAB_182C
00C852  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C855  2               
00C855  2               ; PRINT
00C855  2               
00C855  2               LAB_PRINT
00C855  2  F0 3B        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
00C857  2               
00C857  2               LAB_1831
00C857  2  C9 AB        	CMP	#TK_TAB		; compare with TAB( token
00C859  2  F0 56        	BEQ	LAB_18A2		; go do TAB/SPC
00C85B  2               
00C85B  2  C9 AF        	CMP	#TK_SPC		; compare with SPC( token
00C85D  2  F0 52        	BEQ	LAB_18A2		; go do TAB/SPC
00C85F  2               
00C85F  2  C9 2C        	CMP	#','			; compare with ","
00C861  2  F0 38        	BEQ	LAB_188B		; go do move to next TAB mark
00C863  2               
00C863  2  C9 3B        	CMP	#';'			; compare with ";"
00C865  2  F0 66        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
00C867  2               
00C867  2  20 E1 CA     	JSR	LAB_EVEX		; evaluate expression
00C86A  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00C86C  2  30 E1        	BMI	LAB_1829		; branch if string
00C86E  2               
00C86E  2  20 95 DA     	JSR	LAB_296E		; convert FAC1 to string
00C871  2  20 44 D1     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
00C874  2  A0 00        	LDY	#$00			; clear index
00C876  2               
00C876  2               ; don't check fit if terminal width byte is zero
00C876  2               
00C876  2  A5 0F        	LDA	TWidth		; get terminal width byte
00C878  2  F0 0A        	BEQ	LAB_185E		; skip check if zero
00C87A  2               
00C87A  2  38           	SEC				; set carry for subtract
00C87B  2  E5 0E        	SBC	TPos			; subtract terminal position
00C87D  2  F1 AE        	SBC	(des_pl),Y		; subtract string length
00C87F  2  B0 03        	BCS	LAB_185E		; branch if less than terminal width
00C881  2               
00C881  2  20 92 C8     	JSR	LAB_CRLF		; else print CR/LF
00C884  2               LAB_185E
00C884  2  20 D6 C8     	JSR	LAB_18C6		; print string from Sutill/Sutilh
00C887  2  F0 C9        	BEQ	LAB_182C		; always go continue processing line
00C889  2               
00C889  2               ; CR/LF return to BASIC from BASIC input handler
00C889  2               
00C889  2               LAB_1866
00C889  2  A9 00        	LDA	#$00			; clear byte
00C88B  2  9D 21 02     	STA	Ibuffs,X		; null terminate input
00C88E  2  A2 21        	LDX	#<Ibuffs		; set X to buffer start-1 low byte
00C890  2  A0 02        	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
00C892  2               
00C892  2               ; print CR/LF
00C892  2               
00C892  2               LAB_CRLF
00C892  2  A9 0D        	LDA	#$0D			; load [CR]
00C894  2  20 ED C8     	JSR	LAB_PRNA		; go print the character
00C897  2  A9 0A        	LDA	#$0A			; load [LF]
00C899  2  D0 52        	BNE	LAB_PRNA		; go print the character and return, branch always
00C89B  2               
00C89B  2               LAB_188B
00C89B  2  A5 0E        	LDA	TPos			; get terminal position
00C89D  2  C5 10        	CMP	Iclim			; compare with input column limit
00C89F  2  90 05        	BCC	LAB_1897		; branch if less
00C8A1  2               
00C8A1  2  20 92 C8     	JSR	LAB_CRLF		; else print CR/LF (next line)
00C8A4  2  D0 27        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
00C8A6  2               
00C8A6  2               LAB_1897
00C8A6  2  38           	SEC				; set carry for subtract
00C8A7  2               LAB_1898
00C8A7  2  E5 64        	SBC	TabSiz		; subtract TAB size
00C8A9  2  B0 FC        	BCS	LAB_1898		; loop if result was +ve
00C8AB  2               
00C8AB  2  49 FF        	EOR	#$FF			; complement it
00C8AD  2  69 01        	ADC	#$01			; +1 (twos complement)
00C8AF  2  D0 12        	BNE	LAB_18B6		; always print A spaces (result is never $00)
00C8B1  2               
00C8B1  2               					; do TAB/SPC
00C8B1  2               LAB_18A2
00C8B1  2  48           	PHA				; save token
00C8B2  2  20 89 D4     	JSR	LAB_SGBY		; scan and get byte parameter
00C8B5  2  C9 29        	CMP	#$29			; is next character )
00C8B7  2  D0 7B        	BNE	LAB_1910		; if not do syntax error then warm start
00C8B9  2               
00C8B9  2  68           	PLA				; get token back
00C8BA  2  C9 AB        	CMP	#TK_TAB		; was it TAB ?
00C8BC  2  D0 06        	BNE	LAB_18B7		; if not go do SPC
00C8BE  2               
00C8BE  2               					; calculate TAB offset
00C8BE  2  8A           	TXA				; copy integer value to A
00C8BF  2  E5 0E        	SBC	TPos			; subtract terminal position
00C8C1  2  90 0A        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
00C8C3  2               
00C8C3  2               					; print A spaces
00C8C3  2               LAB_18B6
00C8C3  2  AA           	TAX				; copy result to X
00C8C4  2               LAB_18B7
00C8C4  2  8A           	TXA				; set flags on size for SPC
00C8C5  2  F0 06        	BEQ	LAB_18BD		; branch if result was = $0, already here
00C8C7  2               
00C8C7  2               					; print X spaces
00C8C7  2               LAB_18BA
00C8C7  2  20 E8 C8     	JSR	LAB_18E0		; print " "
00C8CA  2  CA           	DEX				; decrement count
00C8CB  2  D0 FA        	BNE	LAB_18BA		; loop if not all done
00C8CD  2               
00C8CD  2               					; continue with PRINT processing
00C8CD  2               LAB_18BD
00C8CD  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C8D0  2  D0 85        	BNE	LAB_1831		; if more to print go do it
00C8D2  2               
00C8D2  2  60           	RTS
00C8D3  2               
00C8D3  2               ; print null terminated string from memory
00C8D3  2               
00C8D3  2               LAB_18C3
00C8D3  2  20 44 D1     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
00C8D6  2               
00C8D6  2               ; print string from Sutill/Sutilh
00C8D6  2               
00C8D6  2               LAB_18C6
00C8D6  2  20 3E D3     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
00C8D9  2               					; space returns with A = length, X=$71=pointer low byte,
00C8D9  2               					; Y=$72=pointer high byte
00C8D9  2  A0 00        	LDY	#$00			; reset index
00C8DB  2  AA           	TAX				; copy length to X
00C8DC  2  F0 49        	BEQ	LAB_188C		; exit (RTS) if null string
00C8DE  2               
00C8DE  2               LAB_18CD
00C8DE  2               
00C8DE  2  B1 71        	LDA	(ut1_pl),Y		; get next byte
00C8E0  2  20 ED C8     	JSR	LAB_PRNA		; go print the character
00C8E3  2  C8           	INY				; increment index
00C8E4  2  CA           	DEX				; decrement count
00C8E5  2  D0 F7        	BNE	LAB_18CD		; loop if not done yet
00C8E7  2               
00C8E7  2  60           	RTS
00C8E8  2               
00C8E8  2               					; Print single format character
00C8E8  2               ; print " "
00C8E8  2               
00C8E8  2               LAB_18E0
00C8E8  2  A9 20        	LDA	#$20			; load " "
00C8EA  2  2C           	.byte	$2C			; change next line to BIT LAB_3FA9
00C8EB  2               
00C8EB  2               ; print "?" character
00C8EB  2               
00C8EB  2               LAB_18E3
00C8EB  2  A9 3F        	LDA	#$3F			; load "?" character
00C8ED  2               
00C8ED  2               ; print character in A
00C8ED  2               ; now includes the null handler
00C8ED  2               ; also includes infinite line length code
00C8ED  2               ; note! some routines expect this one to exit with Zb=0
00C8ED  2               
00C8ED  2               LAB_PRNA
00C8ED  2  C9 20        	CMP	#' '			; compare with " "
00C8EF  2  90 19        	BCC	LAB_18F9		; branch if less (non printing)
00C8F1  2               
00C8F1  2               					; else printable character
00C8F1  2  48           	PHA				; save the character
00C8F2  2               
00C8F2  2               ; don't check fit if terminal width byte is zero
00C8F2  2               
00C8F2  2  A5 0F        	LDA	TWidth		; get terminal width
00C8F4  2  D0 0A        	BNE	LAB_18F0		; branch if not zero (not infinite length)
00C8F6  2               
00C8F6  2               ; is "infinite line" so check TAB position
00C8F6  2               
00C8F6  2  A5 0E        	LDA	TPos			; get position
00C8F8  2  E5 64        	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
00C8FA  2  D0 0B        	BNE	LAB_18F7		; skip reset if different
00C8FC  2               
00C8FC  2  85 0E        	STA	TPos			; else reset position
00C8FE  2  F0 07        	BEQ	LAB_18F7		; go print character
00C900  2               
00C900  2               LAB_18F0
00C900  2  C5 0E        	CMP	TPos			; compare with terminal character position
00C902  2  D0 03        	BNE	LAB_18F7		; branch if not at end of line
00C904  2               
00C904  2  20 92 C8     	JSR	LAB_CRLF		; else print CR/LF
00C907  2               LAB_18F7
00C907  2  E6 0E        	INC	TPos			; increment terminal position
00C909  2  68           	PLA				; get character back
00C90A  2               LAB_18F9
00C90A  2  20 ED E0     	JSR	V_OUTP		; output byte via output vector
00C90D  2  C9 0D        	CMP	#$0D			; compare with [CR]
00C90F  2  D0 14        	BNE	LAB_188A		; branch if not [CR]
00C911  2               
00C911  2               					; else print nullct nulls after the [CR]
00C911  2  86 78        	STX	TempB			; save buffer index
00C913  2  A6 0D        	LDX	Nullct		; get null count
00C915  2  F0 0A        	BEQ	LAB_1886		; branch if no nulls
00C917  2               
00C917  2  A9 00        	LDA	#$00			; load [NULL]
00C919  2               LAB_1880
00C919  2  20 ED C8     	JSR	LAB_PRNA		; go print the character
00C91C  2  CA           	DEX				; decrement count
00C91D  2  D0 FA        	BNE	LAB_1880		; loop if not all done
00C91F  2               
00C91F  2  A9 0D        	LDA	#$0D			; restore the character (and set the flags)
00C921  2               LAB_1886
00C921  2  86 0E        	STX	TPos			; clear terminal position (X always = zero when we get here)
00C923  2  A6 78        	LDX	TempB			; restore buffer index
00C925  2               LAB_188A
00C925  2  29 FF        	AND	#$FF			; set the flags
00C927  2               LAB_188C
00C927  2  60           	RTS
00C928  2               
00C928  2               ; handle bad input data
00C928  2               
00C928  2               LAB_1904
00C928  2  A5 62        	LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
00C92A  2  10 0B        	BPL	LAB_1913		; branch if INPUT (go do redo)
00C92C  2               
00C92C  2  A5 8D        	LDA	Dlinel		; get current DATA line low byte
00C92E  2  A4 8E        	LDY	Dlineh		; get current DATA line high byte
00C930  2  85 87        	STA	Clinel		; save current line low byte
00C932  2  84 88        	STY	Clineh		; save current line high byte
00C934  2               LAB_1910
00C934  2  4C 02 CC     	JMP	LAB_SNER		; do syntax error then warm start
00C937  2               
00C937  2               					; mode was INPUT
00C937  2               LAB_1913
00C937  2  A9 12        	LDA	#<LAB_REDO		; point to redo message (low addr)
00C939  2  A0 E8        	LDY	#>LAB_REDO		; point to redo message (high addr)
00C93B  2  20 D3 C8     	JSR	LAB_18C3		; print null terminated string from memory
00C93E  2  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
00C940  2  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
00C942  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00C944  2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
00C946  2  60           	RTS
00C947  2               
00C947  2               ; perform INPUT
00C947  2               
00C947  2               LAB_INPUT
00C947  2  C9 22        	CMP	#$22			; compare next byte with open quote
00C949  2  D0 0B        	BNE	LAB_1934		; branch if no prompt string
00C94B  2               
00C94B  2  20 BE CB     	JSR	LAB_1BC1		; print "..." string
00C94E  2  A9 3B        	LDA	#$3B			; load A with ";"
00C950  2  20 F1 CB     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
00C953  2  20 D6 C8     	JSR	LAB_18C6		; print string from Sutill/Sutilh
00C956  2               
00C956  2               					; done with prompt, now get data
00C956  2               LAB_1934
00C956  2  20 6A D0     	JSR	LAB_CKRN		; check not Direct, back here if ok
00C959  2  20 40 C2     	JSR	LAB_INLN		; print "? " and get BASIC input
00C95C  2  A9 00        	LDA	#$00			; set mode = INPUT
00C95E  2  CD 21 02     	CMP	Ibuffs		; test first byte in buffer
00C961  2  D0 0A        	BNE	LAB_1953		; branch if not null input
00C963  2               
00C963  2  18           	CLC				; was null input so clear carry to exit program
00C964  2  4C 2C C5     	JMP	LAB_1647		; go do BREAK exit
00C967  2               
00C967  2               ; perform READ
00C967  2               
00C967  2               LAB_READ
00C967  2  A6 8F        	LDX	Dptrl			; get DATA pointer low byte
00C969  2  A4 90        	LDY	Dptrh			; get DATA pointer high byte
00C96B  2  A9 80        	LDA	#$80			; set mode = READ
00C96D  2               
00C96D  2               LAB_1953
00C96D  2  85 62        	STA	Imode			; set input mode flag, $00=INPUT, $80=READ
00C96F  2  86 91        	STX	Rdptrl		; save READ pointer low byte
00C971  2  84 92        	STY	Rdptrh		; save READ pointer high byte
00C973  2               
00C973  2               					; READ or INPUT next variable from list
00C973  2               LAB_195B
00C973  2  20 AA CD     	JSR	LAB_GVAR		; get (var) address
00C976  2  85 97        	STA	Lvarpl		; save address low byte
00C978  2  84 98        	STY	Lvarph		; save address high byte
00C97A  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00C97C  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00C97E  2  85 11        	STA	Itempl		; save as temporary integer low byte
00C980  2  84 12        	STY	Itemph		; save as temporary integer high byte
00C982  2  A6 91        	LDX	Rdptrl		; get READ pointer low byte
00C984  2  A4 92        	LDY	Rdptrh		; get READ pointer high byte
00C986  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00C988  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00C98A  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C98D  2  D0 11        	BNE	LAB_1988		; branch if not null
00C98F  2               
00C98F  2               					; pointer was to null entry
00C98F  2  24 62        	BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
00C991  2  30 65        	BMI	LAB_19DD		; branch if READ
00C993  2               
00C993  2               					; mode was INPUT
00C993  2  20 EB C8     	JSR	LAB_18E3		; print "?" character (double ? for extended input)
00C996  2  20 40 C2     	JSR	LAB_INLN		; print "? " and get BASIC input
00C999  2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00C99B  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00C99D  2               LAB_1985
00C99D  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C9A0  2               LAB_1988
00C9A0  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00C9A2  2  10 24        	BPL	LAB_19B0		; branch if numeric
00C9A4  2               
00C9A4  2               					; else get string
00C9A4  2  85 5B        	STA	Srchc			; save search character
00C9A6  2  C9 22        	CMP	#$22			; was it " ?
00C9A8  2  F0 07        	BEQ	LAB_1999		; branch if so
00C9AA  2               
00C9AA  2  A9 3A        	LDA	#':'			; else search character is ":"
00C9AC  2  85 5B        	STA	Srchc			; set new search character
00C9AE  2  A9 2C        	LDA	#','			; other search character is ","
00C9B0  2  18           	CLC				; clear carry for add
00C9B1  2               LAB_1999
00C9B1  2  85 5C        	STA	Asrch			; set second search character
00C9B3  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00C9B5  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00C9B7  2               
00C9B7  2  69 00        	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
00C9B9  2  90 01        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
00C9BB  2               
00C9BB  2  C8           	INY				; else increment high byte
00C9BC  2               LAB_19A4
00C9BC  2  20 4A D1     	JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
00C9BF  2  20 CF D4     	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
00C9C2  2  20 D0 C7     	JSR	LAB_17D5		; go do string LET
00C9C5  2  4C CE C9     	JMP	LAB_19B6		; go check string terminator
00C9C8  2               
00C9C8  2               					; get numeric INPUT
00C9C8  2               LAB_19B0
00C9C8  2  20 A6 D9     	JSR	LAB_2887		; get FAC1 from string
00C9CB  2  20 A3 D8     	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
00C9CE  2               LAB_19B6
00C9CE  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C9D1  2  F0 0A        	BEQ	LAB_19C5		; branch if null (last entry)
00C9D3  2               
00C9D3  2  C9 2C        	CMP	#','			; else compare with ","
00C9D5  2  F0 03        	BEQ	LAB_19C2		; branch if ","
00C9D7  2               
00C9D7  2  4C 28 C9     	JMP	LAB_1904		; else go handle bad input data
00C9DA  2               
00C9DA  2               					; got good input data
00C9DA  2               LAB_19C2
00C9DA  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00C9DD  2               LAB_19C5
00C9DD  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
00C9DF  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
00C9E1  2  85 91        	STA	Rdptrl		; save for now
00C9E3  2  84 92        	STY	Rdptrh		; save for now
00C9E5  2  A5 11        	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
00C9E7  2  A4 12        	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
00C9E9  2  85 C3        	STA	Bpntrl		; set BASIC execute pointer low byte
00C9EB  2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00C9ED  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00C9F0  2  F0 2C        	BEQ	LAB_1A03		; if null go do extra ignored message
00C9F2  2               
00C9F2  2  20 FE CB     	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
00C9F5  2  4C 73 C9     	JMP	LAB_195B		; go INPUT next variable from list
00C9F8  2               
00C9F8  2               					; find next DATA statement or do "Out of DATA" error
00C9F8  2               LAB_19DD
00C9F8  2  20 9D C6     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
00C9FB  2  C8           	INY				; increment index
00C9FC  2  AA           	TAX				; copy character ([:] or [EOL])
00C9FD  2  D0 12        	BNE	LAB_19F6		; branch if [:]
00C9FF  2               
00C9FF  2  A2 06        	LDX	#$06			; set for "Out of DATA" error
00CA01  2  C8           	INY				; increment index, now points to next line pointer high byte
00CA02  2  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
00CA04  2  F0 73        	BEQ	LAB_1A54		; branch if end (eventually does error X)
00CA06  2               
00CA06  2  C8           	INY				; increment index
00CA07  2  B1 C3        	LDA	(Bpntrl),Y		; get next line # low byte
00CA09  2  85 8D        	STA	Dlinel		; save current DATA line low byte
00CA0B  2  C8           	INY				; increment index
00CA0C  2  B1 C3        	LDA	(Bpntrl),Y		; get next line # high byte
00CA0E  2  C8           	INY				; increment index
00CA0F  2  85 8E        	STA	Dlineh		; save current DATA line high byte
00CA11  2               LAB_19F6
00CA11  2  B1 C3        	LDA	(Bpntrl),Y		; get byte
00CA13  2  C8           	INY				; increment index
00CA14  2  AA           	TAX				; copy to X
00CA15  2  20 8F C6     	JSR	LAB_170F		; set BASIC execute pointer
00CA18  2  E0 83        	CPX	#TK_DATA		; compare with "DATA" token
00CA1A  2  F0 81        	BEQ	LAB_1985		; was "DATA" so go do next READ
00CA1C  2               
00CA1C  2  D0 DA        	BNE	LAB_19DD		; go find next statement if not "DATA"
00CA1E  2               
00CA1E  2               ; end of INPUT/READ routine
00CA1E  2               
00CA1E  2               LAB_1A03
00CA1E  2  A5 91        	LDA	Rdptrl		; get temp READ pointer low byte
00CA20  2  A4 92        	LDY	Rdptrh		; get temp READ pointer high byte
00CA22  2  A6 62        	LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
00CA24  2  10 03        	BPL	LAB_1A0E		; branch if INPUT
00CA26  2               
00CA26  2  4C 4E C5     	JMP	LAB_1624		; save AY as DATA pointer and return
00CA29  2               
00CA29  2               					; we were getting INPUT
00CA29  2               LAB_1A0E
00CA29  2  A0 00        	LDY	#$00			; clear index
00CA2B  2  B1 91        	LDA	(Rdptrl),Y		; get next byte
00CA2D  2  D0 01        	BNE	LAB_1A1B		; error if not end of INPUT
00CA2F  2               
00CA2F  2  60           	RTS
00CA30  2               
00CA30  2               					; user typed too much
00CA30  2               LAB_1A1B
00CA30  2  A9 01        	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
00CA32  2  A0 E8        	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
00CA34  2  4C D3 C8     	JMP	LAB_18C3		; print null terminated string from memory and return
00CA37  2               
00CA37  2               ; search the stack for FOR activity
00CA37  2               ; exit with z=1 if FOR else exit with z=0
00CA37  2               
00CA37  2               LAB_11A1
00CA37  2  BA           	TSX				; copy stack pointer
00CA38  2  E8           	INX				; +1 pass return address
00CA39  2  E8           	INX				; +2 pass return address
00CA3A  2  E8           	INX				; +3 pass calling routine return address
00CA3B  2  E8           	INX				; +4 pass calling routine return address
00CA3C  2               LAB_11A6
00CA3C  2  BD 01 01     	LDA	LAB_STAK+1,X	; get token byte from stack
00CA3F  2  C9 81        	CMP	#TK_FOR		; is it FOR token
00CA41  2  D0 21        	BNE	LAB_11CE		; exit if not FOR token
00CA43  2               
00CA43  2               					; was FOR token
00CA43  2  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
00CA45  2  D0 0A        	BNE	LAB_11BB		; branch if not null
00CA47  2               
00CA47  2  BD 02 01     	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
00CA4A  2  85 97        	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
00CA4C  2  BD 03 01     	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
00CA4F  2  85 98        	STA	Frnxth		; save var pointer for FOR/NEXT high byte
00CA51  2               LAB_11BB
00CA51  2  DD 03 01     	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
00CA54  2  D0 07        	BNE	LAB_11C7		; branch if no match
00CA56  2               
00CA56  2  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
00CA58  2  DD 02 01     	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
00CA5B  2  F0 07        	BEQ	LAB_11CE		; exit if match found
00CA5D  2               
00CA5D  2               LAB_11C7
00CA5D  2  8A           	TXA				; copy index
00CA5E  2  18           	CLC				; clear carry for add
00CA5F  2  69 10        	ADC	#$10			; add FOR stack use size
00CA61  2  AA           	TAX				; copy back to index
00CA62  2  D0 D8        	BNE	LAB_11A6		; loop if not at start of stack
00CA64  2               
00CA64  2               LAB_11CE
00CA64  2  60           	RTS
00CA65  2               
00CA65  2               ; perform NEXT
00CA65  2               
00CA65  2               LAB_NEXT
00CA65  2  D0 04        	BNE	LAB_1A46		; branch if NEXT var
00CA67  2               
00CA67  2  A0 00        	LDY	#$00			; else clear Y
00CA69  2  F0 03        	BEQ	LAB_1A49		; branch always (no variable to search for)
00CA6B  2               
00CA6B  2               ; NEXT var
00CA6B  2               
00CA6B  2               LAB_1A46
00CA6B  2  20 AA CD     	JSR	LAB_GVAR		; get variable address
00CA6E  2               LAB_1A49
00CA6E  2  85 97        	STA	Frnxtl		; store variable pointer low byte
00CA70  2  84 98        	STY	Frnxth		; store variable pointer high byte
00CA72  2               					; (both cleared if no variable defined)
00CA72  2  20 37 CA     	JSR	LAB_11A1		; search the stack for FOR activity
00CA75  2  F0 04        	BEQ	LAB_1A56		; branch if found
00CA77  2               
00CA77  2  A2 00        	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
00CA79  2               LAB_1A54
00CA79  2  F0 63        	BEQ	LAB_1ABE		; do error #X, then warm start
00CA7B  2               
00CA7B  2               LAB_1A56
00CA7B  2  9A           	TXS				; set stack pointer, X set by search, dumps return addresses
00CA7C  2               
00CA7C  2  8A           	TXA				; copy stack pointer
00CA7D  2  38           	SEC				; set carry for subtract
00CA7E  2  E9 F7        	SBC	#$F7			; point to TO var
00CA80  2  85 73        	STA	ut2_pl		; save pointer to TO var for compare
00CA82  2  69 FB        	ADC	#$FB			; point to STEP var
00CA84  2               
00CA84  2  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
00CA86  2  20 7D D8     	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
00CA89  2  BA           	TSX				; get stack pointer back
00CA8A  2  BD 08 01     	LDA	LAB_STAK+8,X	; get step sign
00CA8D  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00CA8F  2  A5 97        	LDA	Frnxtl		; get FOR variable pointer low byte
00CA91  2  A4 98        	LDY	Frnxth		; get FOR variable pointer high byte
00CA93  2  20 BE D5     	JSR	LAB_246C		; add (FOR variable) to FAC1
00CA96  2  20 A3 D8     	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
00CA99  2  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
00CA9B  2  20 19 D9     	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
00CA9E  2  BA           	TSX				; get stack pointer back
00CA9F  2  DD 08 01     	CMP	LAB_STAK+8,X	; compare step sign
00CAA2  2  F0 17        	BEQ	LAB_1A9B		; branch if = (loop complete)
00CAA4  2               
00CAA4  2               					; loop back and do it all again
00CAA4  2  BD 0D 01     	LDA	LAB_STAK+$0D,X	; get FOR line low byte
00CAA7  2  85 87        	STA	Clinel		; save current line low byte
00CAA9  2  BD 0E 01     	LDA	LAB_STAK+$0E,X	; get FOR line high byte
00CAAC  2  85 88        	STA	Clineh		; save current line high byte
00CAAE  2  BD 10 01     	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
00CAB1  2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00CAB3  2  BD 0F 01     	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
00CAB6  2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00CAB8  2               LAB_1A98
00CAB8  2  4C BC C4     	JMP	LAB_15C2		; go do interpreter inner loop
00CABB  2               
00CABB  2               					; loop complete so carry on
00CABB  2               LAB_1A9B
00CABB  2  8A           	TXA				; stack copy to A
00CABC  2  69 0F        	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
00CABE  2  AA           	TAX				; copy back to index
00CABF  2  9A           	TXS				; copy to stack pointer
00CAC0  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00CAC3  2  C9 2C        	CMP	#','			; compare with ","
00CAC5  2  D0 F1        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
00CAC7  2               
00CAC7  2               					; was "," so another NEXT variable to do
00CAC7  2  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
00CACA  2  20 6B CA     	JSR	LAB_1A46		; do NEXT (var)
00CACD  2               
00CACD  2               ; evaluate expression and check is numeric, else do type mismatch
00CACD  2               
00CACD  2               LAB_EVNM
00CACD  2  20 E1 CA     	JSR	LAB_EVEX		; evaluate expression
00CAD0  2               
00CAD0  2               ; check if source is numeric, else do type mismatch
00CAD0  2               
00CAD0  2               LAB_CTNM
00CAD0  2  18           	CLC				; destination is numeric
00CAD1  2  24           	.byte	$24			; makes next line BIT $38
00CAD2  2               
00CAD2  2               ; check if source is string, else do type mismatch
00CAD2  2               
00CAD2  2               LAB_CTST
00CAD2  2  38           	SEC				; required type is string
00CAD3  2               
00CAD3  2               ; type match check, set C for string, clear C for numeric
00CAD3  2               
00CAD3  2               LAB_CKTM
00CAD3  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00CAD5  2  30 03        	BMI	LAB_1ABA		; branch if data type is string
00CAD7  2               
00CAD7  2               					; else data type was numeric
00CAD7  2  B0 03        	BCS	LAB_1ABC		; if required type is string do type mismatch error
00CAD9  2               LAB_1AB9
00CAD9  2  60           	RTS
00CADA  2               
00CADA  2               					; data type was string, now check required type
00CADA  2               LAB_1ABA
00CADA  2  B0 FD        	BCS	LAB_1AB9		; exit if required type is string
00CADC  2               
00CADC  2               					; else do type mismatch error
00CADC  2               LAB_1ABC
00CADC  2  A2 18        	LDX	#$18			; error code $18 ("Type mismatch" error)
00CADE  2               LAB_1ABE
00CADE  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00CAE1  2               
00CAE1  2               ; evaluate expression
00CAE1  2               
00CAE1  2               LAB_EVEX
00CAE1  2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
00CAE3  2  D0 02        	BNE	LAB_1AC7		; skip next if not zero
00CAE5  2               
00CAE5  2  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
00CAE7  2               LAB_1AC7
00CAE7  2  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
00CAE9  2               
00CAE9  2               LAB_EVEZ
00CAE9  2  A9 00        	LDA	#$00			; set null precedence (flag done)
00CAEB  2               LAB_1ACC
00CAEB  2  48           	PHA				; push precedence byte
00CAEC  2  A9 02        	LDA	#$02			; 2 bytes
00CAEE  2  20 03 C1     	JSR	LAB_1212		; check room on stack for A bytes
00CAF1  2  20 CD CB     	JSR	LAB_GVAL		; get value from line
00CAF4  2  A9 00        	LDA	#$00			; clear A
00CAF6  2  85 9B        	STA	comp_f		; clear compare function flag
00CAF8  2               LAB_1ADB
00CAF8  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00CAFB  2               LAB_1ADE
00CAFB  2  38           	SEC				; set carry for subtract
00CAFC  2  E9 C0        	SBC	#TK_GT		; subtract token for > (lowest comparison function)
00CAFE  2  90 17        	BCC	LAB_1AFA		; branch if < TK_GT
00CB00  2               
00CB00  2  C9 03        	CMP	#$03			; compare with ">" to "<" tokens
00CB02  2  B0 13        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
00CB04  2               
00CB04  2               					; was token for > = or < (A = 0, 1 or 2)
00CB04  2  C9 01        	CMP	#$01			; compare with token for =
00CB06  2  2A           	ROL				; *2, b0 = carry (=1 if token was = or <)
00CB07  2               					; (A = 0, 3 or 5)
00CB07  2  49 01        	EOR	#$01			; toggle b0
00CB09  2               					; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
00CB09  2  45 9B        	EOR	comp_f		; EOR with compare function flag bits
00CB0B  2  C5 9B        	CMP	comp_f		; compare with compare function flag
00CB0D  2  90 67        	BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
00CB0F  2               					; was more than one <, = or >)
00CB0F  2               
00CB0F  2  85 9B        	STA	comp_f		; save new compare function flag
00CB11  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00CB14  2  4C FB CA     	JMP	LAB_1ADE		; go do next character
00CB17  2               
00CB17  2               					; token is < ">" or > "<" tokens
00CB17  2               LAB_1AFA
00CB17  2  A6 9B        	LDX	comp_f		; get compare function flag
00CB19  2  D0 2C        	BNE	LAB_1B2A		; branch if compare function
00CB1B  2               
00CB1B  2  B0 79        	BCS	LAB_1B78		; go do functions
00CB1D  2               
00CB1D  2               					; else was <  TK_GT so is operator or lower
00CB1D  2  69 0A        	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
00CB1F  2  90 75        	BCC	LAB_1B78		; branch if < + operator
00CB21  2               
00CB21  2               					; carry was set so token was +, -, *, /, ^, AND, OR or EOR
00CB21  2  D0 07        	BNE	LAB_1B0B		; branch if not + token
00CB23  2               
00CB23  2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00CB25  2  10 03        	BPL	LAB_1B0B		; branch if not string
00CB27  2               
00CB27  2               					; will only be $00 if type is string and token was +
00CB27  2  4C D4 D2     	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
00CB2A  2               					; is in line, and return
00CB2A  2               
00CB2A  2               LAB_1B0B
00CB2A  2  85 71        	STA	ut1_pl		; save it
00CB2C  2  0A           	ASL				; *2
00CB2D  2  65 71        	ADC	ut1_pl		; *3
00CB2F  2  A8           	TAY				; copy to index
00CB30  2               LAB_1B13
00CB30  2  68           	PLA				; pull previous precedence
00CB31  2  D9 E9 E2     	CMP	LAB_OPPT,Y		; compare with precedence byte
00CB34  2  B0 65        	BCS	LAB_1B7D		; branch if A >=
00CB36  2               
00CB36  2  20 D0 CA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00CB39  2               LAB_1B1C
00CB39  2  48           	PHA				; save precedence
00CB3A  2               LAB_1B1D
00CB3A  2  20 62 CB     	JSR	LAB_1B43		; get vector, execute function then continue evaluation
00CB3D  2  68           	PLA				; restore precedence
00CB3E  2  A4 99        	LDY	prstk			; get precedence stacked flag
00CB40  2  10 19        	BPL	LAB_1B3C		; branch if stacked values
00CB42  2               
00CB42  2  AA           	TAX				; copy precedence (set flags)
00CB43  2  F0 76        	BEQ	LAB_1B9D		; exit if done
00CB45  2               
00CB45  2  D0 5D        	BNE	LAB_1B86		; else pop FAC2 and return, branch always
00CB47  2               
00CB47  2               LAB_1B2A
00CB47  2  26 5F        	ROL	Dtypef		; shift data type flag into Cb
00CB49  2  8A           	TXA				; copy compare function flag
00CB4A  2  85 5F        	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
00CB4C  2  2A           	ROL				; shift data type into compare function byte b0
00CB4D  2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
00CB4F  2  D0 02        	BNE	LAB_1B34		; branch if no underflow
00CB51  2               
00CB51  2  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
00CB53  2               LAB_1B34
00CB53  2  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
00CB55  2               TK_LT_PLUS	= TK_LT-TK_PLUS
00CB55  2  A0 24        	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
00CB57  2  85 9B        	STA	comp_f		; save new compare function flag
00CB59  2  D0 D5        	BNE	LAB_1B13		; branch always
00CB5B  2               
00CB5B  2               LAB_1B3C
00CB5B  2  D9 E9 E2     	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
00CB5E  2  B0 44        	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
00CB60  2               
00CB60  2  90 D7        	BCC	LAB_1B1C		; branch always
00CB62  2               
00CB62  2               ;.get vector, execute function then continue evaluation
00CB62  2               
00CB62  2               LAB_1B43
00CB62  2  B9 EB E2     	LDA	LAB_OPPT+2,Y	; get function vector high byte
00CB65  2  48           	PHA				; onto stack
00CB66  2  B9 EA E2     	LDA	LAB_OPPT+1,Y	; get function vector low byte
00CB69  2  48           	PHA				; onto stack
00CB6A  2               					; now push sign, round FAC1 and put on stack
00CB6A  2  20 79 CB     	JSR	LAB_1B5B		; function will return here, then the next RTS will call
00CB6D  2               					; the function
00CB6D  2  A5 9B        	LDA	comp_f		; get compare function flag
00CB6F  2  48           	PHA				; push compare evaluation byte
00CB70  2  B9 E9 E2     	LDA	LAB_OPPT,Y		; get precedence byte
00CB73  2  4C EB CA     	JMP	LAB_1ACC		; continue evaluating expression
00CB76  2               
00CB76  2               LAB_1B53
00CB76  2  4C 02 CC     	JMP	LAB_SNER		; do syntax error then warm start
00CB79  2               
00CB79  2               ; push sign, round FAC1 and put on stack
00CB79  2               
00CB79  2               LAB_1B5B
00CB79  2  68           	PLA				; get return addr low byte
00CB7A  2  85 71        	STA	ut1_pl		; save it
00CB7C  2  E6 71        	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
00CB7E  2               					; note! no check is made on the high byte! if the calling
00CB7E  2               					; routine assembles to a page edge then this all goes
00CB7E  2               					; horribly wrong !!!
00CB7E  2  68           	PLA				; get return addr high byte
00CB7F  2  85 72        	STA	ut1_ph		; save it
00CB81  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00CB83  2  48           	PHA				; push sign
00CB84  2               
00CB84  2               ; round FAC1 and put on stack
00CB84  2               
00CB84  2               LAB_1B66
00CB84  2  20 D9 D8     	JSR	LAB_27BA		; round FAC1
00CB87  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00CB89  2  48           	PHA				; push on stack
00CB8A  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00CB8C  2  48           	PHA				; push on stack
00CB8D  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00CB8F  2  48           	PHA				; push on stack
00CB90  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00CB92  2  48           	PHA				; push on stack
00CB93  2  6C 71 00     	JMP	(ut1_pl)		; return, sort of
00CB96  2               
00CB96  2               ; do functions
00CB96  2               
00CB96  2               LAB_1B78
00CB96  2  A0 FF        	LDY	#$FF			; flag function
00CB98  2  68           	PLA				; pull precedence byte
00CB99  2               LAB_1B7B
00CB99  2  F0 20        	BEQ	LAB_1B9D		; exit if done
00CB9B  2               
00CB9B  2               LAB_1B7D
00CB9B  2  C9 64        	CMP	#$64			; compare previous precedence with $64
00CB9D  2  F0 03        	BEQ	LAB_1B84		; branch if was $64 (< function)
00CB9F  2               
00CB9F  2  20 D0 CA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00CBA2  2               LAB_1B84
00CBA2  2  84 99        	STY	prstk			; save precedence stacked flag
00CBA4  2               
00CBA4  2               					; pop FAC2 and return
00CBA4  2               LAB_1B86
00CBA4  2  68           	PLA				; pop byte
00CBA5  2  4A           	LSR				; shift out comparison evaluation lowest bit
00CBA6  2  85 63        	STA	Cflag			; save comparison evaluation flag
00CBA8  2  68           	PLA				; pop exponent
00CBA9  2  85 B3        	STA	FAC2_e		; save FAC2 exponent
00CBAB  2  68           	PLA				; pop mantissa1
00CBAC  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00CBAE  2  68           	PLA				; pop mantissa2
00CBAF  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00CBB1  2  68           	PLA				; pop mantissa3
00CBB2  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00CBB4  2  68           	PLA				; pop sign
00CBB5  2  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
00CBB7  2  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
00CBB9  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00CBBB  2               LAB_1B9D
00CBBB  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00CBBD  2  60           	RTS
00CBBE  2               
00CBBE  2               ; print "..." string to string util area
00CBBE  2               
00CBBE  2               LAB_1BC1
00CBBE  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00CBC0  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00CBC2  2  69 00        	ADC	#$00			; add carry to low byte
00CBC4  2  90 01        	BCC	LAB_1BCA		; branch if no overflow
00CBC6  2               
00CBC6  2  C8           	INY				; increment high byte
00CBC7  2               LAB_1BCA
00CBC7  2  20 44 D1     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
00CBCA  2  4C CF D4     	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
00CBCD  2               
00CBCD  2               ; get value from line
00CBCD  2               
00CBCD  2               LAB_GVAL
00CBCD  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00CBD0  2  B0 03        	BCS	LAB_1BAC		; branch if not numeric character
00CBD2  2               
00CBD2  2               					; else numeric string found (e.g. 123)
00CBD2  2               LAB_1BA9
00CBD2  2  4C A6 D9     	JMP	LAB_2887		; get FAC1 from string and return
00CBD5  2               
00CBD5  2               ; get value from line .. continued
00CBD5  2               
00CBD5  2               					; wasn't a number so ..
00CBD5  2               LAB_1BAC
00CBD5  2  AA           	TAX				; set the flags
00CBD6  2  30 2F        	BMI	LAB_1BD0		; if -ve go test token values
00CBD8  2               
00CBD8  2               					; else it is either a string, number, variable or (<expr>)
00CBD8  2  C9 24        	CMP	#'$'			; compare with "$"
00CBDA  2  F0 F6        	BEQ	LAB_1BA9		; branch if "$", hex number
00CBDC  2               
00CBDC  2  C9 25        	CMP	#'%'			; else compare with "%"
00CBDE  2  F0 F2        	BEQ	LAB_1BA9		; branch if "%", binary number
00CBE0  2               
00CBE0  2  C9 2E        	CMP	#'.'			; compare with "."
00CBE2  2  F0 EE        	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
00CBE4  2               
00CBE4  2               					; it wasn't any sort of number so ..
00CBE4  2  C9 22        	CMP	#$22			; compare with "
00CBE6  2  F0 D6        	BEQ	LAB_1BC1		; branch if open quote
00CBE8  2               
00CBE8  2               					; wasn't any sort of number so ..
00CBE8  2               
00CBE8  2               ; evaluate expression within parentheses
00CBE8  2               
00CBE8  2  C9 28        	CMP	#'('			; compare with "("
00CBEA  2  D0 4F        	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
00CBEC  2               
00CBEC  2               LAB_1BF7
00CBEC  2  20 E9 CA     	JSR	LAB_EVEZ		; evaluate expression, no decrement
00CBEF  2               
00CBEF  2               ; all the 'scan for' routines return the character after the sought character
00CBEF  2               
00CBEF  2               ; scan for ")" , else do syntax error then warm start
00CBEF  2               
00CBEF  2               LAB_1BFB
00CBEF  2  A9 29        	LDA	#$29			; load A with ")"
00CBF1  2               
00CBF1  2               ; scan for CHR$(A) , else do syntax error then warm start
00CBF1  2               
00CBF1  2               LAB_SCCA
00CBF1  2  A0 00        	LDY	#$00			; clear index
00CBF3  2  D1 C3        	CMP	(Bpntrl),Y		; check next byte is = A
00CBF5  2  D0 0B        	BNE	LAB_SNER		; if not do syntax error then warm start
00CBF7  2               
00CBF7  2  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then return
00CBFA  2               
00CBFA  2               ; scan for "(" , else do syntax error then warm start
00CBFA  2               
00CBFA  2               LAB_1BFE
00CBFA  2  A9 28        	LDA	#$28			; load A with "("
00CBFC  2  D0 F3        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
00CBFE  2               					; (branch always)
00CBFE  2               
00CBFE  2               ; scan for "," , else do syntax error then warm start
00CBFE  2               
00CBFE  2               LAB_1C01
00CBFE  2  A9 2C        	LDA	#$2C			; load A with ","
00CC00  2  D0 EF        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
00CC02  2               					; (branch always)
00CC02  2               
00CC02  2               ; syntax error then warm start
00CC02  2               
00CC02  2               LAB_SNER
00CC02  2  A2 02        	LDX	#$02			; error code $02 ("Syntax" error)
00CC04  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00CC07  2               
00CC07  2               ; get value from line .. continued
00CC07  2               ; do tokens
00CC07  2               
00CC07  2               LAB_1BD0
00CC07  2  C9 B7        	CMP	#TK_MINUS		; compare with token for -
00CC09  2  F0 29        	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
00CC0B  2               
00CC0B  2               					; wasn't -n so ..
00CC0B  2  C9 B6        	CMP	#TK_PLUS		; compare with token for +
00CC0D  2  F0 BE        	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
00CC0F  2               
00CC0F  2  C9 B1        	CMP	#TK_NOT		; compare with token for NOT
00CC11  2  D0 13        	BNE	LAB_1BE7		; branch if not token for NOT
00CC13  2               
00CC13  2               					; was NOT token
00CC13  2               TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
00CC13  2  A0 21        	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
00CC15  2  D0 1F        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
00CC17  2               
00CC17  2               ; do = compare
00CC17  2               
00CC17  2               LAB_EQUAL
00CC17  2  20 A6 CE     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
00CC1A  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00CC1C  2  49 FF        	EOR	#$FF			; invert it
00CC1E  2  A8           	TAY				; copy it
00CC1F  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00CC21  2  49 FF        	EOR	#$FF			; invert it
00CC23  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00CC26  2               
00CC26  2               ; get value from line .. continued
00CC26  2               
00CC26  2               					; wasn't +, -, or NOT so ..
00CC26  2               LAB_1BE7
00CC26  2  C9 AE        	CMP	#TK_FN		; compare with token for FN
00CC28  2  D0 03        	BNE	LAB_1BEE		; branch if not token for FN
00CC2A  2               
00CC2A  2  4C B4 D0     	JMP	LAB_201E		; go evaluate FNx
00CC2D  2               
00CC2D  2               ; get value from line .. continued
00CC2D  2               
00CC2D  2               					; wasn't +, -, NOT or FN so ..
00CC2D  2               LAB_1BEE
00CC2D  2  E9 C3        	SBC	#TK_SGN		; subtract with token for SGN
00CC2F  2  B0 19        	BCS	LAB_1C27		; if a function token go do it
00CC31  2               
00CC31  2  4C 02 CC     	JMP	LAB_SNER		; else do syntax error
00CC34  2               
00CC34  2               ; set-up for functions
00CC34  2               
00CC34  2               LAB_1C11
00CC34  2               TK_GT_PLUS	= TK_GT-TK_PLUS
00CC34  2  A0 1E        	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
00CC36  2               LAB_1C13
00CC36  2  68           	PLA				; dump return address low byte
00CC37  2  68           	PLA				; dump return address high byte
00CC38  2  4C 3A CB     	JMP	LAB_1B1D		; execute function then continue evaluation
00CC3B  2               
00CC3B  2               ; variable name set-up
00CC3B  2               ; get (var), return value in FAC_1 and $ flag
00CC3B  2               
00CC3B  2               LAB_1C18
00CC3B  2  20 AA CD     	JSR	LAB_GVAR		; get (var) address
00CC3E  2  85 AE        	STA	FAC1_2		; save address low byte in FAC1 mantissa2
00CC40  2  84 AF        	STY	FAC1_3		; save address high byte in FAC1 mantissa3
00CC42  2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
00CC44  2  30 03        	BMI	LAB_1C25		; if string then return (does RTS)
00CC46  2               
00CC46  2               LAB_1C24
00CC46  2  4C 7D D8     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
00CC49  2               
00CC49  2               LAB_1C25
00CC49  2  60           	RTS
00CC4A  2               
00CC4A  2               ; get value from line .. continued
00CC4A  2               ; only functions left so ..
00CC4A  2               
00CC4A  2               ; set up function references
00CC4A  2               
00CC4A  2               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
00CC4A  2               ; to process function calls. now the function vector is computed and pushed on the stack
00CC4A  2               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
00CC4A  2               ; is calculated and the routine called, if not this routine just does RTS. whichever
00CC4A  2               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
00CC4A  2               ; the function code
00CC4A  2               
00CC4A  2               ; this also removes some less than elegant code that was used to bypass type checking
00CC4A  2               ; for functions that returned strings
00CC4A  2               
00CC4A  2               LAB_1C27
00CC4A  2  0A           	ASL				; *2 (2 bytes per function address)
00CC4B  2  A8           	TAY				; copy to index
00CC4C  2               
00CC4C  2  B9 A4 E2     	LDA	LAB_FTBM,Y		; get function jump vector high byte
00CC4F  2  48           	PHA				; push functions jump vector high byte
00CC50  2  B9 A3 E2     	LDA	LAB_FTBL,Y		; get function jump vector low byte
00CC53  2  48           	PHA				; push functions jump vector low byte
00CC54  2               
00CC54  2  B9 5E E2     	LDA	LAB_FTPM,Y		; get function pre process vector high byte
00CC57  2  F0 05        	BEQ	LAB_1C56		; skip pre process if null vector
00CC59  2               
00CC59  2  48           	PHA				; push functions pre process vector high byte
00CC5A  2  B9 5D E2     	LDA	LAB_FTPL,Y		; get function pre process vector low byte
00CC5D  2  48           	PHA				; push functions pre process vector low byte
00CC5E  2               
00CC5E  2               LAB_1C56
00CC5E  2  60           	RTS				; do function, or pre process, call
00CC5F  2               
00CC5F  2               ; process string expression in parenthesis
00CC5F  2               
00CC5F  2               LAB_PPFS
00CC5F  2  20 EC CB     	JSR	LAB_1BF7		; process expression in parenthesis
00CC62  2  4C D2 CA     	JMP	LAB_CTST		; check if source is string then do function,
00CC65  2               					; else do type mismatch
00CC65  2               
00CC65  2               ; process numeric expression in parenthesis
00CC65  2               
00CC65  2               LAB_PPFN
00CC65  2  20 EC CB     	JSR	LAB_1BF7		; process expression in parenthesis
00CC68  2  4C D0 CA     	JMP	LAB_CTNM		; check if source is numeric then do function,
00CC6B  2               					; else do type mismatch
00CC6B  2               
00CC6B  2               ; set numeric data type and increment BASIC execute pointer
00CC6B  2               
00CC6B  2               LAB_PPBI
00CC6B  2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
00CC6D  2  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then do function
00CC70  2               
00CC70  2               ; process string for LEFT$, RIGHT$ or MID$
00CC70  2               
00CC70  2               LAB_LRMS
00CC70  2  20 E9 CA     	JSR	LAB_EVEZ		; evaluate (should be string) expression
00CC73  2  20 FE CB     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
00CC76  2  20 D2 CA     	JSR	LAB_CTST		; check if source is string, else do type mismatch
00CC79  2               
00CC79  2  68           	PLA				; get function jump vector low byte
00CC7A  2  AA           	TAX				; save functions jump vector low byte
00CC7B  2  68           	PLA				; get function jump vector high byte
00CC7C  2  A8           	TAY				; save functions jump vector high byte
00CC7D  2  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
00CC7F  2  48           	PHA				; push string pointer high byte
00CC80  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00CC82  2  48           	PHA				; push string pointer low byte
00CC83  2  98           	TYA				; get function jump vector high byte back
00CC84  2  48           	PHA				; save functions jump vector high byte
00CC85  2  8A           	TXA				; get function jump vector low byte back
00CC86  2  48           	PHA				; save functions jump vector low byte
00CC87  2  20 8C D4     	JSR	LAB_GTBY		; get byte parameter
00CC8A  2  8A           	TXA				; copy byte parameter to A
00CC8B  2  60           	RTS				; go do function
00CC8C  2               
00CC8C  2               ; process numeric expression(s) for BIN$ or HEX$
00CC8C  2               
00CC8C  2               LAB_BHSS
00CC8C  2  20 E9 CA     	JSR	LAB_EVEZ		; process expression
00CC8F  2  20 D0 CA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00CC92  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00CC94  2  C9 98        	CMP	#$98			; compare with exponent = 2^24
00CC96  2  B0 20        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
00CC98  2               
00CC98  2  20 50 D9     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
00CC9B  2  A2 02        	LDX	#$02			; 3 bytes to do
00CC9D  2               LAB_CFAC
00CC9D  2  B5 AD        	LDA	FAC1_1,X		; get byte from FAC1
00CC9F  2  95 11        	STA	nums_1,X		; save byte to temp
00CCA1  2  CA           	DEX				; decrement index
00CCA2  2  10 F9        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
00CCA4  2               
00CCA4  2  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
00CCA7  2  A2 00        	LDX	#$00			; set default to no leading "0"s
00CCA9  2  C9 29        	CMP	#')'			; compare with close bracket
00CCAB  2  F0 0A        	BEQ	LAB_1C54		; if ")" go do rest of function
00CCAD  2               
00CCAD  2  20 DE D4     	JSR	LAB_SCGB		; scan for "," and get byte
00CCB0  2  20 C2 00     	JSR	LAB_GBYT		; get last byte back
00CCB3  2  C9 29        	CMP	#')'			; is next character )
00CCB5  2  D0 01        	BNE	LAB_BHER		; if not ")" go do error
00CCB7  2               
00CCB7  2               LAB_1C54
00CCB7  2  60           	RTS				; else do function
00CCB8  2               
00CCB8  2               LAB_BHER
00CCB8  2  4C 29 CF     	JMP	LAB_FCER		; do function call error then warm start
00CCBB  2               
00CCBB  2               ; perform EOR
00CCBB  2               
00CCBB  2               ; added operator format is the same as AND or OR, precedence is the same as OR
00CCBB  2               
00CCBB  2               ; this bit worked first time but it took a while to sort out the operator table
00CCBB  2               ; pointers and offsets afterwards!
00CCBB  2               
00CCBB  2               LAB_EOR
00CCBB  2  20 E2 CC     	JSR	GetFirst		; get first integer expression (no sign check)
00CCBE  2  45 5B        	EOR	XOAw_l		; EOR with expression 1 low byte
00CCC0  2  A8           	TAY				; save in Y
00CCC1  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00CCC3  2  45 5C        	EOR	XOAw_h		; EOR with expression 1 high byte
00CCC5  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00CCC8  2               
00CCC8  2               ; perform OR
00CCC8  2               
00CCC8  2               LAB_OR
00CCC8  2  20 E2 CC     	JSR	GetFirst		; get first integer expression (no sign check)
00CCCB  2  05 5B        	ORA	XOAw_l		; OR with expression 1 low byte
00CCCD  2  A8           	TAY				; save in Y
00CCCE  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00CCD0  2  05 5C        	ORA	XOAw_h		; OR with expression 1 high byte
00CCD2  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00CCD5  2               
00CCD5  2               ; perform AND
00CCD5  2               
00CCD5  2               LAB_AND
00CCD5  2  20 E2 CC     	JSR	GetFirst		; get first integer expression (no sign check)
00CCD8  2  25 5B        	AND	XOAw_l		; AND with expression 1 low byte
00CCDA  2  A8           	TAY				; save in Y
00CCDB  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00CCDD  2  25 5C        	AND	XOAw_h		; AND with expression 1 high byte
00CCDF  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00CCE2  2               
00CCE2  2               ; get first value for OR, AND or EOR
00CCE2  2               
00CCE2  2               GetFirst
00CCE2  2  20 A6 CE     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
00CCE5  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00CCE7  2  85 5C        	STA	XOAw_h		; save it
00CCE9  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00CCEB  2  85 5B        	STA	XOAw_l		; save it
00CCED  2  20 C3 D5     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
00CCF0  2  20 A6 CE     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
00CCF3  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00CCF5  2               LAB_1C95
00CCF5  2  60           	RTS
00CCF6  2               
00CCF6  2               ; perform comparisons
00CCF6  2               
00CCF6  2               ; do < compare
00CCF6  2               
00CCF6  2               LAB_LTHAN
00CCF6  2  20 D3 CA     	JSR	LAB_CKTM		; type match check, set C for string
00CCF9  2  B0 13        	BCS	LAB_1CAE		; branch if string
00CCFB  2               
00CCFB  2               					; do numeric < compare
00CCFB  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
00CCFD  2  09 7F        	ORA	#$7F			; set all non sign bits
00CCFF  2  25 B4        	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
00CD01  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00CD03  2  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
00CD05  2  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
00CD07  2  20 17 D9     	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
00CD0A  2  AA           	TAX				; copy result
00CD0B  2  4C 3F CD     	JMP	LAB_1CE1		; go evaluate result
00CD0E  2               
00CD0E  2               					; do string < compare
00CD0E  2               LAB_1CAE
00CD0E  2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
00CD10  2  C6 9B        	DEC	comp_f		; clear < bit in compare function flag
00CD12  2  20 3E D3     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
00CD15  2               					; space returns with A = length, X=pointer low byte,
00CD15  2               					; Y=pointer high byte
00CD15  2  85 AC        	STA	str_ln		; save length
00CD17  2  86 AD        	STX	str_pl		; save string pointer low byte
00CD19  2  84 AE        	STY	str_ph		; save string pointer high byte
00CD1B  2  A5 B5        	LDA	FAC2_2		; get descriptor pointer low byte
00CD1D  2  A4 B6        	LDY	FAC2_3		; get descriptor pointer high byte
00CD1F  2  20 42 D3     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
00CD22  2               					; returns with A = length, X=pointer low byte,
00CD22  2               					; Y=pointer high byte
00CD22  2  86 B5        	STX	FAC2_2		; save string pointer low byte
00CD24  2  84 B6        	STY	FAC2_3		; save string pointer high byte
00CD26  2  AA           	TAX				; copy length
00CD27  2  38           	SEC				; set carry for subtract
00CD28  2  E5 AC        	SBC	str_ln		; subtract string 1 length
00CD2A  2  F0 08        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
00CD2C  2               
00CD2C  2  A9 01        	LDA	#$01			; set str 1 length > string 2 length
00CD2E  2  90 04        	BCC	LAB_1CD6		; branch if so
00CD30  2               
00CD30  2  A6 AC        	LDX	str_ln		; get string 1 length
00CD32  2  A9 FF        	LDA	#$FF			; set str 1 length < string 2 length
00CD34  2               LAB_1CD6
00CD34  2  85 B0        	STA	FAC1_s		; save length compare
00CD36  2  A0 FF        	LDY	#$FF			; set index
00CD38  2  E8           	INX				; adjust for loop
00CD39  2               LAB_1CDB
00CD39  2  C8           	INY				; increment index
00CD3A  2  CA           	DEX				; decrement count
00CD3B  2  D0 07        	BNE	LAB_1CE6		; branch if still bytes to do
00CD3D  2               
00CD3D  2  A6 B0        	LDX	FAC1_s		; get length compare back
00CD3F  2               LAB_1CE1
00CD3F  2  30 0F        	BMI	LAB_1CF2		; branch if str 1 < str 2
00CD41  2               
00CD41  2  18           	CLC				; flag str 1 <= str 2
00CD42  2  90 0C        	BCC	LAB_1CF2		; go evaluate result
00CD44  2               
00CD44  2               LAB_1CE6
00CD44  2  B1 B5        	LDA	(FAC2_2),Y		; get string 2 byte
00CD46  2  D1 AD        	CMP	(FAC1_1),Y		; compare with string 1 byte
00CD48  2  F0 EF        	BEQ	LAB_1CDB		; loop if bytes =
00CD4A  2               
00CD4A  2  A2 FF        	LDX	#$FF			; set str 1 < string 2
00CD4C  2  B0 02        	BCS	LAB_1CF2		; branch if so
00CD4E  2               
00CD4E  2  A2 01        	LDX	#$01			;  set str 1 > string 2
00CD50  2               LAB_1CF2
00CD50  2  E8           	INX				; x = 0, 1 or 2
00CD51  2  8A           	TXA				; copy to A
00CD52  2  2A           	ROL				; *2 (1, 2 or 4)
00CD53  2  25 63        	AND	Cflag			; AND with comparison evaluation flag
00CD55  2  F0 02        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
00CD57  2               
00CD57  2  A9 FF        	LDA	#$FF			; else set result true
00CD59  2               LAB_1CFB
00CD59  2  4C FA D8     	JMP	LAB_27DB		; save A as integer byte and return
00CD5C  2               
00CD5C  2               LAB_1CFE
00CD5C  2  20 FE CB     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
00CD5F  2               
00CD5F  2               ; perform DIM
00CD5F  2               
00CD5F  2               LAB_DIM
00CD5F  2  AA           	TAX				; copy "DIM" flag to X
00CD60  2  20 AF CD     	JSR	LAB_1D10		; search for variable
00CD63  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00CD66  2  D0 F4        	BNE	LAB_1CFE		; scan for "," and loop if not null
00CD68  2               
00CD68  2  60           	RTS
00CD69  2               
00CD69  2               ; perform << (left shift)
00CD69  2               
00CD69  2               LAB_LSHIFT
00CD69  2  20 9F CD     	JSR	GetPair		; get integer expression and byte (no sign check)
00CD6C  2  A5 AE        	LDA	FAC1_2		; get expression high byte
00CD6E  2  A6 78        	LDX	TempB			; get shift count
00CD70  2  F0 22        	BEQ	NoShift		; branch if zero
00CD72  2               
00CD72  2  E0 10        	CPX	#$10			; compare bit count with 16d
00CD74  2  B0 23        	BCS	TooBig		; branch if >=
00CD76  2               
00CD76  2               Ls_loop
00CD76  2  06 AF        	ASL	FAC1_3		; shift low byte
00CD78  2  2A           	ROL				; shift high byte
00CD79  2  CA           	DEX				; decrement bit count
00CD7A  2  D0 FA        	BNE	Ls_loop		; loop if shift not complete
00CD7C  2               
00CD7C  2  A4 AF        	LDY	FAC1_3		; get expression low byte
00CD7E  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00CD81  2               
00CD81  2               ; perform >> (right shift)
00CD81  2               
00CD81  2               LAB_RSHIFT
00CD81  2  20 9F CD     	JSR	GetPair		; get integer expression and byte (no sign check)
00CD84  2  A5 AE        	LDA	FAC1_2		; get expression high byte
00CD86  2  A6 78        	LDX	TempB			; get shift count
00CD88  2  F0 0A        	BEQ	NoShift		; branch if zero
00CD8A  2               
00CD8A  2  E0 10        	CPX	#$10			; compare bit count with 16d
00CD8C  2  B0 0B        	BCS	TooBig		; branch if >=
00CD8E  2               
00CD8E  2               Rs_loop
00CD8E  2  4A           	LSR				; shift high byte
00CD8F  2  66 AF        	ROR	FAC1_3		; shift low byte
00CD91  2  CA           	DEX				; decrement bit count
00CD92  2  D0 FA        	BNE	Rs_loop		; loop if shift not complete
00CD94  2               
00CD94  2               NoShift
00CD94  2  A4 AF        	LDY	FAC1_3		; get expression low byte
00CD96  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00CD99  2               
00CD99  2               TooBig
00CD99  2  A9 00        	LDA	#$00			; clear high byte
00CD9B  2  A8           	TAY				; copy to low byte
00CD9C  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00CD9F  2               
00CD9F  2               GetPair
00CD9F  2  20 8F D4     	JSR	LAB_EVBY		; evaluate byte expression, result in X
00CDA2  2  86 78        	STX	TempB			; save it
00CDA4  2  20 C3 D5     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
00CDA7  2  4C A6 CE     	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
00CDAA  2               
00CDAA  2               ; search for variable
00CDAA  2               
00CDAA  2               ; return pointer to variable in Cvaral/Cvarah
00CDAA  2               
00CDAA  2               LAB_GVAR
00CDAA  2  A2 00        	LDX	#$00			; set DIM flag = $00
00CDAC  2  20 C2 00     	JSR	LAB_GBYT		; scan memory (1st character)
00CDAF  2               LAB_1D10
00CDAF  2  86 5E        	STX	Defdim		; save DIM flag
00CDB1  2               LAB_1D12
00CDB1  2  85 93        	STA	Varnm1		; save 1st character
00CDB3  2  29 7F        	AND	#$7F			; clear FN flag bit
00CDB5  2  20 1E CE     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
00CDB8  2  B0 03        	BCS	LAB_1D1F		; branch if ok
00CDBA  2               
00CDBA  2  4C 02 CC     	JMP	LAB_SNER		; else syntax error then warm start
00CDBD  2               
00CDBD  2               					; was variable name so ..
00CDBD  2               LAB_1D1F
00CDBD  2  A2 00        	LDX	#$00			; clear 2nd character temp
00CDBF  2  86 5F        	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
00CDC1  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (2nd character)
00CDC4  2  90 05        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
00CDC6  2               
00CDC6  2               					; 2nd character wasn't "0" to "9" so ..
00CDC6  2  20 1E CE     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
00CDC9  2  90 0B        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
00CDCB  2               
00CDCB  2               LAB_1D2D
00CDCB  2  AA           	TAX				; copy 2nd character
00CDCC  2               
00CDCC  2               					; ignore further (valid) characters in the variable name
00CDCC  2               LAB_1D2E
00CDCC  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (3rd character)
00CDCF  2  90 FB        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
00CDD1  2               
00CDD1  2  20 1E CE     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
00CDD4  2  B0 F6        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
00CDD6  2               
00CDD6  2               					; check if string variable
00CDD6  2               LAB_1D38
00CDD6  2  C9 24        	CMP	#'$'			; compare with "$"
00CDD8  2  D0 0B        	BNE	LAB_1D47		; branch if not string
00CDDA  2               
00CDDA  2               ; to introduce a new variable type (% suffix for integers say) then this branch
00CDDA  2               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
00CDDA  2               
00CDDA  2               					; type is string
00CDDA  2  A9 FF        	LDA	#$FF			; set data type = string
00CDDC  2  85 5F        	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
00CDDE  2  8A           	TXA				; get 2nd character back
00CDDF  2  09 80        	ORA	#$80			; set top bit (indicate string var)
00CDE1  2  AA           	TAX				; copy back to 2nd character temp
00CDE2  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00CDE5  2               
00CDE5  2               ; after we have determined the variable type we need to come back here to determine
00CDE5  2               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
00CDE5  2               
00CDE5  2               
00CDE5  2               LAB_1D47				; gets here with character after var name in A
00CDE5  2  86 94        	STX	Varnm2		; save 2nd character
00CDE7  2  05 61        	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
00CDE9  2  C9 28        	CMP	#'('			; compare with "("
00CDEB  2  D0 03        	BNE	LAB_1D53		; branch if not "("
00CDED  2               
00CDED  2  4C B8 CE     	JMP	LAB_1E17		; go find, or make, array
00CDF0  2               
00CDF0  2               ; either find or create var
00CDF0  2               ; var name (1st two characters only!) is in Varnm1,Varnm2
00CDF0  2               
00CDF0  2               					; variable name wasn't var(... so look for plain var
00CDF0  2               LAB_1D53
00CDF0  2  A9 00        	LDA	#$00			; clear A
00CDF2  2  85 61        	STA	Sufnxf		; clear subscript/FNX flag
00CDF4  2  A5 7B        	LDA	Svarl			; get start of vars low byte
00CDF6  2  A6 7C        	LDX	Svarh			; get start of vars high byte
00CDF8  2  A0 00        	LDY	#$00			; clear index
00CDFA  2               LAB_1D5D
00CDFA  2  86 AB        	STX	Vrschh		; save search address high byte
00CDFC  2               LAB_1D5F
00CDFC  2  85 AA        	STA	Vrschl		; save search address low byte
00CDFE  2  E4 7E        	CPX	Sarryh		; compare high address with var space end
00CE00  2  D0 04        	BNE	LAB_1D69		; skip next compare if <>
00CE02  2               
00CE02  2               					; high addresses were = so compare low addresses
00CE02  2  C5 7D        	CMP	Sarryl		; compare low address with var space end
00CE04  2  F0 2C        	BEQ	LAB_1D8B		; if not found go make new var
00CE06  2               
00CE06  2               LAB_1D69
00CE06  2  A5 93        	LDA	Varnm1		; get 1st character of var to find
00CE08  2  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 1st character
00CE0A  2  D0 08        	BNE	LAB_1D77		; branch if no match
00CE0C  2               
00CE0C  2               					; 1st characters match so compare 2nd characters
00CE0C  2  A5 94        	LDA	Varnm2		; get 2nd character of var to find
00CE0E  2  C8           	INY				; index to point to variable name 2nd character
00CE0F  2  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 2nd character
00CE11  2  F0 69        	BEQ	LAB_1DD7		; branch if match (found var)
00CE13  2               
00CE13  2  88           	DEY				; else decrement index (now = $00)
00CE14  2               LAB_1D77
00CE14  2  18           	CLC				; clear carry for add
00CE15  2  A5 AA        	LDA	Vrschl		; get search address low byte
00CE17  2  69 06        	ADC	#$06			; +6 (offset to next var name)
00CE19  2  90 E1        	BCC	LAB_1D5F		; loop if no overflow to high byte
00CE1B  2               
00CE1B  2  E8           	INX				; else increment high byte
00CE1C  2  D0 DC        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
00CE1E  2               
00CE1E  2               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
00CE1E  2               
00CE1E  2               LAB_CASC
00CE1E  2  C9 61        	CMP	#'a'			; compare with "a"
00CE20  2  B0 0A        	BCS	LAB_1D83		; go check <"z"+1
00CE22  2               
00CE22  2               ; check byte, return C=0 if<"A" or >"Z"
00CE22  2               
00CE22  2               LAB_1D82
00CE22  2  C9 41        	CMP	#'A'			; compare with "A"
00CE24  2  90 05        	BCC	LAB_1D8A		; exit if less
00CE26  2               
00CE26  2               					; carry is set
00CE26  2  E9 5B        	SBC	#$5B			; subtract "Z"+1
00CE28  2  38           	SEC				; set carry
00CE29  2  E9 A5        	SBC	#$A5			; subtract $A5 (restore byte)
00CE2B  2               					; carry clear if byte>$5A
00CE2B  2               LAB_1D8A
00CE2B  2  60           	RTS
00CE2C  2               
00CE2C  2               LAB_1D83
00CE2C  2  E9 7B        	SBC	#$7B			; subtract "z"+1
00CE2E  2  38           	SEC				; set carry
00CE2F  2  E9 85        	SBC	#$85			; subtract $85 (restore byte)
00CE31  2               					; carry clear if byte>$7A
00CE31  2  60           	RTS
00CE32  2               
00CE32  2               					; reached end of variable mem without match
00CE32  2               					; .. so create new variable
00CE32  2               LAB_1D8B
00CE32  2  68           	PLA				; pop return address low byte
00CE33  2  48           	PHA				; push return address low byte
00CE34  2               LAB_1C18p2	= LAB_1C18+2
00CE34  2  C9 3D        	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
00CE36  2  D0 05        	BNE	LAB_1D98		; if not get (var) go create new var
00CE38  2               
00CE38  2               ; This will only drop through if the call was from LAB_1C18 and is only called
00CE38  2               ; from there if it is searching for a variable from the RHS of a LET a=b statement
00CE38  2               ; it prevents the creation of variables not assigned a value.
00CE38  2               
00CE38  2               ; value returned by this is either numeric zero (exponent byte is $00) or null string
00CE38  2               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
00CE38  2               
00CE38  2               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
00CE38  2               
00CE38  2               ; this is where you would put the undefined variable error call e.g.
00CE38  2               
00CE38  2               ;					; variable doesn't exist so flag error
00CE38  2               ;	LDX	#$24			; error code $24 ("undefined variable" error)
00CE38  2               ;	JMP	LAB_XERR		; do error #X then warm start
00CE38  2               
00CE38  2               ; the above code has been tested and works a treat! (it replaces the three code lines
00CE38  2               ; below)
00CE38  2               
00CE38  2               					; else return dummy null value
00CE38  2  A9 E1        	LDA	#<LAB_1D96		; low byte point to $00,$00
00CE3A  2               					; (uses part of misc constants table)
00CE3A  2  A0 E1        	LDY	#>LAB_1D96		; high byte point to $00,$00
00CE3C  2  60           	RTS
00CE3D  2               
00CE3D  2               					; create new numeric variable
00CE3D  2               LAB_1D98
00CE3D  2  A5 7D        	LDA	Sarryl		; get var mem end low byte
00CE3F  2  A4 7E        	LDY	Sarryh		; get var mem end high byte
00CE41  2  85 AA        	STA	Ostrtl		; save old block start low byte
00CE43  2  84 AB        	STY	Ostrth		; save old block start high byte
00CE45  2  A5 7F        	LDA	Earryl		; get array mem end low byte
00CE47  2  A4 80        	LDY	Earryh		; get array mem end high byte
00CE49  2  85 A6        	STA	Obendl		; save old block end low byte
00CE4B  2  84 A7        	STY	Obendh		; save old block end high byte
00CE4D  2  18           	CLC				; clear carry for add
00CE4E  2  69 06        	ADC	#$06			; +6 (space for one var)
00CE50  2  90 01        	BCC	LAB_1DAE		; branch if no overflow to high byte
00CE52  2               
00CE52  2  C8           	INY				; else increment high byte
00CE53  2               LAB_1DAE
00CE53  2  85 A4        	STA	Nbendl		; set new block end low byte
00CE55  2  84 A5        	STY	Nbendh		; set new block end high byte
00CE57  2  20 C1 C0     	JSR	LAB_11CF		; open up space in memory
00CE5A  2  A5 A4        	LDA	Nbendl		; get new start low byte
00CE5C  2  A4 A5        	LDY	Nbendh		; get new start high byte (-$100)
00CE5E  2  C8           	INY				; correct high byte
00CE5F  2  85 7D        	STA	Sarryl		; save new var mem end low byte
00CE61  2  84 7E        	STY	Sarryh		; save new var mem end high byte
00CE63  2  A0 00        	LDY	#$00			; clear index
00CE65  2  A5 93        	LDA	Varnm1		; get var name 1st character
00CE67  2  91 AA        	STA	(Vrschl),Y		; save var name 1st character
00CE69  2  C8           	INY				; increment index
00CE6A  2  A5 94        	LDA	Varnm2		; get var name 2nd character
00CE6C  2  91 AA        	STA	(Vrschl),Y		; save var name 2nd character
00CE6E  2  A9 00        	LDA	#$00			; clear A
00CE70  2  C8           	INY				; increment index
00CE71  2  91 AA        	STA	(Vrschl),Y		; initialise var byte
00CE73  2  C8           	INY				; increment index
00CE74  2  91 AA        	STA	(Vrschl),Y		; initialise var byte
00CE76  2  C8           	INY				; increment index
00CE77  2  91 AA        	STA	(Vrschl),Y		; initialise var byte
00CE79  2  C8           	INY				; increment index
00CE7A  2  91 AA        	STA	(Vrschl),Y		; initialise var byte
00CE7C  2               
00CE7C  2               					; found a match for var ((Vrschl) = ptr)
00CE7C  2               LAB_1DD7
00CE7C  2  A5 AA        	LDA	Vrschl		; get var address low byte
00CE7E  2  18           	CLC				; clear carry for add
00CE7F  2  69 02        	ADC	#$02			; +2 (offset past var name bytes)
00CE81  2  A4 AB        	LDY	Vrschh		; get var address high byte
00CE83  2  90 01        	BCC	LAB_1DE1		; branch if no overflow from add
00CE85  2               
00CE85  2  C8           	INY				; else increment high byte
00CE86  2               LAB_1DE1
00CE86  2  85 95        	STA	Cvaral		; save current var address low byte
00CE88  2  84 96        	STY	Cvarah		; save current var address high byte
00CE8A  2  60           	RTS
00CE8B  2               
00CE8B  2               ; set-up array pointer (Adatal/h) to first element in array
00CE8B  2               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
00CE8B  2               
00CE8B  2               LAB_1DE6
00CE8B  2  A5 5D        	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
00CE8D  2  0A           	ASL				; *2 (also clears the carry !)
00CE8E  2  69 05        	ADC	#$05			; +5 (result is 7, 9 or 11 here)
00CE90  2  65 AA        	ADC	Astrtl		; add array start pointer low byte
00CE92  2  A4 AB        	LDY	Astrth		; get array pointer high byte
00CE94  2  90 01        	BCC	LAB_1DF2		; branch if no overflow
00CE96  2               
00CE96  2  C8           	INY				; else increment high byte
00CE97  2               LAB_1DF2
00CE97  2  85 A4        	STA	Adatal		; save array data pointer low byte
00CE99  2  84 A5        	STY	Adatah		; save array data pointer high byte
00CE9B  2  60           	RTS
00CE9C  2               
00CE9C  2               ; evaluate integer expression
00CE9C  2               
00CE9C  2               LAB_EVIN
00CE9C  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00CE9F  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00CEA2  2               					; else do type mismatch
00CEA2  2               
00CEA2  2               ; evaluate integer expression (no check)
00CEA2  2               
00CEA2  2               LAB_EVPI
00CEA2  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00CEA4  2  30 0D        	BMI	LAB_1E12		; do function call error if -ve
00CEA6  2               
00CEA6  2               ; evaluate integer expression (no sign check)
00CEA6  2               
00CEA6  2               LAB_EVIR
00CEA6  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00CEA8  2  C9 90        	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
00CEAA  2  90 09        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
00CEAC  2               
00CEAC  2  A9 E8        	LDA	#<LAB_1DF7		; set pointer low byte to -32768
00CEAE  2  A0 E1        	LDY	#>LAB_1DF7		; set pointer high byte to -32768
00CEB0  2  20 17 D9     	JSR	LAB_27F8		; compare FAC1 with (AY)
00CEB3  2               LAB_1E12
00CEB3  2  D0 74        	BNE	LAB_FCER		; if <> do function call error then warm start
00CEB5  2               
00CEB5  2               LAB_1E14
00CEB5  2  4C 50 D9     	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
00CEB8  2               
00CEB8  2               ; find or make array
00CEB8  2               
00CEB8  2               LAB_1E17
00CEB8  2  A5 5E        	LDA	Defdim		; get DIM flag
00CEBA  2  48           	PHA				; push it
00CEBB  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00CEBD  2  48           	PHA				; push it
00CEBE  2  A0 00        	LDY	#$00			; clear dimensions count
00CEC0  2               
00CEC0  2               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
00CEC0  2               
00CEC0  2               LAB_1E1F
00CEC0  2  98           	TYA				; copy dimensions count
00CEC1  2  48           	PHA				; save it
00CEC2  2  A5 94        	LDA	Varnm2		; get array name 2nd byte
00CEC4  2  48           	PHA				; save it
00CEC5  2  A5 93        	LDA	Varnm1		; get array name 1st byte
00CEC7  2  48           	PHA				; save it
00CEC8  2  20 9C CE     	JSR	LAB_EVIN		; evaluate integer expression
00CECB  2  68           	PLA				; pull array name 1st byte
00CECC  2  85 93        	STA	Varnm1		; restore array name 1st byte
00CECE  2  68           	PLA				; pull array name 2nd byte
00CECF  2  85 94        	STA	Varnm2		; restore array name 2nd byte
00CED1  2  68           	PLA				; pull dimensions count
00CED2  2  A8           	TAY				; restore it
00CED3  2  BA           	TSX				; copy stack pointer
00CED4  2  BD 02 01     	LDA	LAB_STAK+2,X	; get DIM flag
00CED7  2  48           	PHA				; push it
00CED8  2  BD 01 01     	LDA	LAB_STAK+1,X	; get data type flag
00CEDB  2  48           	PHA				; push it
00CEDC  2  A5 AE        	LDA	FAC1_2		; get this dimension size high byte
00CEDE  2  9D 02 01     	STA	LAB_STAK+2,X	; stack before flag bytes
00CEE1  2  A5 AF        	LDA	FAC1_3		; get this dimension size low byte
00CEE3  2  9D 01 01     	STA	LAB_STAK+1,X	; stack before flag bytes
00CEE6  2  C8           	INY				; increment dimensions count
00CEE7  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00CEEA  2  C9 2C        	CMP	#','			; compare with ","
00CEEC  2  F0 D2        	BEQ	LAB_1E1F		; if found go do next dimension
00CEEE  2               
00CEEE  2  84 5D        	STY	Dimcnt		; store dimensions count
00CEF0  2  20 EF CB     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
00CEF3  2  68           	PLA				; pull data type flag
00CEF4  2  85 5F        	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
00CEF6  2  68           	PLA				; pull DIM flag
00CEF7  2  85 5E        	STA	Defdim		; restore DIM flag
00CEF9  2  A6 7D        	LDX	Sarryl		; get array mem start low byte
00CEFB  2  A5 7E        	LDA	Sarryh		; get array mem start high byte
00CEFD  2               
00CEFD  2               ; now check to see if we are at the end of array memory (we would be if there were
00CEFD  2               ; no arrays).
00CEFD  2               
00CEFD  2               LAB_1E5C
00CEFD  2  86 AA        	STX	Astrtl		; save as array start pointer low byte
00CEFF  2  85 AB        	STA	Astrth		; save as array start pointer high byte
00CF01  2  C5 80        	CMP	Earryh		; compare with array mem end high byte
00CF03  2  D0 04        	BNE	LAB_1E68		; branch if not reached array mem end
00CF05  2               
00CF05  2  E4 7F        	CPX	Earryl		; else compare with array mem end low byte
00CF07  2  F0 39        	BEQ	LAB_1EA1		; go build array if not found
00CF09  2               
00CF09  2               					; search for array
00CF09  2               LAB_1E68
00CF09  2  A0 00        	LDY	#$00			; clear index
00CF0B  2  B1 AA        	LDA	(Astrtl),Y		; get array name first byte
00CF0D  2  C8           	INY				; increment index to second name byte
00CF0E  2  C5 93        	CMP	Varnm1		; compare with this array name first byte
00CF10  2  D0 06        	BNE	LAB_1E77		; branch if no match
00CF12  2               
00CF12  2  A5 94        	LDA	Varnm2		; else get this array name second byte
00CF14  2  D1 AA        	CMP	(Astrtl),Y		; compare with array name second byte
00CF16  2  F0 16        	BEQ	LAB_1E8D		; array found so branch
00CF18  2               
00CF18  2               					; no match
00CF18  2               LAB_1E77
00CF18  2  C8           	INY				; increment index
00CF19  2  B1 AA        	LDA	(Astrtl),Y		; get array size low byte
00CF1B  2  18           	CLC				; clear carry for add
00CF1C  2  65 AA        	ADC	Astrtl		; add array start pointer low byte
00CF1E  2  AA           	TAX				; copy low byte to X
00CF1F  2  C8           	INY				; increment index
00CF20  2  B1 AA        	LDA	(Astrtl),Y		; get array size high byte
00CF22  2  65 AB        	ADC	Astrth		; add array mem pointer high byte
00CF24  2  90 D7        	BCC	LAB_1E5C		; if no overflow go check next array
00CF26  2               
00CF26  2               ; do array bounds error
00CF26  2               
00CF26  2               LAB_1E85
00CF26  2  A2 10        	LDX	#$10			; error code $10 ("Array bounds" error)
00CF28  2  2C           	.byte	$2C			; makes next bit BIT LAB_08A2
00CF29  2               
00CF29  2               ; do function call error
00CF29  2               
00CF29  2               LAB_FCER
00CF29  2  A2 08        	LDX	#$08			; error code $08 ("Function call" error)
00CF2B  2               LAB_1E8A
00CF2B  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00CF2E  2               
00CF2E  2               					; found array, are we trying to dimension it?
00CF2E  2               LAB_1E8D
00CF2E  2  A2 12        	LDX	#$12			; set error $12 ("Double dimension" error)
00CF30  2  A5 5E        	LDA	Defdim		; get DIM flag
00CF32  2  D0 F7        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
00CF34  2               					; start
00CF34  2               
00CF34  2               ; found the array and we're not dimensioning it so we must find an element in it
00CF34  2               
00CF34  2  20 8B CE     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
00CF37  2               					; (Astrtl,Astrth points to start of array)
00CF37  2  A5 5D        	LDA	Dimcnt		; get dimensions count
00CF39  2  A0 04        	LDY	#$04			; set index to array's # of dimensions
00CF3B  2  D1 AA        	CMP	(Astrtl),Y		; compare with no of dimensions
00CF3D  2  D0 E7        	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
00CF3F  2               					; dimensions" error here .. if we want a different
00CF3F  2               					; error message
00CF3F  2               
00CF3F  2  4C C5 CF     	JMP	LAB_1F28		; found array so go get element
00CF42  2               					; (could jump to LAB_1F28 as all LAB_1F24 does is take
00CF42  2               					; Dimcnt and save it at (Astrtl),Y which is already the
00CF42  2               					; same or we would have taken the BNE)
00CF42  2               
00CF42  2               					; array not found, so build it
00CF42  2               LAB_1EA1
00CF42  2  20 8B CE     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
00CF45  2               					; (Astrtl,Astrth points to start of array)
00CF45  2  20 0B C1     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
00CF48  2               					; addr to check is in AY (low/high)
00CF48  2  A0 00        	LDY	#$00			; clear Y (don't need to clear A)
00CF4A  2  84 BB        	STY	Aspth			; clear array data size high byte
00CF4C  2  A5 93        	LDA	Varnm1		; get variable name 1st byte
00CF4E  2  91 AA        	STA	(Astrtl),Y		; save array name 1st byte
00CF50  2  C8           	INY				; increment index
00CF51  2  A5 94        	LDA	Varnm2		; get variable name 2nd byte
00CF53  2  91 AA        	STA	(Astrtl),Y		; save array name 2nd byte
00CF55  2  A5 5D        	LDA	Dimcnt		; get dimensions count
00CF57  2  A0 04        	LDY	#$04			; index to dimension count
00CF59  2  84 BA        	STY	Asptl			; set array data size low byte (four bytes per element)
00CF5B  2  91 AA        	STA	(Astrtl),Y		; set array's dimensions count
00CF5D  2               
00CF5D  2               					; now calculate the size of the data space for the array
00CF5D  2  18           	CLC				; clear carry for add (clear on subsequent loops)
00CF5E  2               LAB_1EC0
00CF5E  2  A2 0B        	LDX	#$0B			; set default dimension value low byte
00CF60  2  A9 00        	LDA	#$00			; set default dimension value high byte
00CF62  2  24 5E        	BIT	Defdim		; test default DIM flag
00CF64  2  50 07        	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
00CF66  2               
00CF66  2  68           	PLA				; else pull dimension value low byte
00CF67  2  69 01        	ADC	#$01			; +1 (allow for zeroeth element)
00CF69  2  AA           	TAX				; copy low byte to X
00CF6A  2  68           	PLA				; pull dimension value high byte
00CF6B  2  69 00        	ADC	#$00			; add carry from low byte
00CF6D  2               
00CF6D  2               LAB_1ED0
00CF6D  2  C8           	INY				; index to dimension value high byte
00CF6E  2  91 AA        	STA	(Astrtl),Y		; save dimension value high byte
00CF70  2  C8           	INY				; index to dimension value high byte
00CF71  2  8A           	TXA				; get dimension value low byte
00CF72  2  91 AA        	STA	(Astrtl),Y		; save dimension value low byte
00CF74  2  20 14 D0     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
00CF77  2  86 BA        	STX	Asptl			; save array data size low byte
00CF79  2  85 BB        	STA	Aspth			; save array data size high byte
00CF7B  2  A4 71        	LDY	ut1_pl		; restore index (saved by subroutine)
00CF7D  2  C6 5D        	DEC	Dimcnt		; decrement dimensions count
00CF7F  2  D0 DD        	BNE	LAB_1EC0		; loop while not = 0
00CF81  2               
00CF81  2  65 A5        	ADC	Adatah		; add size high byte to first element high byte
00CF83  2               					; (carry is always clear here)
00CF83  2  B0 5D        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
00CF85  2               
00CF85  2  85 A5        	STA	Adatah		; save end of array high byte
00CF87  2  A8           	TAY				; copy end high byte to Y
00CF88  2  8A           	TXA				; get array size low byte
00CF89  2  65 A4        	ADC	Adatal		; add array start low byte
00CF8B  2  90 03        	BCC	LAB_1EF3		; branch if no carry
00CF8D  2               
00CF8D  2  C8           	INY				; else increment end of array high byte
00CF8E  2  F0 52        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
00CF90  2               
00CF90  2               					; set-up mostly complete, now zero the array
00CF90  2               LAB_1EF3
00CF90  2  20 0B C1     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
00CF93  2               					; addr to check is in AY (low/high)
00CF93  2  85 7F        	STA	Earryl		; save array mem end low byte
00CF95  2  84 80        	STY	Earryh		; save array mem end high byte
00CF97  2  A9 00        	LDA	#$00			; clear byte for array clear
00CF99  2  E6 BB        	INC	Aspth			; increment array size high byte (now block count)
00CF9B  2  A4 BA        	LDY	Asptl			; get array size low byte (now index to block)
00CF9D  2  F0 05        	BEQ	LAB_1F07		; branch if low byte = $00
00CF9F  2               
00CF9F  2               LAB_1F02
00CF9F  2  88           	DEY				; decrement index (do 0 to n-1)
00CFA0  2  91 A4        	STA	(Adatal),Y		; zero byte
00CFA2  2  D0 FB        	BNE	LAB_1F02		; loop until this block done
00CFA4  2               
00CFA4  2               LAB_1F07
00CFA4  2  C6 A5        	DEC	Adatah		; decrement array pointer high byte
00CFA6  2  C6 BB        	DEC	Aspth			; decrement block count high byte
00CFA8  2  D0 F5        	BNE	LAB_1F02		; loop until all blocks done
00CFAA  2               
00CFAA  2  E6 A5        	INC	Adatah		; correct for last loop
00CFAC  2  38           	SEC				; set carry for subtract
00CFAD  2  A0 02        	LDY	#$02			; index to array size low byte
00CFAF  2  A5 7F        	LDA	Earryl		; get array mem end low byte
00CFB1  2  E5 AA        	SBC	Astrtl		; subtract array start low byte
00CFB3  2  91 AA        	STA	(Astrtl),Y		; save array size low byte
00CFB5  2  C8           	INY				; index to array size high byte
00CFB6  2  A5 80        	LDA	Earryh		; get array mem end high byte
00CFB8  2  E5 AB        	SBC	Astrth		; subtract array start high byte
00CFBA  2  91 AA        	STA	(Astrtl),Y		; save array size high byte
00CFBC  2  A5 5E        	LDA	Defdim		; get default DIM flag
00CFBE  2  D0 53        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
00CFC0  2               
00CFC0  2               					; else, find element
00CFC0  2  C8           	INY				; index to # of dimensions
00CFC1  2               
00CFC1  2               LAB_1F24
00CFC1  2  B1 AA        	LDA	(Astrtl),Y		; get array's dimension count
00CFC3  2  85 5D        	STA	Dimcnt		; save it
00CFC5  2               
00CFC5  2               ; we have found, or built, the array. now we need to find the element
00CFC5  2               
00CFC5  2               LAB_1F28
00CFC5  2  A9 00        	LDA	#$00			; clear byte
00CFC7  2  85 BA        	STA	Asptl			; clear array data pointer low byte
00CFC9  2               LAB_1F2C
00CFC9  2  85 BB        	STA	Aspth			; save array data pointer high byte
00CFCB  2  C8           	INY				; increment index (point to array bound high byte)
00CFCC  2  68           	PLA				; pull array index low byte
00CFCD  2  AA           	TAX				; copy to X
00CFCE  2  85 AE        	STA	FAC1_2		; save index low byte to FAC1 mantissa2
00CFD0  2  68           	PLA				; pull array index high byte
00CFD1  2  85 AF        	STA	FAC1_3		; save index high byte to FAC1 mantissa3
00CFD3  2  D1 AA        	CMP	(Astrtl),Y		; compare with array bound high byte
00CFD5  2  90 0E        	BCC	LAB_1F48		; branch if within bounds
00CFD7  2               
00CFD7  2  D0 06        	BNE	LAB_1F42		; if outside bounds do array bounds error
00CFD9  2               
00CFD9  2               					; else high byte was = so test low bytes
00CFD9  2  C8           	INY				; index to array bound low byte
00CFDA  2  8A           	TXA				; get array index low byte
00CFDB  2  D1 AA        	CMP	(Astrtl),Y		; compare with array bound low byte
00CFDD  2  90 07        	BCC	LAB_1F49		; branch if within bounds
00CFDF  2               
00CFDF  2               LAB_1F42
00CFDF  2  4C 26 CF     	JMP	LAB_1E85		; else do array bounds error
00CFE2  2               
00CFE2  2               LAB_1F45
00CFE2  2  4C 3A C1     	JMP	LAB_OMER		; do "Out of memory" error then warm start
00CFE5  2               
00CFE5  2               LAB_1F48
00CFE5  2  C8           	INY				; index to array bound low byte
00CFE6  2               LAB_1F49
00CFE6  2  A5 BB        	LDA	Aspth			; get array data pointer high byte
00CFE8  2  05 BA        	ORA	Asptl			; OR with array data pointer low byte
00CFEA  2  F0 0A        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
00CFEC  2               
00CFEC  2  20 14 D0     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
00CFEF  2  8A           	TXA				; get result low byte
00CFF0  2  65 AE        	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
00CFF2  2  AA           	TAX				; save result low byte
00CFF3  2  98           	TYA				; get result high byte
00CFF4  2  A4 71        	LDY	ut1_pl		; restore index
00CFF6  2               LAB_1F5A
00CFF6  2  65 AF        	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
00CFF8  2  86 BA        	STX	Asptl			; save array data pointer low byte
00CFFA  2  C6 5D        	DEC	Dimcnt		; decrement dimensions count
00CFFC  2  D0 CB        	BNE	LAB_1F2C		; loop if dimensions still to do
00CFFE  2               
00CFFE  2  06 BA        	ASL	Asptl			; array data pointer low byte * 2
00D000  2  2A           	ROL				; array data pointer high byte * 2
00D001  2  06 BA        	ASL	Asptl			; array data pointer low byte * 4
00D003  2  2A           	ROL				; array data pointer high byte * 4
00D004  2  A8           	TAY				; copy high byte
00D005  2  A5 BA        	LDA	Asptl			; get low byte
00D007  2  65 A4        	ADC	Adatal		; add array data start pointer low byte
00D009  2  85 95        	STA	Cvaral		; save as current var address low byte
00D00B  2  98           	TYA				; get high byte back
00D00C  2  65 A5        	ADC	Adatah		; add array data start pointer high byte
00D00E  2  85 96        	STA	Cvarah		; save as current var address high byte
00D010  2  A8           	TAY				; copy high byte to Y
00D011  2  A5 95        	LDA	Cvaral		; get current var address low byte
00D013  2               LAB_1F7B
00D013  2  60           	RTS
00D014  2               
00D014  2               ; does XY = (Astrtl),Y * (Asptl)
00D014  2               
00D014  2               LAB_1F7C
00D014  2  84 71        	STY	ut1_pl		; save index
00D016  2  B1 AA        	LDA	(Astrtl),Y		; get dimension size low byte
00D018  2  85 76        	STA	dims_l		; save dimension size low byte
00D01A  2  88           	DEY				; decrement index
00D01B  2  B1 AA        	LDA	(Astrtl),Y		; get dimension size high byte
00D01D  2  85 77        	STA	dims_h		; save dimension size high byte
00D01F  2               
00D01F  2  A9 10        	LDA	#$10			; count = $10 (16 bit multiply)
00D021  2  85 A8        	STA	numbit		; save bit count
00D023  2  A2 00        	LDX	#$00			; clear result low byte
00D025  2  A0 00        	LDY	#$00			; clear result high byte
00D027  2               LAB_1F8F
00D027  2  8A           	TXA				; get result low byte
00D028  2  0A           	ASL				; *2
00D029  2  AA           	TAX				; save result low byte
00D02A  2  98           	TYA				; get result high byte
00D02B  2  2A           	ROL				; *2
00D02C  2  A8           	TAY				; save result high byte
00D02D  2  B0 B3        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
00D02F  2               
00D02F  2  06 BA        	ASL	Asptl			; shift multiplier low byte
00D031  2  26 BB        	ROL	Aspth			; shift multiplier high byte
00D033  2  90 0B        	BCC	LAB_1FA8		; skip add if no carry
00D035  2               
00D035  2  18           	CLC				; else clear carry for add
00D036  2  8A           	TXA				; get result low byte
00D037  2  65 76        	ADC	dims_l		; add dimension size low byte
00D039  2  AA           	TAX				; save result low byte
00D03A  2  98           	TYA				; get result high byte
00D03B  2  65 77        	ADC	dims_h		; add dimension size high byte
00D03D  2  A8           	TAY				; save result high byte
00D03E  2  B0 A2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
00D040  2               
00D040  2               LAB_1FA8
00D040  2  C6 A8        	DEC	numbit		; decrement bit count
00D042  2  D0 E3        	BNE	LAB_1F8F		; loop until all done
00D044  2               
00D044  2  60           	RTS
00D045  2               
00D045  2               ; perform FRE()
00D045  2               
00D045  2               LAB_FRE
00D045  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00D047  2  10 03        	BPL	LAB_1FB4		; branch if numeric
00D049  2               
00D049  2  20 3E D3     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
00D04C  2               					; space returns with A = length, X=$71=pointer low byte,
00D04C  2               					; Y=$72=pointer high byte
00D04C  2               
00D04C  2               					; FRE(n) was numeric so do this
00D04C  2               LAB_1FB4
00D04C  2  20 DF D1     	JSR	LAB_GARB		; go do garbage collection
00D04F  2  38           	SEC				; set carry for subtract
00D050  2  A5 81        	LDA	Sstorl		; get bottom of string space low byte
00D052  2  E5 7F        	SBC	Earryl		; subtract array mem end low byte
00D054  2  A8           	TAY				; copy result to Y
00D055  2  A5 82        	LDA	Sstorh		; get bottom of string space high byte
00D057  2  E5 80        	SBC	Earryh		; subtract array mem end high byte
00D059  2               
00D059  2               ; save and convert integer AY to FAC1
00D059  2               
00D059  2               LAB_AYFC
00D059  2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
00D05B  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00D05D  2  84 AE        	STY	FAC1_2		; save FAC1 mantissa2
00D05F  2  A2 90        	LDX	#$90			; set exponent=2^16 (integer)
00D061  2  4C 02 D9     	JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
00D064  2               
00D064  2               ; perform POS()
00D064  2               
00D064  2               LAB_POS
00D064  2  A4 0E        	LDY	TPos			; get terminal position
00D066  2               
00D066  2               ; convert Y to byte in FAC1
00D066  2               
00D066  2               LAB_1FD0
00D066  2  A9 00        	LDA	#$00			; clear high byte
00D068  2  F0 EF        	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
00D06A  2               
00D06A  2               ; check not Direct (used by DEF and INPUT)
00D06A  2               
00D06A  2               LAB_CKRN
00D06A  2  A6 88        	LDX	Clineh		; get current line high byte
00D06C  2  E8           	INX				; increment it
00D06D  2  D0 A4        	BNE	LAB_1F7B		; return if can continue not direct mode
00D06F  2               
00D06F  2               					; else do illegal direct error
00D06F  2               LAB_1FD9
00D06F  2  A2 16        	LDX	#$16			; error code $16 ("Illegal direct" error)
00D071  2               LAB_1FDB
00D071  2  4C 3C C1     	JMP	LAB_XERR		; go do error #X, then warm start
00D074  2               
00D074  2               ; perform DEF
00D074  2               
00D074  2               LAB_DEF
00D074  2  20 A5 D0     	JSR	LAB_200B		; check FNx syntax
00D077  2  85 9C        	STA	func_l		; save function pointer low byte
00D079  2  84 9D        	STY	func_h		; save function pointer high byte
00D07B  2  20 6A D0     	JSR	LAB_CKRN		; check not Direct (back here if ok)
00D07E  2  20 FA CB     	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
00D081  2  A9 80        	LDA	#$80			; set flag for FNx
00D083  2  85 61        	STA	Sufnxf		; save subscript/FNx flag
00D085  2  20 AA CD     	JSR	LAB_GVAR		; get (var) address
00D088  2  20 D0 CA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00D08B  2  20 EF CB     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
00D08E  2  A9 C1        	LDA	#TK_EQUAL		; get = token
00D090  2  20 F1 CB     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
00D093  2  A5 96        	LDA	Cvarah		; get current var address high byte
00D095  2  48           	PHA				; push it
00D096  2  A5 95        	LDA	Cvaral		; get current var address low byte
00D098  2  48           	PHA				; push it
00D099  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00D09B  2  48           	PHA				; push it
00D09C  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00D09E  2  48           	PHA				; push it
00D09F  2  20 8C C6     	JSR	LAB_DATA		; go perform DATA
00D0A2  2  4C 14 D1     	JMP	LAB_207A		; put execute pointer and variable pointer into function
00D0A5  2               					; and return
00D0A5  2               
00D0A5  2               ; check FNx syntax
00D0A5  2               
00D0A5  2               LAB_200B
00D0A5  2  A9 AE        	LDA	#TK_FN		; get FN" token
00D0A7  2  20 F1 CB     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
00D0AA  2               					; return character after A
00D0AA  2  09 80        	ORA	#$80			; set FN flag bit
00D0AC  2  85 61        	STA	Sufnxf		; save FN flag so array variable test fails
00D0AE  2  20 B1 CD     	JSR	LAB_1D12		; search for FN variable
00D0B1  2  4C D0 CA     	JMP	LAB_CTNM		; check if source is numeric and return, else do type
00D0B4  2               					; mismatch
00D0B4  2               
00D0B4  2               					; Evaluate FNx
00D0B4  2               LAB_201E
00D0B4  2  20 A5 D0     	JSR	LAB_200B		; check FNx syntax
00D0B7  2  48           	PHA				; push function pointer low byte
00D0B8  2  98           	TYA				; copy function pointer high byte
00D0B9  2  48           	PHA				; push function pointer high byte
00D0BA  2  20 FA CB     	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
00D0BD  2  20 E1 CA     	JSR	LAB_EVEX		; evaluate expression
00D0C0  2  20 EF CB     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
00D0C3  2  20 D0 CA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00D0C6  2  68           	PLA				; pop function pointer high byte
00D0C7  2  85 9D        	STA	func_h		; restore it
00D0C9  2  68           	PLA				; pop function pointer low byte
00D0CA  2  85 9C        	STA	func_l		; restore it
00D0CC  2  A2 20        	LDX	#$20			; error code $20 ("Undefined function" error)
00D0CE  2  A0 03        	LDY	#$03			; index to variable pointer high byte
00D0D0  2  B1 9C        	LDA	(func_l),Y		; get variable pointer high byte
00D0D2  2  F0 9D        	BEQ	LAB_1FDB		; if zero go do undefined function error
00D0D4  2               
00D0D4  2  85 96        	STA	Cvarah		; save variable address high byte
00D0D6  2  88           	DEY				; index to variable address low byte
00D0D7  2  B1 9C        	LDA	(func_l),Y		; get variable address low byte
00D0D9  2  85 95        	STA	Cvaral		; save variable address low byte
00D0DB  2  AA           	TAX				; copy address low byte
00D0DC  2               
00D0DC  2               					; now stack the function variable value before use
00D0DC  2  C8           	INY				; index to mantissa_3
00D0DD  2               LAB_2043
00D0DD  2  B1 95        	LDA	(Cvaral),Y		; get byte from variable
00D0DF  2  48           	PHA				; stack it
00D0E0  2  88           	DEY				; decrement index
00D0E1  2  10 FA        	BPL	LAB_2043		; loop until variable stacked
00D0E3  2               
00D0E3  2  A4 96        	LDY	Cvarah		; get variable address high byte
00D0E5  2  20 A7 D8     	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
00D0E8  2               					; (function variable), return Y=0, always
00D0E8  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00D0EA  2  48           	PHA				; push it
00D0EB  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00D0ED  2  48           	PHA				; push it
00D0EE  2  B1 9C        	LDA	(func_l),Y		; get function execute pointer low byte
00D0F0  2  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
00D0F2  2  C8           	INY				; index to high byte
00D0F3  2  B1 9C        	LDA	(func_l),Y		; get function execute pointer high byte
00D0F5  2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
00D0F7  2  A5 96        	LDA	Cvarah		; get variable address high byte
00D0F9  2  48           	PHA				; push it
00D0FA  2  A5 95        	LDA	Cvaral		; get variable address low byte
00D0FC  2  48           	PHA				; push it
00D0FD  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00D100  2               					; else do type mismatch
00D100  2  68           	PLA				; pull variable address low byte
00D101  2  85 9C        	STA	func_l		; save variable address low byte
00D103  2  68           	PLA				; pull variable address high byte
00D104  2  85 9D        	STA	func_h		; save variable address high byte
00D106  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00D109  2  F0 03        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
00D10B  2               
00D10B  2  4C 02 CC     	JMP	LAB_SNER		; else syntax error then warm start
00D10E  2               
00D10E  2               ; restore Bpntrl,Bpntrh and function variable from stack
00D10E  2               
00D10E  2               LAB_2074
00D10E  2  68           	PLA				; pull BASIC execute pointer low byte
00D10F  2  85 C3        	STA	Bpntrl		; restore BASIC execute pointer low byte
00D111  2  68           	PLA				; pull BASIC execute pointer high byte
00D112  2  85 C4        	STA	Bpntrh		; restore BASIC execute pointer high byte
00D114  2               
00D114  2               ; put execute pointer and variable pointer into function
00D114  2               
00D114  2               LAB_207A
00D114  2  A0 00        	LDY	#$00			; clear index
00D116  2  68           	PLA				; pull BASIC execute pointer low byte
00D117  2  91 9C        	STA	(func_l),Y		; save to function
00D119  2  C8           	INY				; increment index
00D11A  2  68           	PLA				; pull BASIC execute pointer high byte
00D11B  2  91 9C        	STA	(func_l),Y		; save to function
00D11D  2  C8           	INY				; increment index
00D11E  2  68           	PLA				; pull current var address low byte
00D11F  2  91 9C        	STA	(func_l),Y		; save to function
00D121  2  C8           	INY				; increment index
00D122  2  68           	PLA				; pull current var address high byte
00D123  2  91 9C        	STA	(func_l),Y		; save to function
00D125  2  60           	RTS
00D126  2               
00D126  2               ; perform STR$()
00D126  2               
00D126  2               LAB_STRS
00D126  2  20 D0 CA     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00D129  2  20 95 DA     	JSR	LAB_296E		; convert FAC1 to string
00D12C  2  A9 F0        	LDA	#<Decssp1		; set result string low pointer
00D12E  2  A0 00        	LDY	#>Decssp1		; set result string high pointer
00D130  2  F0 12        	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
00D132  2               
00D132  2               ; Do string vector
00D132  2               ; copy des_pl/h to des_2l/h and make string space A bytes long
00D132  2               
00D132  2               LAB_209C
00D132  2  A6 AE        	LDX	des_pl		; get descriptor pointer low byte
00D134  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
00D136  2  86 9E        	STX	des_2l		; save descriptor pointer low byte
00D138  2  84 9F        	STY	des_2h		; save descriptor pointer high byte
00D13A  2               
00D13A  2               ; make string space A bytes long
00D13A  2               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D13A  2               
00D13A  2               LAB_MSSP
00D13A  2  20 AD D1     	JSR	LAB_2115		; make space in string memory for string A long
00D13D  2               					; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D13D  2  86 AD        	STX	str_pl		; save string pointer low byte
00D13F  2  84 AE        	STY	str_ph		; save string pointer high byte
00D141  2  85 AC        	STA	str_ln		; save length
00D143  2  60           	RTS
00D144  2               
00D144  2               ; Scan, set up string
00D144  2               ; print " terminated string to Sutill/Sutilh
00D144  2               
00D144  2               LAB_20AE
00D144  2  A2 22        	LDX	#$22			; set terminator to "
00D146  2  86 5B        	STX	Srchc			; set search character (terminator 1)
00D148  2  86 5C        	STX	Asrch			; set terminator 2
00D14A  2               
00D14A  2               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
00D14A  2               ; source is AY
00D14A  2               
00D14A  2               LAB_20B4
00D14A  2  85 B8        	STA	ssptr_l		; store string start low byte
00D14C  2  84 B9        	STY	ssptr_h		; store string start high byte
00D14E  2  85 AD        	STA	str_pl		; save string pointer low byte
00D150  2  84 AE        	STY	str_ph		; save string pointer high byte
00D152  2  A0 FF        	LDY	#$FF			; set length to -1
00D154  2               LAB_20BE
00D154  2  C8           	INY				; increment length
00D155  2  B1 B8        	LDA	(ssptr_l),Y		; get byte from string
00D157  2  F0 0C        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
00D159  2               
00D159  2  C5 5B        	CMP	Srchc			; compare with search character (terminator 1)
00D15B  2  F0 04        	BEQ	LAB_20CB		; branch if terminator
00D15D  2               
00D15D  2  C5 5C        	CMP	Asrch			; compare with terminator 2
00D15F  2  D0 F3        	BNE	LAB_20BE		; loop if not terminator 2
00D161  2               
00D161  2               LAB_20CB
00D161  2  C9 22        	CMP	#$22			; compare with "
00D163  2  F0 01        	BEQ	LAB_20D0		; branch if " (carry set if = !)
00D165  2               
00D165  2               LAB_20CF
00D165  2  18           	CLC				; clear carry for add (only if [EOL] terminated string)
00D166  2               LAB_20D0
00D166  2  84 AC        	STY	str_ln		; save length in FAC1 exponent
00D168  2  98           	TYA				; copy length to A
00D169  2  65 B8        	ADC	ssptr_l		; add string start low byte
00D16B  2  85 BA        	STA	Sendl			; save string end low byte
00D16D  2  A6 B9        	LDX	ssptr_h		; get string start high byte
00D16F  2  90 01        	BCC	LAB_20DC		; branch if no low byte overflow
00D171  2               
00D171  2  E8           	INX				; else increment high byte
00D172  2               LAB_20DC
00D172  2  86 BB        	STX	Sendh			; save string end high byte
00D174  2  A5 B9        	LDA	ssptr_h		; get string start high byte
00D176  2  C9 03        	CMP	#>Ram_base		; compare with start of program memory
00D178  2  B0 0B        	BCS	LAB_RTST		; branch if not in utility area
00D17A  2               
00D17A  2               					; string in utility area, move to string memory
00D17A  2  98           	TYA				; copy length to A
00D17B  2  20 32 D1     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
00D17E  2               					; long
00D17E  2  A6 B8        	LDX	ssptr_l		; get string start low byte
00D180  2  A4 B9        	LDY	ssptr_h		; get string start high byte
00D182  2  20 1F D3     	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
00D185  2               
00D185  2               ; check for space on descriptor stack then ..
00D185  2               ; put string address and length on descriptor stack and update stack pointers
00D185  2               
00D185  2               LAB_RTST
00D185  2  A6 65        	LDX	next_s		; get string stack pointer
00D187  2  E0 71        	CPX	#des_sk+$09		; compare with max+1
00D189  2  D0 05        	BNE	LAB_20F8		; branch if space on string stack
00D18B  2               
00D18B  2               					; else do string too complex error
00D18B  2  A2 1C        	LDX	#$1C			; error code $1C ("String too complex" error)
00D18D  2               LAB_20F5
00D18D  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00D190  2               
00D190  2               ; put string address and length on descriptor stack and update stack pointers
00D190  2               
00D190  2               LAB_20F8
00D190  2  A5 AC        	LDA	str_ln		; get string length
00D192  2  95 00        	STA	PLUS_0,X		; put on string stack
00D194  2  A5 AD        	LDA	str_pl		; get string pointer low byte
00D196  2  95 01        	STA	PLUS_1,X		; put on string stack
00D198  2  A5 AE        	LDA	str_ph		; get string pointer high byte
00D19A  2  95 02        	STA	PLUS_2,X		; put on string stack
00D19C  2  A0 00        	LDY	#$00			; clear Y
00D19E  2  86 AE        	STX	des_pl		; save string descriptor pointer low byte
00D1A0  2  84 AF        	STY	des_ph		; save string descriptor pointer high byte (always $00)
00D1A2  2  88           	DEY				; Y = $FF
00D1A3  2  84 5F        	STY	Dtypef		; save data type flag, $FF=string
00D1A5  2  86 66        	STX	last_sl		; save old stack pointer (current top item)
00D1A7  2  E8           	INX				; update stack pointer
00D1A8  2  E8           	INX				; update stack pointer
00D1A9  2  E8           	INX				; update stack pointer
00D1AA  2  86 65        	STX	next_s		; save new top item value
00D1AC  2  60           	RTS
00D1AD  2               
00D1AD  2               ; Build descriptor
00D1AD  2               ; make space in string memory for string A long
00D1AD  2               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
00D1AD  2               
00D1AD  2               LAB_2115
00D1AD  2  46 60        	LSR	Gclctd		; clear garbage collected flag (b7)
00D1AF  2               
00D1AF  2               					; make space for string A long
00D1AF  2               LAB_2117
00D1AF  2  48           	PHA				; save string length
00D1B0  2  49 FF        	EOR	#$FF			; complement it
00D1B2  2  38           	SEC				; set carry for subtract (twos comp add)
00D1B3  2  65 81        	ADC	Sstorl		; add bottom of string space low byte (subtract length)
00D1B5  2  A4 82        	LDY	Sstorh		; get bottom of string space high byte
00D1B7  2  B0 01        	BCS	LAB_2122		; skip decrement if no underflow
00D1B9  2               
00D1B9  2  88           	DEY				; decrement bottom of string space high byte
00D1BA  2               LAB_2122
00D1BA  2  C4 80        	CPY	Earryh		; compare with array mem end high byte
00D1BC  2  90 11        	BCC	LAB_2137		; do out of memory error if less
00D1BE  2               
00D1BE  2  D0 04        	BNE	LAB_212C		; if not = skip next test
00D1C0  2               
00D1C0  2  C5 7F        	CMP	Earryl		; compare with array mem end low byte
00D1C2  2  90 0B        	BCC	LAB_2137		; do out of memory error if less
00D1C4  2               
00D1C4  2               LAB_212C
00D1C4  2  85 81        	STA	Sstorl		; save bottom of string space low byte
00D1C6  2  84 82        	STY	Sstorh		; save bottom of string space high byte
00D1C8  2  85 83        	STA	Sutill		; save string utility ptr low byte
00D1CA  2  84 84        	STY	Sutilh		; save string utility ptr high byte
00D1CC  2  AA           	TAX				; copy low byte to X
00D1CD  2  68           	PLA				; get string length back
00D1CE  2  60           	RTS
00D1CF  2               
00D1CF  2               LAB_2137
00D1CF  2  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
00D1D1  2  A5 60        	LDA	Gclctd		; get garbage collected flag
00D1D3  2  30 B8        	BMI	LAB_20F5		; if set then do error code X
00D1D5  2               
00D1D5  2  20 DF D1     	JSR	LAB_GARB		; else go do garbage collection
00D1D8  2  A9 80        	LDA	#$80			; flag for garbage collected
00D1DA  2  85 60        	STA	Gclctd		; set garbage collected flag
00D1DC  2  68           	PLA				; pull length
00D1DD  2  D0 D0        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
00D1DF  2               
00D1DF  2               ; garbage collection routine
00D1DF  2               
00D1DF  2               LAB_GARB
00D1DF  2  A6 85        	LDX	Ememl			; get end of mem low byte
00D1E1  2  A5 86        	LDA	Ememh			; get end of mem high byte
00D1E3  2               
00D1E3  2               ; re-run routine from last ending
00D1E3  2               
00D1E3  2               LAB_214B
00D1E3  2  86 81        	STX	Sstorl		; set string storage low byte
00D1E5  2  85 82        	STA	Sstorh		; set string storage high byte
00D1E7  2  A0 00        	LDY	#$00			; clear index
00D1E9  2  84 9D        	STY	garb_h		; clear working pointer high byte (flag no strings to move)
00D1EB  2  A5 7F        	LDA	Earryl		; get array mem end low byte
00D1ED  2  A6 80        	LDX	Earryh		; get array mem end high byte
00D1EF  2  85 AA        	STA	Histrl		; save as highest string low byte
00D1F1  2  86 AB        	STX	Histrh		; save as highest string high byte
00D1F3  2  A9 68        	LDA	#des_sk		; set descriptor stack pointer
00D1F5  2  85 71        	STA	ut1_pl		; save descriptor stack pointer low byte
00D1F7  2  84 72        	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
00D1F9  2               LAB_2161
00D1F9  2  C5 65        	CMP	next_s		; compare with descriptor stack pointer
00D1FB  2  F0 05        	BEQ	LAB_216A		; branch if =
00D1FD  2               
00D1FD  2  20 63 D2     	JSR	LAB_21D7		; go garbage collect descriptor stack
00D200  2  F0 F7        	BEQ	LAB_2161		; loop always
00D202  2               
00D202  2               					; done stacked strings, now do string vars
00D202  2               LAB_216A
00D202  2  06 A0        	ASL	g_step		; set step size = $06
00D204  2  A5 7B        	LDA	Svarl			; get start of vars low byte
00D206  2  A6 7C        	LDX	Svarh			; get start of vars high byte
00D208  2  85 71        	STA	ut1_pl		; save as pointer low byte
00D20A  2  86 72        	STX	ut1_ph		; save as pointer high byte
00D20C  2               LAB_2176
00D20C  2  E4 7E        	CPX	Sarryh		; compare start of arrays high byte
00D20E  2  D0 04        	BNE	LAB_217E		; branch if no high byte match
00D210  2               
00D210  2  C5 7D        	CMP	Sarryl		; else compare start of arrays low byte
00D212  2  F0 05        	BEQ	LAB_2183		; branch if = var mem end
00D214  2               
00D214  2               LAB_217E
00D214  2  20 5D D2     	JSR	LAB_21D1		; go garbage collect strings
00D217  2  F0 F3        	BEQ	LAB_2176		; loop always
00D219  2               
00D219  2               					; done string vars, now do string arrays
00D219  2               LAB_2183
00D219  2  85 A4        	STA	Nbendl		; save start of arrays low byte as working pointer
00D21B  2  86 A5        	STX	Nbendh		; save start of arrays high byte as working pointer
00D21D  2  A9 04        	LDA	#$04			; set step size
00D21F  2  85 A0        	STA	g_step		; save step size
00D221  2               LAB_218B
00D221  2  A5 A4        	LDA	Nbendl		; get pointer low byte
00D223  2  A6 A5        	LDX	Nbendh		; get pointer high byte
00D225  2               LAB_218F
00D225  2  E4 80        	CPX	Earryh		; compare with array mem end high byte
00D227  2  D0 04        	BNE	LAB_219A		; branch if not at end
00D229  2               
00D229  2  C5 7F        	CMP	Earryl		; else compare with array mem end low byte
00D22B  2  F0 75        	BEQ	LAB_2216		; tidy up and exit if at end
00D22D  2               
00D22D  2               LAB_219A
00D22D  2  85 71        	STA	ut1_pl		; save pointer low byte
00D22F  2  86 72        	STX	ut1_ph		; save pointer high byte
00D231  2  A0 02        	LDY	#$02			; set index
00D233  2  B1 71        	LDA	(ut1_pl),Y		; get array size low byte
00D235  2  65 A4        	ADC	Nbendl		; add start of this array low byte
00D237  2  85 A4        	STA	Nbendl		; save start of next array low byte
00D239  2  C8           	INY				; increment index
00D23A  2  B1 71        	LDA	(ut1_pl),Y		; get array size high byte
00D23C  2  65 A5        	ADC	Nbendh		; add start of this array high byte
00D23E  2  85 A5        	STA	Nbendh		; save start of next array high byte
00D240  2  A0 01        	LDY	#$01			; set index
00D242  2  B1 71        	LDA	(ut1_pl),Y		; get name second byte
00D244  2  10 DB        	BPL	LAB_218B		; skip if not string array
00D246  2               
00D246  2               ; was string array so ..
00D246  2               
00D246  2  A0 04        	LDY	#$04			; set index
00D248  2  B1 71        	LDA	(ut1_pl),Y		; get # of dimensions
00D24A  2  0A           	ASL				; *2
00D24B  2  69 05        	ADC	#$05			; +5 (array header size)
00D24D  2  20 95 D2     	JSR	LAB_2208		; go set up for first element
00D250  2               LAB_21C4
00D250  2  E4 A5        	CPX	Nbendh		; compare with start of next array high byte
00D252  2  D0 04        	BNE	LAB_21CC		; branch if <> (go do this array)
00D254  2               
00D254  2  C5 A4        	CMP	Nbendl		; else compare element pointer low byte with next array
00D256  2               					; low byte
00D256  2  F0 CD        	BEQ	LAB_218F		; if equal then go do next array
00D258  2               
00D258  2               LAB_21CC
00D258  2  20 63 D2     	JSR	LAB_21D7		; go defrag array strings
00D25B  2  F0 F3        	BEQ	LAB_21C4		; go do next array string (loop always)
00D25D  2               
00D25D  2               ; defrag string variables
00D25D  2               ; enter with XA = variable pointer
00D25D  2               ; return with XA = next variable pointer
00D25D  2               
00D25D  2               LAB_21D1
00D25D  2  C8           	INY				; increment index (Y was $00)
00D25E  2  B1 71        	LDA	(ut1_pl),Y		; get var name byte 2
00D260  2  10 30        	BPL	LAB_2206		; if not string, step pointer to next var and return
00D262  2               
00D262  2  C8           	INY				; else increment index
00D263  2               LAB_21D7
00D263  2  B1 71        	LDA	(ut1_pl),Y		; get string length
00D265  2  F0 2B        	BEQ	LAB_2206		; if null, step pointer to next string and return
00D267  2               
00D267  2  C8           	INY				; else increment index
00D268  2  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte
00D26A  2  AA           	TAX				; copy to X
00D26B  2  C8           	INY				; increment index
00D26C  2  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte
00D26E  2  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
00D270  2  90 06        	BCC	LAB_21EC		; branch if less
00D272  2               
00D272  2  D0 1E        	BNE	LAB_2206		; if greater, step pointer to next string and return
00D274  2               
00D274  2               					; high bytes were = so compare low bytes
00D274  2  E4 81        	CPX	Sstorl		; compare bottom of string space low byte
00D276  2  B0 1A        	BCS	LAB_2206		; if >=, step pointer to next string and return
00D278  2               
00D278  2               					; string pointer is < string storage pointer (pos in mem)
00D278  2               LAB_21EC
00D278  2  C5 AB        	CMP	Histrh		; compare to highest string high byte
00D27A  2  90 17        	BCC	LAB_2207		; if <, step pointer to next string and return
00D27C  2               
00D27C  2  D0 04        	BNE	LAB_21F6		; if > update pointers, step to next and return
00D27E  2               
00D27E  2               					; high bytes were = so compare low bytes
00D27E  2  E4 AA        	CPX	Histrl		; compare to highest string low byte
00D280  2  90 11        	BCC	LAB_2207		; if <, step pointer to next string and return
00D282  2               
00D282  2               					; string is in string memory space
00D282  2               LAB_21F6
00D282  2  86 AA        	STX	Histrl		; save as new highest string low byte
00D284  2  85 AB        	STA	Histrh		; save as new highest string high byte
00D286  2  A5 71        	LDA	ut1_pl		; get start of vars(descriptors) low byte
00D288  2  A6 72        	LDX	ut1_ph		; get start of vars(descriptors) high byte
00D28A  2  85 9C        	STA	garb_l		; save as working pointer low byte
00D28C  2  86 9D        	STX	garb_h		; save as working pointer high byte
00D28E  2  88           	DEY				; decrement index DIFFERS
00D28F  2  88           	DEY				; decrement index (should point to descriptor start)
00D290  2  84 A2        	STY	g_indx		; save index pointer
00D292  2               
00D292  2               					; step pointer to next string
00D292  2               LAB_2206
00D292  2  18           	CLC				; clear carry for add
00D293  2               LAB_2207
00D293  2  A5 A0        	LDA	g_step		; get step size
00D295  2               LAB_2208
00D295  2  65 71        	ADC	ut1_pl		; add pointer low byte
00D297  2  85 71        	STA	ut1_pl		; save pointer low byte
00D299  2  90 02        	BCC	LAB_2211		; branch if no overflow
00D29B  2               
00D29B  2  E6 72        	INC	ut1_ph		; else increment high byte
00D29D  2               LAB_2211
00D29D  2  A6 72        	LDX	ut1_ph		; get pointer high byte
00D29F  2  A0 00        	LDY	#$00			; clear Y
00D2A1  2  60           	RTS
00D2A2  2               
00D2A2  2               ; search complete, now either exit or set-up and move string
00D2A2  2               
00D2A2  2               LAB_2216
00D2A2  2  C6 A0        	DEC	g_step		; decrement step size (now $03 for descriptor stack)
00D2A4  2  A6 9D        	LDX	garb_h		; get string to move high byte
00D2A6  2  F0 F5        	BEQ	LAB_2211		; exit if nothing to move
00D2A8  2               
00D2A8  2  A4 A2        	LDY	g_indx		; get index byte back (points to descriptor)
00D2AA  2  18           	CLC				; clear carry for add
00D2AB  2  B1 9C        	LDA	(garb_l),Y		; get string length
00D2AD  2  65 AA        	ADC	Histrl		; add highest string low byte
00D2AF  2  85 A6        	STA	Obendl		; save old block end low pointer
00D2B1  2  A5 AB        	LDA	Histrh		; get highest string high byte
00D2B3  2  69 00        	ADC	#$00			; add any carry
00D2B5  2  85 A7        	STA	Obendh		; save old block end high byte
00D2B7  2  A5 81        	LDA	Sstorl		; get bottom of string space low byte
00D2B9  2  A6 82        	LDX	Sstorh		; get bottom of string space high byte
00D2BB  2  85 A4        	STA	Nbendl		; save new block end low byte
00D2BD  2  86 A5        	STX	Nbendh		; save new block end high byte
00D2BF  2  20 C8 C0     	JSR	LAB_11D6		; open up space in memory, don't set array end
00D2C2  2  A4 A2        	LDY	g_indx		; get index byte
00D2C4  2  C8           	INY				; point to descriptor low byte
00D2C5  2  A5 A4        	LDA	Nbendl		; get string pointer low byte
00D2C7  2  91 9C        	STA	(garb_l),Y		; save new string pointer low byte
00D2C9  2  AA           	TAX				; copy string pointer low byte
00D2CA  2  E6 A5        	INC	Nbendh		; correct high byte (move sets high byte -1)
00D2CC  2  A5 A5        	LDA	Nbendh		; get new string pointer high byte
00D2CE  2  C8           	INY				; point to descriptor high byte
00D2CF  2  91 9C        	STA	(garb_l),Y		; save new string pointer high byte
00D2D1  2  4C E3 D1     	JMP	LAB_214B		; re-run routine from last ending
00D2D4  2               					; (but don't collect this string)
00D2D4  2               
00D2D4  2               ; concatenate
00D2D4  2               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
00D2D4  2               
00D2D4  2               LAB_224D
00D2D4  2  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
00D2D6  2  48           	PHA				; put on stack
00D2D7  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00D2D9  2  48           	PHA				; put on stack
00D2DA  2  20 CD CB     	JSR	LAB_GVAL		; get value from line
00D2DD  2  20 D2 CA     	JSR	LAB_CTST		; check if source is string, else do type mismatch
00D2E0  2  68           	PLA				; get descriptor pointer low byte back
00D2E1  2  85 B8        	STA	ssptr_l		; set pointer low byte
00D2E3  2  68           	PLA				; get descriptor pointer high byte back
00D2E4  2  85 B9        	STA	ssptr_h		; set pointer high byte
00D2E6  2  A0 00        	LDY	#$00			; clear index
00D2E8  2  B1 B8        	LDA	(ssptr_l),Y		; get length_1 from descriptor
00D2EA  2  18           	CLC				; clear carry for add
00D2EB  2  71 AE        	ADC	(des_pl),Y		; add length_2
00D2ED  2  90 05        	BCC	LAB_226D		; branch if no overflow
00D2EF  2               
00D2EF  2  A2 1A        	LDX	#$1A			; else set error code $1A ("String too long" error)
00D2F1  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00D2F4  2               
00D2F4  2               LAB_226D
00D2F4  2  20 32 D1     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
00D2F7  2               					; long
00D2F7  2  20 11 D3     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
00D2FA  2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
00D2FC  2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
00D2FE  2  20 42 D3     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
00D301  2               					; returns with A = length, ut1_pl = pointer low byte,
00D301  2               					; ut1_ph = pointer high byte
00D301  2  20 23 D3     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
00D304  2  A5 B8        	LDA	ssptr_l		;.set descriptor pointer low byte
00D306  2  A4 B9        	LDY	ssptr_h		;.set descriptor pointer high byte
00D308  2  20 42 D3     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
00D30B  2               					; returns with A = length, X=ut1_pl=pointer low byte,
00D30B  2               					; Y=ut1_ph=pointer high byte
00D30B  2  20 85 D1     	JSR	LAB_RTST		; check for space on descriptor stack then put string
00D30E  2               					; address and length on descriptor stack and update stack
00D30E  2               					; pointers
00D30E  2  4C F8 CA     	JMP	LAB_1ADB		;.continue evaluation
00D311  2               
00D311  2               ; copy string from descriptor (sdescr) to (Sutill)
00D311  2               
00D311  2               LAB_228A
00D311  2  A0 00        	LDY	#$00			; clear index
00D313  2  B1 B8        	LDA	(sdescr),Y		; get string length
00D315  2  48           	PHA				; save on stack
00D316  2  C8           	INY				; increment index
00D317  2  B1 B8        	LDA	(sdescr),Y		; get source string pointer low byte
00D319  2  AA           	TAX				; copy to X
00D31A  2  C8           	INY				; increment index
00D31B  2  B1 B8        	LDA	(sdescr),Y		; get source string pointer high byte
00D31D  2  A8           	TAY				; copy to Y
00D31E  2  68           	PLA				; get length back
00D31F  2               
00D31F  2               ; store string A bytes long from YX to (Sutill)
00D31F  2               
00D31F  2               LAB_2298
00D31F  2  86 71        	STX	ut1_pl		; save source string pointer low byte
00D321  2  84 72        	STY	ut1_ph		; save source string pointer high byte
00D323  2               
00D323  2               ; store string A bytes long from (ut1_pl) to (Sutill)
00D323  2               
00D323  2               LAB_229C
00D323  2  AA           	TAX				; copy length to index (don't count with Y)
00D324  2  F0 14        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
00D326  2               
00D326  2  A0 00        	LDY	#$00			; zero pointer (copy forward)
00D328  2               LAB_22A0
00D328  2  B1 71        	LDA	(ut1_pl),Y		; get source byte
00D32A  2  91 83        	STA	(Sutill),Y		; save destination byte
00D32C  2               
00D32C  2  C8           	INY				; increment index
00D32D  2  CA           	DEX				; decrement counter
00D32E  2  D0 F8        	BNE	LAB_22A0		; loop while <> 0
00D330  2               
00D330  2  98           	TYA				; restore length from Y
00D331  2               LAB_22A9
00D331  2  18           	CLC				; clear carry for add
00D332  2  65 83        	ADC	Sutill		; add string utility ptr low byte
00D334  2  85 83        	STA	Sutill		; save string utility ptr low byte
00D336  2  90 02        	BCC	LAB_22B2		; branch if no carry
00D338  2               
00D338  2  E6 84        	INC	Sutilh		; else increment string utility ptr high byte
00D33A  2               LAB_22B2
00D33A  2  60           	RTS
00D33B  2               
00D33B  2               ; evaluate string
00D33B  2               
00D33B  2               LAB_EVST
00D33B  2  20 D2 CA     	JSR	LAB_CTST		; check if source is string, else do type mismatch
00D33E  2               
00D33E  2               ; pop string off descriptor stack, or from top of string space
00D33E  2               ; returns with A = length, X=pointer low byte, Y=pointer high byte
00D33E  2               
00D33E  2               LAB_22B6
00D33E  2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
00D340  2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
00D342  2               
00D342  2               ; pop (YA) descriptor off stack or from top of string space
00D342  2               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
00D342  2               
00D342  2               LAB_22BA
00D342  2  85 71        	STA	ut1_pl		; save descriptor pointer low byte
00D344  2  84 72        	STY	ut1_ph		; save descriptor pointer high byte
00D346  2  20 73 D3     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
00D349  2  08           	PHP				; save status flags
00D34A  2  A0 00        	LDY	#$00			; clear index
00D34C  2  B1 71        	LDA	(ut1_pl),Y		; get length from string descriptor
00D34E  2  48           	PHA				; put on stack
00D34F  2  C8           	INY				; increment index
00D350  2  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
00D352  2  AA           	TAX				; copy to X
00D353  2  C8           	INY				; increment index
00D354  2  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
00D356  2  A8           	TAY				; copy to Y
00D357  2  68           	PLA				; get string length back
00D358  2  28           	PLP				; restore status
00D359  2  D0 13        	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
00D35B  2               
00D35B  2  C4 82        	CPY	Sstorh		; compare bottom of string space high byte
00D35D  2  D0 0F        	BNE	LAB_22E6		; branch if <>
00D35F  2               
00D35F  2  E4 81        	CPX	Sstorl		; else compare bottom of string space low byte
00D361  2  D0 0B        	BNE	LAB_22E6		; branch if <>
00D363  2               
00D363  2  48           	PHA				; save string length
00D364  2  18           	CLC				; clear carry for add
00D365  2  65 81        	ADC	Sstorl		; add bottom of string space low byte
00D367  2  85 81        	STA	Sstorl		; save bottom of string space low byte
00D369  2  90 02        	BCC	LAB_22E5		; skip increment if no overflow
00D36B  2               
00D36B  2  E6 82        	INC	Sstorh		; increment bottom of string space high byte
00D36D  2               LAB_22E5
00D36D  2  68           	PLA				; restore string length
00D36E  2               LAB_22E6
00D36E  2  86 71        	STX	ut1_pl		; save string pointer low byte
00D370  2  84 72        	STY	ut1_ph		; save string pointer high byte
00D372  2  60           	RTS
00D373  2               
00D373  2               ; clean descriptor stack, YA = pointer
00D373  2               ; checks if AY is on the descriptor stack, if so does a stack discard
00D373  2               
00D373  2               LAB_22EB
00D373  2  C4 67        	CPY	last_sh		; compare pointer high byte
00D375  2  D0 0C        	BNE	LAB_22FB		; exit if <>
00D377  2               
00D377  2  C5 66        	CMP	last_sl		; compare pointer low byte
00D379  2  D0 08        	BNE	LAB_22FB		; exit if <>
00D37B  2               
00D37B  2  85 65        	STA	next_s		; save descriptor stack pointer
00D37D  2  E9 03        	SBC	#$03			; -3
00D37F  2  85 66        	STA	last_sl		; save low byte -3
00D381  2  A0 00        	LDY	#$00			; clear high byte
00D383  2               LAB_22FB
00D383  2  60           	RTS
00D384  2               
00D384  2               ; perform CHR$()
00D384  2               
00D384  2               LAB_CHRS
00D384  2  20 8F D4     	JSR	LAB_EVBY		; evaluate byte expression, result in X
00D387  2  8A           	TXA				; copy to A
00D388  2  48           	PHA				; save character
00D389  2  A9 01        	LDA	#$01			; string is single byte
00D38B  2  20 3A D1     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
00D38E  2               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00D38E  2  68           	PLA				; get character back
00D38F  2  A0 00        	LDY	#$00			; clear index
00D391  2  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
00D393  2  4C 85 D1     	JMP	LAB_RTST		; check for space on descriptor stack then put string
00D396  2               					; address and length on descriptor stack and update stack
00D396  2               					; pointers
00D396  2               
00D396  2               ; perform LEFT$()
00D396  2               
00D396  2               LAB_LEFT
00D396  2  48           	PHA				; push byte parameter
00D397  2  20 F7 D3     	JSR	LAB_236F		; pull string data and byte parameter from stack
00D39A  2               					; return pointer in des_2l/h, byte in A (and X), Y=0
00D39A  2  D1 9E        	CMP	(des_2l),Y		; compare byte parameter with string length
00D39C  2  98           	TYA				; clear A
00D39D  2  F0 09        	BEQ	LAB_2316		; go do string copy (branch always)
00D39F  2               
00D39F  2               ; perform RIGHT$()
00D39F  2               
00D39F  2               LAB_RIGHT
00D39F  2  48           	PHA				; push byte parameter
00D3A0  2  20 F7 D3     	JSR	LAB_236F		; pull string data and byte parameter from stack
00D3A3  2               					; return pointer in des_2l/h, byte in A (and X), Y=0
00D3A3  2  18           	CLC				; clear carry for add-1
00D3A4  2  F1 9E        	SBC	(des_2l),Y		; subtract string length
00D3A6  2  49 FF        	EOR	#$FF			; invert it (A=LEN(expression$)-l)
00D3A8  2               
00D3A8  2               LAB_2316
00D3A8  2  90 04        	BCC	LAB_231C		; branch if string length > byte parameter
00D3AA  2               
00D3AA  2  B1 9E        	LDA	(des_2l),Y		; else make parameter = length
00D3AC  2  AA           	TAX				; copy to byte parameter copy
00D3AD  2  98           	TYA				; clear string start offset
00D3AE  2               LAB_231C
00D3AE  2  48           	PHA				; save string start offset
00D3AF  2               LAB_231D
00D3AF  2  8A           	TXA				; copy byte parameter (or string length if <)
00D3B0  2               LAB_231E
00D3B0  2  48           	PHA				; save string length
00D3B1  2  20 3A D1     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
00D3B4  2               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00D3B4  2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
00D3B6  2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
00D3B8  2  20 42 D3     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
00D3BB  2               					; returns with A = length, X=ut1_pl=pointer low byte,
00D3BB  2               					; Y=ut1_ph=pointer high byte
00D3BB  2  68           	PLA				; get string length back
00D3BC  2  A8           	TAY				; copy length to Y
00D3BD  2  68           	PLA				; get string start offset back
00D3BE  2  18           	CLC				; clear carry for add
00D3BF  2  65 71        	ADC	ut1_pl		; add start offset to string start pointer low byte
00D3C1  2  85 71        	STA	ut1_pl		; save string start pointer low byte
00D3C3  2  90 02        	BCC	LAB_2335		; branch if no overflow
00D3C5  2               
00D3C5  2  E6 72        	INC	ut1_ph		; else increment string start pointer high byte
00D3C7  2               LAB_2335
00D3C7  2  98           	TYA				; copy length to A
00D3C8  2  20 23 D3     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
00D3CB  2  4C 85 D1     	JMP	LAB_RTST		; check for space on descriptor stack then put string
00D3CE  2               					; address and length on descriptor stack and update stack
00D3CE  2               					; pointers
00D3CE  2               
00D3CE  2               ; perform MID$()
00D3CE  2               
00D3CE  2               LAB_MIDS
00D3CE  2  48           	PHA				; push byte parameter
00D3CF  2  A9 FF        	LDA	#$FF			; set default length = 255
00D3D1  2  85 AF        	STA	mids_l		; save default length
00D3D3  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00D3D6  2  C9 29        	CMP	#')'			; compare with ")"
00D3D8  2  F0 06        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
00D3DA  2               
00D3DA  2  20 FE CB     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
00D3DD  2  20 8C D4     	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
00D3E0  2               LAB_2358
00D3E0  2  20 F7 D3     	JSR	LAB_236F		; pull string data and byte parameter from stack
00D3E3  2               					; return pointer in des_2l/h, byte in A (and X), Y=0
00D3E3  2  CA           	DEX				; decrement start index
00D3E4  2  8A           	TXA				; copy to A
00D3E5  2  48           	PHA				; save string start offset
00D3E6  2  18           	CLC				; clear carry for sub-1
00D3E7  2  A2 00        	LDX	#$00			; clear output string length
00D3E9  2  F1 9E        	SBC	(des_2l),Y		; subtract string length
00D3EB  2  B0 C2        	BCS	LAB_231D		; if start>string length go do null string
00D3ED  2               
00D3ED  2  49 FF        	EOR	#$FF			; complement -length
00D3EF  2  C5 AF        	CMP	mids_l		; compare byte parameter
00D3F1  2  90 BD        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
00D3F3  2               
00D3F3  2  A5 AF        	LDA	mids_l		; get length byte
00D3F5  2  B0 B9        	BCS	LAB_231E		; go do string copy (branch always)
00D3F7  2               
00D3F7  2               ; pull string data and byte parameter from stack
00D3F7  2               ; return pointer in des_2l/h, byte in A (and X), Y=0
00D3F7  2               
00D3F7  2               LAB_236F
00D3F7  2  20 EF CB     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
00D3FA  2  68           	PLA				; pull return address low byte (return address)
00D3FB  2  85 A2        	STA	Fnxjpl		; save functions jump vector low byte
00D3FD  2  68           	PLA				; pull return address high byte (return address)
00D3FE  2  85 A3        	STA	Fnxjph		; save functions jump vector high byte
00D400  2  68           	PLA				; pull byte parameter
00D401  2  AA           	TAX				; copy byte parameter to X
00D402  2  68           	PLA				; pull string pointer low byte
00D403  2  85 9E        	STA	des_2l		; save it
00D405  2  68           	PLA				; pull string pointer high byte
00D406  2  85 9F        	STA	des_2h		; save it
00D408  2  A0 00        	LDY	#$00			; clear index
00D40A  2  8A           	TXA				; copy byte parameter
00D40B  2  F0 79        	BEQ	LAB_23A8		; if null do function call error then warm start
00D40D  2               
00D40D  2  E6 A2        	INC	Fnxjpl		; increment function jump vector low byte
00D40F  2               					; (JSR pushes return addr-1. this is all very nice
00D40F  2               					; but will go tits up if either call is on a page
00D40F  2               					; boundary!)
00D40F  2  6C A2 00     	JMP	(Fnxjpl)		; in effect, RTS
00D412  2               
00D412  2               ; perform LCASE$()
00D412  2               
00D412  2               LAB_LCASE
00D412  2  20 3B D3     	JSR	LAB_EVST		; evaluate string
00D415  2  85 AC        	STA	str_ln		; set string length
00D417  2  A8           	TAY				; copy length to Y
00D418  2  F0 38        	BEQ	NoString		; branch if null string
00D41A  2               
00D41A  2  20 3A D1     	JSR	LAB_MSSP		; make string space A bytes long A=length,
00D41D  2               					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D41D  2  86 AD        	STX	str_pl		; save string pointer low byte
00D41F  2  84 AE        	STY	str_ph		; save string pointer high byte
00D421  2  A8           	TAY				; get string length back
00D422  2               
00D422  2               LC_loop
00D422  2  88           	DEY				; decrement index
00D423  2  B1 71        	LDA	(ut1_pl),Y		; get byte from string
00D425  2  20 22 CE     	JSR	LAB_1D82		; is character "A" to "Z"
00D428  2  90 02        	BCC	NoUcase		; branch if not upper case alpha
00D42A  2               
00D42A  2  09 20        	ORA	#$20			; convert upper to lower case
00D42C  2               NoUcase
00D42C  2  91 83        	STA	(Sutill),Y		; save byte back to string
00D42E  2  98           	TYA				; test index
00D42F  2  D0 F1        	BNE	LC_loop		; loop if not all done
00D431  2               
00D431  2  F0 1F        	BEQ	NoString		; tidy up and exit, branch always
00D433  2               
00D433  2               ; perform UCASE$()
00D433  2               
00D433  2               LAB_UCASE
00D433  2  20 3B D3     	JSR	LAB_EVST		; evaluate string
00D436  2  85 AC        	STA	str_ln		; set string length
00D438  2  A8           	TAY				; copy length to Y
00D439  2  F0 17        	BEQ	NoString		; branch if null string
00D43B  2               
00D43B  2  20 3A D1     	JSR	LAB_MSSP		; make string space A bytes long A=length,
00D43E  2               					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D43E  2  86 AD        	STX	str_pl		; save string pointer low byte
00D440  2  84 AE        	STY	str_ph		; save string pointer high byte
00D442  2  A8           	TAY				; get string length back
00D443  2               
00D443  2               UC_loop
00D443  2  88           	DEY				; decrement index
00D444  2  B1 71        	LDA	(ut1_pl),Y		; get byte from string
00D446  2  20 1E CE     	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
00D449  2  90 02        	BCC	NoLcase		; branch if not alpha
00D44B  2               
00D44B  2  29 DF        	AND	#$DF			; convert lower to upper case
00D44D  2               NoLcase
00D44D  2  91 83        	STA	(Sutill),Y		; save byte back to string
00D44F  2  98           	TYA				; test index
00D450  2  D0 F1        	BNE	UC_loop		; loop if not all done
00D452  2               
00D452  2               NoString
00D452  2  4C 85 D1     	JMP	LAB_RTST		; check for space on descriptor stack then put string
00D455  2               					; address and length on descriptor stack and update stack
00D455  2               					; pointers
00D455  2               
00D455  2               ; perform SADD()
00D455  2               
00D455  2               LAB_SADD
00D455  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00D458  2  20 AA CD     	JSR	LAB_GVAR		; get var address
00D45B  2               
00D45B  2  20 EF CB     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
00D45E  2  20 D2 CA     	JSR	LAB_CTST		; check if source is string, else do type mismatch
00D461  2               
00D461  2  A0 02        	LDY	#$02			; index to string pointer high byte
00D463  2  B1 95        	LDA	(Cvaral),Y		; get string pointer high byte
00D465  2  AA           	TAX				; copy string pointer high byte to X
00D466  2  88           	DEY				; index to string pointer low byte
00D467  2  B1 95        	LDA	(Cvaral),Y		; get string pointer low byte
00D469  2  A8           	TAY				; copy string pointer low byte to Y
00D46A  2  8A           	TXA				; copy string pointer high byte to A
00D46B  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00D46E  2               
00D46E  2               ; perform LEN()
00D46E  2               
00D46E  2               LAB_LENS
00D46E  2  20 74 D4     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
00D471  2  4C 66 D0     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
00D474  2               
00D474  2               ; evaluate string, get length in Y
00D474  2               
00D474  2               LAB_ESGL
00D474  2  20 3B D3     	JSR	LAB_EVST		; evaluate string
00D477  2  A8           	TAY				; copy length to Y
00D478  2  60           	RTS
00D479  2               
00D479  2               ; perform ASC()
00D479  2               
00D479  2               LAB_ASC
00D479  2  20 74 D4     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
00D47C  2  F0 08        	BEQ	LAB_23A8		; if null do function call error then warm start
00D47E  2               
00D47E  2  A0 00        	LDY	#$00			; set index to first character
00D480  2  B1 71        	LDA	(ut1_pl),Y		; get byte
00D482  2  A8           	TAY				; copy to Y
00D483  2  4C 66 D0     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
00D486  2               
00D486  2               ; do function call error then warm start
00D486  2               
00D486  2               LAB_23A8
00D486  2  4C 29 CF     	JMP	LAB_FCER		; do function call error then warm start
00D489  2               
00D489  2               ; scan and get byte parameter
00D489  2               
00D489  2               LAB_SGBY
00D489  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00D48C  2               
00D48C  2               ; get byte parameter
00D48C  2               
00D48C  2               LAB_GTBY
00D48C  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00D48F  2               					; else do type mismatch
00D48F  2               
00D48F  2               ; evaluate byte expression, result in X
00D48F  2               
00D48F  2               LAB_EVBY
00D48F  2  20 A2 CE     	JSR	LAB_EVPI		; evaluate integer expression (no check)
00D492  2               
00D492  2  A4 AE        	LDY	FAC1_2		; get FAC1 mantissa2
00D494  2  D0 F0        	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
00D496  2               
00D496  2  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
00D498  2  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
00D49B  2               
00D49B  2               ; perform VAL()
00D49B  2               
00D49B  2               LAB_VAL
00D49B  2  20 74 D4     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
00D49E  2  D0 03        	BNE	LAB_23C5		; branch if not null string
00D4A0  2               
00D4A0  2               					; string was null so set result = $00
00D4A0  2  4C 50 D6     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
00D4A3  2               
00D4A3  2               LAB_23C5
00D4A3  2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
00D4A5  2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00D4A7  2  86 BA        	STX	Btmpl			; save BASIC execute pointer low byte
00D4A9  2  84 BB        	STY	Btmph			; save BASIC execute pointer high byte
00D4AB  2  A6 71        	LDX	ut1_pl		; get string pointer low byte
00D4AD  2  86 C3        	STX	Bpntrl		; save as BASIC execute pointer low byte
00D4AF  2  18           	CLC				; clear carry
00D4B0  2  65 71        	ADC	ut1_pl		; add string length
00D4B2  2  85 73        	STA	ut2_pl		; save string end low byte
00D4B4  2  A5 72        	LDA	ut1_ph		; get string pointer high byte
00D4B6  2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
00D4B8  2  69 00        	ADC	#$00			; add carry to high byte
00D4BA  2  85 74        	STA	ut2_ph		; save string end high byte
00D4BC  2  A0 00        	LDY	#$00			; set index to $00
00D4BE  2  B1 73        	LDA	(ut2_pl),Y		; get string end +1 byte
00D4C0  2  48           	PHA				; push it
00D4C1  2  98           	TYA				; clear A
00D4C2  2  91 73        	STA	(ut2_pl),Y		; terminate string with $00
00D4C4  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00D4C7  2  20 A6 D9     	JSR	LAB_2887		; get FAC1 from string
00D4CA  2  68           	PLA				; restore string end +1 byte
00D4CB  2  A0 00        	LDY	#$00			; set index to zero
00D4CD  2  91 73        	STA	(ut2_pl),Y		; put string end byte back
00D4CF  2               
00D4CF  2               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
00D4CF  2               
00D4CF  2               LAB_23F3
00D4CF  2  A6 BA        	LDX	Btmpl			; get BASIC execute pointer low byte back
00D4D1  2  A4 BB        	LDY	Btmph			; get BASIC execute pointer high byte back
00D4D3  2  86 C3        	STX	Bpntrl		; save BASIC execute pointer low byte
00D4D5  2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
00D4D7  2  60           	RTS
00D4D8  2               
00D4D8  2               ; get two parameters for POKE or WAIT
00D4D8  2               
00D4D8  2               LAB_GADB
00D4D8  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00D4DB  2               					; else do type mismatch
00D4DB  2  20 F1 D4     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
00D4DE  2               
00D4DE  2               ; scan for "," and get byte, else do Syntax error then warm start
00D4DE  2               
00D4DE  2               LAB_SCGB
00D4DE  2  20 FE CB     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
00D4E1  2  A5 12        	LDA	Itemph		; save temporary integer high byte
00D4E3  2  48           	PHA				; on stack
00D4E4  2  A5 11        	LDA	Itempl		; save temporary integer low byte
00D4E6  2  48           	PHA				; on stack
00D4E7  2  20 8C D4     	JSR	LAB_GTBY		; get byte parameter
00D4EA  2  68           	PLA				; pull low byte
00D4EB  2  85 11        	STA	Itempl		; restore temporary integer low byte
00D4ED  2  68           	PLA				; pull high byte
00D4EE  2  85 12        	STA	Itemph		; restore temporary integer high byte
00D4F0  2  60           	RTS
00D4F1  2               
00D4F1  2               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
00D4F1  2               ; -ve and converts it into a right truncated integer in Itempl and Itemph
00D4F1  2               
00D4F1  2               ; save unsigned 16 bit integer part of FAC1 in temporary integer
00D4F1  2               
00D4F1  2               LAB_F2FX
00D4F1  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00D4F3  2  C9 98        	CMP	#$98			; compare with exponent = 2^24
00D4F5  2  B0 8F        	BCS	LAB_23A8		; if >= do function call error then warm start
00D4F7  2               
00D4F7  2               LAB_F2FU
00D4F7  2  20 50 D9     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
00D4FA  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00D4FC  2  A4 AF        	LDY	FAC1_3		; get FAC1 mantissa3
00D4FE  2  84 11        	STY	Itempl		; save temporary integer low byte
00D500  2  85 12        	STA	Itemph		; save temporary integer high byte
00D502  2  60           	RTS
00D503  2               
00D503  2               ; perform PEEK()
00D503  2               
00D503  2               LAB_PEEK
00D503  2  20 F1 D4     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
00D506  2  A2 00        	LDX	#$00			; clear index
00D508  2  A1 11        	LDA	(Itempl,X)		; get byte via temporary integer (addr)
00D50A  2  A8           	TAY				; copy byte to Y
00D50B  2  4C 66 D0     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
00D50E  2               
00D50E  2               ; perform POKE
00D50E  2               
00D50E  2               LAB_POKE
00D50E  2  20 D8 D4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
00D511  2  8A           	TXA				; copy byte argument to A
00D512  2  A2 00        	LDX	#$00			; clear index
00D514  2  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
00D516  2  60           	RTS
00D517  2               
00D517  2               ; perform DEEK()
00D517  2               
00D517  2               LAB_DEEK
00D517  2  20 F1 D4     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
00D51A  2  A2 00        	LDX	#$00			; clear index
00D51C  2  A1 11        	LDA	(Itempl,X)		; PEEK low byte
00D51E  2  A8           	TAY				; copy to Y
00D51F  2  E6 11        	INC	Itempl		; increment pointer low byte
00D521  2  D0 02        	BNE	Deekh			; skip high increment if no rollover
00D523  2               
00D523  2  E6 12        	INC	Itemph		; increment pointer high byte
00D525  2               Deekh
00D525  2  A1 11        	LDA	(Itempl,X)		; PEEK high byte
00D527  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00D52A  2               
00D52A  2               ; perform DOKE
00D52A  2               
00D52A  2               LAB_DOKE
00D52A  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00D52D  2               					; else do type mismatch
00D52D  2  20 F1 D4     	JSR	LAB_F2FX		; convert floating-to-fixed
00D530  2               
00D530  2  84 97        	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
00D532  2  85 98        	STA	Frnxth		; save pointer high byte
00D534  2               
00D534  2  20 FE CB     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
00D537  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00D53A  2               					; else do type mismatch
00D53A  2  20 F1 D4     	JSR	LAB_F2FX		; convert floating-to-fixed
00D53D  2               
00D53D  2  98           	TYA				; copy value low byte (float to fixed returns word in AY)
00D53E  2  A2 00        	LDX	#$00			; clear index
00D540  2  81 97        	STA	(Frnxtl,X)		; POKE low byte
00D542  2  E6 97        	INC	Frnxtl		; increment pointer low byte
00D544  2  D0 02        	BNE	Dokeh			; skip high increment if no rollover
00D546  2               
00D546  2  E6 98        	INC	Frnxth		; increment pointer high byte
00D548  2               Dokeh
00D548  2  A5 12        	LDA	Itemph		; get value high byte
00D54A  2  81 97        	STA	(Frnxtl,X)		; POKE high byte
00D54C  2  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
00D54F  2               
00D54F  2               ; perform SWAP
00D54F  2               
00D54F  2               LAB_SWAP
00D54F  2  20 AA CD     	JSR	LAB_GVAR		; get var1 address
00D552  2  85 97        	STA	Lvarpl		; save var1 address low byte
00D554  2  84 98        	STY	Lvarph		; save var1 address high byte
00D556  2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
00D558  2  48           	PHA				; save data type flag
00D559  2               
00D559  2  20 FE CB     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
00D55C  2  20 AA CD     	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
00D55F  2  68           	PLA				; pull var1 data type flag
00D560  2  45 5F        	EOR	Dtypef		; compare with var2 data type
00D562  2  10 10        	BPL	SwapErr		; exit if not both the same type
00D564  2               
00D564  2  A0 03        	LDY	#$03			; four bytes to swap (either value or descriptor+1)
00D566  2               SwapLp
00D566  2  B1 97        	LDA	(Lvarpl),Y		; get byte from var1
00D568  2  AA           	TAX				; save var1 byte
00D569  2  B1 95        	LDA	(Cvaral),Y		; get byte from var2
00D56B  2  91 97        	STA	(Lvarpl),Y		; save byte to var1
00D56D  2  8A           	TXA				; restore var1 byte
00D56E  2  91 95        	STA	(Cvaral),Y		; save byte to var2
00D570  2  88           	DEY				; decrement index
00D571  2  10 F3        	BPL	SwapLp		; loop until done
00D573  2               
00D573  2  60           	RTS
00D574  2               
00D574  2               SwapErr
00D574  2  4C DC CA     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
00D577  2               
00D577  2               ; perform CALL
00D577  2               
00D577  2               LAB_CALL
00D577  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00D57A  2               					; else do type mismatch
00D57A  2  20 F1 D4     	JSR	LAB_F2FX		; convert floating-to-fixed
00D57D  2  A9 D5        	LDA	#>CallExit		; set return address high byte
00D57F  2  48           	PHA				; put on stack
00D580  2  A9 85        	LDA	#<CallExit-1	; set return address low byte
00D582  2  48           	PHA				; put on stack
00D583  2  6C 11 00     	JMP	(Itempl)		; do indirect jump to user routine
00D586  2               
00D586  2               ; if the called routine exits correctly then it will return to here. this will then get
00D586  2               ; the next byte for the interpreter and return
00D586  2               
00D586  2               CallExit
00D586  2  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
00D589  2               
00D589  2               ; perform WAIT
00D589  2               
00D589  2               LAB_WAIT
00D589  2  20 D8 D4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
00D58C  2  86 97        	STX	Frnxtl		; save byte
00D58E  2  A2 00        	LDX	#$00			; clear mask
00D590  2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00D593  2  F0 03        	BEQ	LAB_2441		; skip if no third argument
00D595  2               
00D595  2  20 DE D4     	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
00D598  2               LAB_2441
00D598  2  86 98        	STX	Frnxth		; save EOR argument
00D59A  2               LAB_2445
00D59A  2  B1 11        	LDA	(Itempl),Y		; get byte via temporary integer (addr)
00D59C  2  45 98        	EOR	Frnxth		; EOR with second argument (mask)
00D59E  2  25 97        	AND	Frnxtl		; AND with first argument (byte)
00D5A0  2  F0 F8        	BEQ	LAB_2445		; loop if result is zero
00D5A2  2               
00D5A2  2               LAB_244D
00D5A2  2  60           	RTS
00D5A3  2               
00D5A3  2               ; perform subtraction, FAC1 from (AY)
00D5A3  2               
00D5A3  2               LAB_2455
00D5A3  2  20 8B D7     	JSR	LAB_264D		; unpack memory (AY) into FAC2
00D5A6  2               
00D5A6  2               ; perform subtraction, FAC1 from FAC2
00D5A6  2               
00D5A6  2               LAB_SUBTRACT
00D5A6  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00D5A8  2  49 FF        	EOR	#$FF			; complement it
00D5AA  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00D5AC  2  45 B7        	EOR	FAC2_s		; EOR with FAC2 sign (b7)
00D5AE  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00D5B0  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00D5B2  2  4C C1 D5     	JMP	LAB_ADD		; go add FAC2 to FAC1
00D5B5  2               
00D5B5  2               ; perform addition
00D5B5  2               
00D5B5  2               LAB_2467
00D5B5  2  20 DA D6     	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
00D5B8  2  90 4D        	BCC	LAB_24A8		;.go subtract mantissas
00D5BA  2               
00D5BA  2               ; add 0.5 to FAC1
00D5BA  2               
00D5BA  2               LAB_244E
00D5BA  2  A9 E9        	LDA	#<LAB_2A96		; set 0.5 pointer low byte
00D5BC  2  A0 E1        	LDY	#>LAB_2A96		; set 0.5 pointer high byte
00D5BE  2               
00D5BE  2               ; add (AY) to FAC1
00D5BE  2               
00D5BE  2               LAB_246C
00D5BE  2  20 8B D7     	JSR	LAB_264D		; unpack memory (AY) into FAC2
00D5C1  2               
00D5C1  2               ; add FAC2 to FAC1
00D5C1  2               
00D5C1  2               LAB_ADD
00D5C1  2  D0 10        	BNE	LAB_2474		; branch if FAC1 was not zero
00D5C3  2               
00D5C3  2               ; copy FAC2 to FAC1
00D5C3  2               
00D5C3  2               LAB_279B
00D5C3  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
00D5C5  2               
00D5C5  2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
00D5C5  2               
00D5C5  2               LAB_279D
00D5C5  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00D5C7  2  A2 04        	LDX	#$04			; 4 bytes to copy
00D5C9  2               LAB_27A1
00D5C9  2  B5 B2        	LDA	FAC1_o,X		; get byte from FAC2,X
00D5CB  2  95 AB        	STA	FAC1_e-1,X		; save byte at FAC1,X
00D5CD  2  CA           	DEX				; decrement count
00D5CE  2  D0 F9        	BNE	LAB_27A1		; loop if not all done
00D5D0  2               
00D5D0  2  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
00D5D2  2  60           	RTS
00D5D3  2               
00D5D3  2               					; FAC1 is non zero
00D5D3  2               LAB_2474
00D5D3  2  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
00D5D5  2  86 A3        	STX	FAC2_r		; save as FAC2 rounding byte
00D5D7  2  A2 B3        	LDX	#FAC2_e		; set index to FAC2 exponent addr
00D5D9  2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
00D5DB  2               LAB_247C
00D5DB  2  A8           	TAY				; copy exponent
00D5DC  2  F0 C4        	BEQ	LAB_244D		; exit if zero
00D5DE  2               
00D5DE  2  38           	SEC				; set carry for subtract
00D5DF  2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
00D5E1  2  F0 24        	BEQ	LAB_24A8		; branch if = (go add mantissa)
00D5E3  2               
00D5E3  2  90 12        	BCC	LAB_2498		; branch if <
00D5E5  2               
00D5E5  2               					; FAC2>FAC1
00D5E5  2  84 AC        	STY	FAC1_e		; save FAC1 exponent
00D5E7  2  A4 B7        	LDY	FAC2_s		; get FAC2 sign (b7)
00D5E9  2  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
00D5EB  2  49 FF        	EOR	#$FF			; complement A
00D5ED  2  69 00        	ADC	#$00			; +1 (twos complement, carry is set)
00D5EF  2  A0 00        	LDY	#$00			; clear Y
00D5F1  2  84 A3        	STY	FAC2_r		; clear FAC2 rounding byte
00D5F3  2  A2 AC        	LDX	#FAC1_e		; set index to FAC1 exponent addr
00D5F5  2  D0 04        	BNE	LAB_249C		; branch always
00D5F7  2               
00D5F7  2               LAB_2498
00D5F7  2  A0 00        	LDY	#$00			; clear Y
00D5F9  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00D5FB  2               LAB_249C
00D5FB  2  C9 F9        	CMP	#$F9			; compare exponent diff with $F9
00D5FD  2  30 B6        	BMI	LAB_2467		; branch if range $79-$F8
00D5FF  2               
00D5FF  2  A8           	TAY				; copy exponent difference to Y
00D600  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00D602  2  56 01        	LSR	PLUS_1,X		; shift FAC? mantissa1
00D604  2  20 F1 D6     	JSR	LAB_2592		; shift FACX Y times right
00D607  2               
00D607  2               					; exponents are equal now do mantissa subtract
00D607  2               LAB_24A8
00D607  2  24 B8        	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
00D609  2  10 4C        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
00D60B  2               
00D60B  2  A0 AC        	LDY	#FAC1_e		; set index to FAC1 exponent addr
00D60D  2  E0 B3        	CPX	#FAC2_e		; compare X to FAC2 exponent addr
00D60F  2  F0 02        	BEQ	LAB_24B4		; branch if =
00D611  2               
00D611  2  A0 B3        	LDY	#FAC2_e		; else set index to FAC2 exponent addr
00D613  2               
00D613  2               					; subtract smaller from bigger (take sign of bigger)
00D613  2               LAB_24B4
00D613  2  38           	SEC				; set carry for subtract
00D614  2  49 FF        	EOR	#$FF			; ones complement A
00D616  2  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
00D618  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00D61A  2  B9 03 00     	LDA	PLUS_3,Y		; get FACY mantissa3
00D61D  2  F5 03        	SBC	PLUS_3,X		; subtract FACX mantissa3
00D61F  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00D621  2  B9 02 00     	LDA	PLUS_2,Y		; get FACY mantissa2
00D624  2  F5 02        	SBC	PLUS_2,X		; subtract FACX mantissa2
00D626  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00D628  2  B9 01 00     	LDA	PLUS_1,Y		; get FACY mantissa1
00D62B  2  F5 01        	SBC	PLUS_1,X		; subtract FACX mantissa1
00D62D  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00D62F  2               
00D62F  2               ; do ABS and normalise FAC1
00D62F  2               
00D62F  2               LAB_24D0
00D62F  2  B0 03        	BCS	LAB_24D5		; branch if number is +ve
00D631  2               
00D631  2  20 96 D6     	JSR	LAB_2537		; negate FAC1
00D634  2               
00D634  2               ; normalise FAC1
00D634  2               
00D634  2               LAB_24D5
00D634  2  A0 00        	LDY	#$00			; clear Y
00D636  2  98           	TYA				; clear A
00D637  2  18           	CLC				; clear carry for add
00D638  2               LAB_24D9
00D638  2  A6 AD        	LDX	FAC1_1		; get FAC1 mantissa1
00D63A  2  D0 3E        	BNE	LAB_251B		; if not zero normalise FAC1
00D63C  2               
00D63C  2  A6 AE        	LDX	FAC1_2		; get FAC1 mantissa2
00D63E  2  86 AD        	STX	FAC1_1		; save FAC1 mantissa1
00D640  2  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
00D642  2  86 AE        	STX	FAC1_2		; save FAC1 mantissa2
00D644  2  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
00D646  2  86 AF        	STX	FAC1_3		; save FAC1 mantissa3
00D648  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00D64A  2  69 08        	ADC	#$08			; add x to exponent offset
00D64C  2  C9 18        	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
00D64E  2  D0 E8        	BNE	LAB_24D9		; loop if not max
00D650  2               
00D650  2               ; clear FAC1 exponent and sign
00D650  2               
00D650  2               LAB_24F1
00D650  2  A9 00        	LDA	#$00			; clear A
00D652  2               LAB_24F3
00D652  2  85 AC        	STA	FAC1_e		; set FAC1 exponent
00D654  2               
00D654  2               ; save FAC1 sign
00D654  2               
00D654  2               LAB_24F5
00D654  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00D656  2  60           	RTS
00D657  2               
00D657  2               ; add FAC2 mantissa to FAC1 mantissa
00D657  2               
00D657  2               LAB_24F8
00D657  2  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
00D659  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00D65B  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00D65D  2  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
00D65F  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00D661  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00D663  2  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
00D665  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00D667  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00D669  2  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
00D66B  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00D66D  2  B0 1A        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
00D66F  2               
00D66F  2  60           	RTS				; else just exit
00D670  2               
00D670  2               LAB_2511
00D670  2  69 01        	ADC	#$01			; add 1 to exponent offset
00D672  2  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
00D674  2  26 AF        	ROL	FAC1_3		; shift FAC1 mantissa3
00D676  2  26 AE        	ROL	FAC1_2		; shift FAC1 mantissa2
00D678  2  26 AD        	ROL	FAC1_1		; shift FAC1 mantissa1
00D67A  2               
00D67A  2               ; normalise FAC1
00D67A  2               
00D67A  2               LAB_251B
00D67A  2  10 F4        	BPL	LAB_2511		; loop if not normalised
00D67C  2               
00D67C  2  38           	SEC				; set carry for subtract
00D67D  2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
00D67F  2  B0 CF        	BCS	LAB_24F1		; branch if underflow (set result = $0)
00D681  2               
00D681  2  49 FF        	EOR	#$FF			; complement exponent
00D683  2  69 01        	ADC	#$01			; +1 (twos complement)
00D685  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00D687  2               
00D687  2               ; test and normalise FAC1 for C=0/1
00D687  2               
00D687  2               LAB_2528
00D687  2  90 0C        	BCC	LAB_2536		; exit if no overflow
00D689  2               
00D689  2               ; normalise FAC1 for C=1
00D689  2               
00D689  2               LAB_252A
00D689  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
00D68B  2  F0 36        	BEQ	LAB_2564		; if zero do overflow error and warm start
00D68D  2               
00D68D  2  66 AD        	ROR	FAC1_1		; shift FAC1 mantissa1
00D68F  2  66 AE        	ROR	FAC1_2		; shift FAC1 mantissa2
00D691  2  66 AF        	ROR	FAC1_3		; shift FAC1 mantissa3
00D693  2  66 B9        	ROR	FAC1_r		; shift FAC1 rounding byte
00D695  2               LAB_2536
00D695  2  60           	RTS
00D696  2               
00D696  2               ; negate FAC1
00D696  2               
00D696  2               LAB_2537
00D696  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00D698  2  49 FF        	EOR	#$FF			; complement it
00D69A  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00D69C  2               
00D69C  2               ; twos complement FAC1 mantissa
00D69C  2               
00D69C  2               LAB_253D
00D69C  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00D69E  2  49 FF        	EOR	#$FF			; complement it
00D6A0  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00D6A2  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00D6A4  2  49 FF        	EOR	#$FF			; complement it
00D6A6  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00D6A8  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00D6AA  2  49 FF        	EOR	#$FF			; complement it
00D6AC  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00D6AE  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00D6B0  2  49 FF        	EOR	#$FF			; complement it
00D6B2  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00D6B4  2  E6 B9        	INC	FAC1_r		; increment FAC1 rounding byte
00D6B6  2  D0 0A        	BNE	LAB_2563		; exit if no overflow
00D6B8  2               
00D6B8  2               ; increment FAC1 mantissa
00D6B8  2               
00D6B8  2               LAB_2559
00D6B8  2  E6 AF        	INC	FAC1_3		; increment FAC1 mantissa3
00D6BA  2  D0 06        	BNE	LAB_2563		; finished if no rollover
00D6BC  2               
00D6BC  2  E6 AE        	INC	FAC1_2		; increment FAC1 mantissa2
00D6BE  2  D0 02        	BNE	LAB_2563		; finished if no rollover
00D6C0  2               
00D6C0  2  E6 AD        	INC	FAC1_1		; increment FAC1 mantissa1
00D6C2  2               LAB_2563
00D6C2  2  60           	RTS
00D6C3  2               
00D6C3  2               ; do overflow error (overflow exit)
00D6C3  2               
00D6C3  2               LAB_2564
00D6C3  2  A2 0A        	LDX	#$0A			; error code $0A ("Overflow" error)
00D6C5  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00D6C8  2               
00D6C8  2               ; shift FCAtemp << A+8 times
00D6C8  2               
00D6C8  2               LAB_2569
00D6C8  2  A2 74        	LDX	#FACt_1-1		; set offset to FACtemp
00D6CA  2               LAB_256B
00D6CA  2  B4 03        	LDY	PLUS_3,X		; get FACX mantissa3
00D6CC  2  84 B9        	STY	FAC1_r		; save as FAC1 rounding byte
00D6CE  2  B4 02        	LDY	PLUS_2,X		; get FACX mantissa2
00D6D0  2  94 03        	STY	PLUS_3,X		; save FACX mantissa3
00D6D2  2  B4 01        	LDY	PLUS_1,X		; get FACX mantissa1
00D6D4  2  94 02        	STY	PLUS_2,X		; save FACX mantissa2
00D6D6  2  A4 B2        	LDY	FAC1_o		; get FAC1 overflow byte
00D6D8  2  94 01        	STY	PLUS_1,X		; save FACX mantissa1
00D6DA  2               
00D6DA  2               ; shift FACX -A times right (> 8 shifts)
00D6DA  2               
00D6DA  2               LAB_257B
00D6DA  2  69 08        	ADC	#$08			; add 8 to shift count
00D6DC  2  30 EC        	BMI	LAB_256B		; go do 8 shift if still -ve
00D6DE  2               
00D6DE  2  F0 EA        	BEQ	LAB_256B		; go do 8 shift if zero
00D6E0  2               
00D6E0  2  E9 08        	SBC	#$08			; else subtract 8 again
00D6E2  2  A8           	TAY				; save count to Y
00D6E3  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00D6E5  2  B0 12        	BCS	LAB_259A		;.
00D6E7  2               
00D6E7  2               LAB_2588
00D6E7  2  16 01        	ASL	PLUS_1,X		; shift FACX mantissa1
00D6E9  2  90 02        	BCC	LAB_258E		; branch if +ve
00D6EB  2               
00D6EB  2  F6 01        	INC	PLUS_1,X		; this sets b7 eventually
00D6ED  2               LAB_258E
00D6ED  2  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
00D6EF  2  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
00D6F1  2               
00D6F1  2               ; shift FACX Y times right
00D6F1  2               
00D6F1  2               LAB_2592
00D6F1  2  76 02        	ROR	PLUS_2,X		; shift FACX mantissa2
00D6F3  2  76 03        	ROR	PLUS_3,X		; shift FACX mantissa3
00D6F5  2  6A           	ROR				; shift FACX rounding byte
00D6F6  2  C8           	INY				; increment exponent diff
00D6F7  2  D0 EE        	BNE	LAB_2588		; branch if range adjust not complete
00D6F9  2               
00D6F9  2               LAB_259A
00D6F9  2  18           	CLC				; just clear it
00D6FA  2  60           	RTS
00D6FB  2               
00D6FB  2               ; perform LOG()
00D6FB  2               
00D6FB  2               LAB_LOG
00D6FB  2  20 E9 D8     	JSR	LAB_27CA		; test sign and zero
00D6FE  2  F0 02        	BEQ	LAB_25C4		; if zero do function call error then warm start
00D700  2               
00D700  2  10 03        	BPL	LAB_25C7		; skip error if +ve
00D702  2               
00D702  2               LAB_25C4
00D702  2  4C 29 CF     	JMP	LAB_FCER		; do function call error then warm start (-ve)
00D705  2               
00D705  2               LAB_25C7
00D705  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00D707  2  E9 7F        	SBC	#$7F			; normalise it
00D709  2  48           	PHA				; save it
00D70A  2  A9 80        	LDA	#$80			; set exponent to zero
00D70C  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00D70E  2  A9 69        	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
00D710  2  A0 E1        	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
00D712  2  20 BE D5     	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
00D715  2  A9 6D        	LDA	#<LAB_25B1		; set root2 pointer low byte
00D717  2  A0 E1        	LDY	#>LAB_25B1		; set root2 pointer high byte
00D719  2  20 01 D8     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
00D71C  2  A9 E0        	LDA	#<LAB_259C		; set 1 pointer low byte
00D71E  2  A0 E1        	LDY	#>LAB_259C		; set 1 pointer high byte
00D720  2  20 A3 D5     	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
00D723  2  A9 5C        	LDA	#<LAB_25A0		; set pointer low byte to counter
00D725  2  A0 E1        	LDY	#>LAB_25A0		; set pointer high byte to counter
00D727  2  20 51 DC     	JSR	LAB_2B6E		; ^2 then series evaluation
00D72A  2  A9 71        	LDA	#<LAB_25B5		; set -0.5 pointer low byte
00D72C  2  A0 E1        	LDY	#>LAB_25B5		; set -0.5 pointer high byte
00D72E  2  20 BE D5     	JSR	LAB_246C		; add (AY) to FAC1
00D731  2  68           	PLA				; restore FAC1 exponent
00D732  2  20 45 DA     	JSR	LAB_2912		; evaluate new ASCII digit
00D735  2  A9 75        	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
00D737  2  A0 E1        	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
00D739  2               
00D739  2               ; do convert AY, FCA1*(AY)
00D739  2               
00D739  2               LAB_25FB
00D739  2  20 8B D7     	JSR	LAB_264D		; unpack memory (AY) into FAC2
00D73C  2               LAB_MULTIPLY
00D73C  2  F0 4C        	BEQ	LAB_264C		; exit if zero
00D73E  2               
00D73E  2  20 B1 D7     	JSR	LAB_2673		; test and adjust accumulators
00D741  2  A9 00        	LDA	#$00			; clear A
00D743  2  85 75        	STA	FACt_1		; clear temp mantissa1
00D745  2  85 76        	STA	FACt_2		; clear temp mantissa2
00D747  2  85 77        	STA	FACt_3		; clear temp mantissa3
00D749  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00D74B  2  20 60 D7     	JSR	LAB_2622		; go do shift/add FAC2
00D74E  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00D750  2  20 60 D7     	JSR	LAB_2622		; go do shift/add FAC2
00D753  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00D755  2  20 60 D7     	JSR	LAB_2622		; go do shift/add FAC2
00D758  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00D75A  2  20 65 D7     	JSR	LAB_2627		; go do shift/add FAC2
00D75D  2  4C 6E D8     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
00D760  2               
00D760  2               LAB_2622
00D760  2  D0 03        	BNE	LAB_2627		; branch if byte <> zero
00D762  2               
00D762  2  4C C8 D6     	JMP	LAB_2569		; shift FCAtemp << A+8 times
00D765  2               
00D765  2               					; else do shift and add
00D765  2               LAB_2627
00D765  2  4A           	LSR				; shift byte
00D766  2  09 80        	ORA	#$80			; set top bit (mark for 8 times)
00D768  2               LAB_262A
00D768  2  A8           	TAY				; copy result
00D769  2  90 13        	BCC	LAB_2640		; skip next if bit was zero
00D76B  2               
00D76B  2  18           	CLC				; clear carry for add
00D76C  2  A5 77        	LDA	FACt_3		; get temp mantissa3
00D76E  2  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
00D770  2  85 77        	STA	FACt_3		; save temp mantissa3
00D772  2  A5 76        	LDA	FACt_2		; get temp mantissa2
00D774  2  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
00D776  2  85 76        	STA	FACt_2		; save temp mantissa2
00D778  2  A5 75        	LDA	FACt_1		; get temp mantissa1
00D77A  2  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
00D77C  2  85 75        	STA	FACt_1		; save temp mantissa1
00D77E  2               LAB_2640
00D77E  2  66 75        	ROR	FACt_1		; shift temp mantissa1
00D780  2  66 76        	ROR	FACt_2		; shift temp mantissa2
00D782  2  66 77        	ROR	FACt_3		; shift temp mantissa3
00D784  2  66 B9        	ROR	FAC1_r		; shift temp rounding byte
00D786  2  98           	TYA				; get byte back
00D787  2  4A           	LSR				; shift byte
00D788  2  D0 DE        	BNE	LAB_262A		; loop if all bits not done
00D78A  2               
00D78A  2               LAB_264C
00D78A  2  60           	RTS
00D78B  2               
00D78B  2               ; unpack memory (AY) into FAC2
00D78B  2               
00D78B  2               LAB_264D
00D78B  2  85 71        	STA	ut1_pl		; save pointer low byte
00D78D  2  84 72        	STY	ut1_ph		; save pointer high byte
00D78F  2  A0 03        	LDY	#$03			; 4 bytes to get (0-3)
00D791  2  B1 71        	LDA	(ut1_pl),Y		; get mantissa3
00D793  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00D795  2  88           	DEY				; decrement index
00D796  2  B1 71        	LDA	(ut1_pl),Y		; get mantissa2
00D798  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00D79A  2  88           	DEY				; decrement index
00D79B  2  B1 71        	LDA	(ut1_pl),Y		; get mantissa1+sign
00D79D  2  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
00D79F  2  45 B0        	EOR	FAC1_s		; EOR with FAC1 sign (b7)
00D7A1  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00D7A3  2  A5 B7        	LDA	FAC2_s		; recover FAC2 sign (b7)
00D7A5  2  09 80        	ORA	#$80			; set 1xxx xxx (set normal bit)
00D7A7  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00D7A9  2  88           	DEY				; decrement index
00D7AA  2  B1 71        	LDA	(ut1_pl),Y		; get exponent byte
00D7AC  2  85 B3        	STA	FAC2_e		; save FAC2 exponent
00D7AE  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00D7B0  2  60           	RTS
00D7B1  2               
00D7B1  2               ; test and adjust accumulators
00D7B1  2               
00D7B1  2               LAB_2673
00D7B1  2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
00D7B3  2               LAB_2675
00D7B3  2  F0 1D        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
00D7B5  2               
00D7B5  2  18           	CLC				; clear carry for add
00D7B6  2  65 AC        	ADC	FAC1_e		; add FAC1 exponent
00D7B8  2  90 04        	BCC	LAB_2680		; branch if sum of exponents <$0100
00D7BA  2               
00D7BA  2  30 31        	BMI	LAB_269B		; do overflow error
00D7BC  2               
00D7BC  2  18           	CLC				; clear carry for the add
00D7BD  2  2C           	.byte	$2C			; makes next line BIT $1410
00D7BE  2               LAB_2680
00D7BE  2  10 12        	BPL	LAB_2696		; if +ve go handle underflow
00D7C0  2               
00D7C0  2  69 80        	ADC	#$80			; adjust exponent
00D7C2  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00D7C4  2  D0 03        	BNE	LAB_268B		; branch if not zero
00D7C6  2               
00D7C6  2  4C 54 D6     	JMP	LAB_24F5		; save FAC1 sign and return
00D7C9  2               
00D7C9  2               LAB_268B
00D7C9  2  A5 B8        	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
00D7CB  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00D7CD  2               LAB_268F
00D7CD  2  60           	RTS
00D7CE  2               
00D7CE  2               ; handle overflow and underflow
00D7CE  2               
00D7CE  2               LAB_2690
00D7CE  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00D7D0  2  10 1B        	BPL	LAB_269B		; do overflow error
00D7D2  2               
00D7D2  2               					; handle underflow
00D7D2  2               LAB_2696
00D7D2  2  68           	PLA				; pop return address low byte
00D7D3  2  68           	PLA				; pop return address high byte
00D7D4  2  4C 50 D6     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
00D7D7  2               
00D7D7  2               ; multiply by 10
00D7D7  2               
00D7D7  2               LAB_269E
00D7D7  2  20 CA D8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
00D7DA  2  AA           	TAX				; copy exponent (set the flags)
00D7DB  2  F0 F0        	BEQ	LAB_268F		; exit if zero
00D7DD  2               
00D7DD  2  18           	CLC				; clear carry for add
00D7DE  2  69 02        	ADC	#$02			; add two to exponent (*4)
00D7E0  2  B0 0B        	BCS	LAB_269B		; do overflow error if > $FF
00D7E2  2               
00D7E2  2  A2 00        	LDX	#$00			; clear byte
00D7E4  2  86 B8        	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
00D7E6  2  20 DB D5     	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
00D7E9  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*10)
00D7EB  2  D0 E0        	BNE	LAB_268F		; if non zero just do RTS
00D7ED  2               
00D7ED  2               LAB_269B
00D7ED  2  4C C3 D6     	JMP	LAB_2564		; do overflow error and warm start
00D7F0  2               
00D7F0  2               ; divide by 10
00D7F0  2               
00D7F0  2               LAB_26B9
00D7F0  2  20 CA D8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
00D7F3  2  A9 F1        	LDA	#<LAB_26B5		; set pointer to 10d low addr
00D7F5  2  A0 E1        	LDY	#>LAB_26B5		; set pointer to 10d high addr
00D7F7  2  A2 00        	LDX	#$00			; clear sign
00D7F9  2               
00D7F9  2               ; divide by (AY) (X=sign)
00D7F9  2               
00D7F9  2               LAB_26C2
00D7F9  2  86 B8        	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00D7FB  2  20 7D D8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
00D7FE  2  4C 04 D8     	JMP	LAB_DIVIDE		; do FAC2/FAC1
00D801  2               
00D801  2               					; Perform divide-by
00D801  2               ; convert AY and do (AY)/FAC1
00D801  2               
00D801  2               LAB_26CA
00D801  2  20 8B D7     	JSR	LAB_264D		; unpack memory (AY) into FAC2
00D804  2               
00D804  2               					; Perform divide-into
00D804  2               LAB_DIVIDE
00D804  2  F0 63        	BEQ	LAB_2737		; if zero go do /0 error
00D806  2               
00D806  2  20 D9 D8     	JSR	LAB_27BA		; round FAC1
00D809  2  A9 00        	LDA	#$00			; clear A
00D80B  2  38           	SEC				; set carry for subtract
00D80C  2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
00D80E  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00D810  2  20 B1 D7     	JSR	LAB_2673		; test and adjust accumulators
00D813  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
00D815  2  F0 D6        	BEQ	LAB_269B		; if zero do overflow error
00D817  2               
00D817  2  A2 FF        	LDX	#$FF			; set index for pre increment
00D819  2  A9 01        	LDA	#$01			; set bit to flag byte save
00D81B  2               LAB_26E4
00D81B  2  A4 B4        	LDY	FAC2_1		; get FAC2 mantissa1
00D81D  2  C4 AD        	CPY	FAC1_1		; compare FAC1 mantissa1
00D81F  2  D0 0A        	BNE	LAB_26F4		; branch if <>
00D821  2               
00D821  2  A4 B5        	LDY	FAC2_2		; get FAC2 mantissa2
00D823  2  C4 AE        	CPY	FAC1_2		; compare FAC1 mantissa2
00D825  2  D0 04        	BNE	LAB_26F4		; branch if <>
00D827  2               
00D827  2  A4 B6        	LDY	FAC2_3		; get FAC2 mantissa3
00D829  2  C4 AF        	CPY	FAC1_3		; compare FAC1 mantissa3
00D82B  2               LAB_26F4
00D82B  2  08           	PHP				; save FAC2-FAC1 compare status
00D82C  2  2A           	ROL				; shift the result byte
00D82D  2  90 0E        	BCC	LAB_2702		; if no carry skip the byte save
00D82F  2               
00D82F  2  A0 01        	LDY	#$01			; set bit to flag byte save
00D831  2  E8           	INX				; else increment the index to FACt
00D832  2  E0 02        	CPX	#$02			; compare with the index to FACt_3
00D834  2  30 04        	BMI	LAB_2701		; if not last byte just go save it
00D836  2               
00D836  2  D0 28        	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
00D838  2               					; return
00D838  2               
00D838  2  A0 40        	LDY	#$40			; set bit to flag byte save for the rounding byte
00D83A  2               LAB_2701
00D83A  2  95 75        	STA	FACt_1,X		; write result byte to FACt_1 + index
00D83C  2  98           	TYA				; copy the next save byte flag
00D83D  2               LAB_2702
00D83D  2  28           	PLP				; restore FAC2-FAC1 compare status
00D83E  2  90 14        	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
00D840  2               
00D840  2  A8           	TAY				; save FAC2-FAC1 compare status
00D841  2  A5 B6        	LDA	FAC2_3		; get FAC2 mantissa3
00D843  2  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
00D845  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00D847  2  A5 B5        	LDA	FAC2_2		; get FAC2 mantissa2
00D849  2  E5 AE        	SBC	FAC1_2		; subtract FAC1 mantissa2
00D84B  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00D84D  2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
00D84F  2  E5 AD        	SBC	FAC1_1		; subtract FAC1 mantissa1
00D851  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00D853  2  98           	TYA				; restore FAC2-FAC1 compare status
00D854  2               
00D854  2               					; FAC2 = FAC2*2
00D854  2               LAB_2704
00D854  2  06 B6        	ASL	FAC2_3		; shift FAC2 mantissa3
00D856  2  26 B5        	ROL	FAC2_2		; shift FAC2 mantissa2
00D858  2  26 B4        	ROL	FAC2_1		; shift FAC2 mantissa1
00D85A  2  B0 CF        	BCS	LAB_26F4		; loop with no compare
00D85C  2               
00D85C  2  30 BD        	BMI	LAB_26E4		; loop with compare
00D85E  2               
00D85E  2  10 CB        	BPL	LAB_26F4		; loop always with no compare
00D860  2               
00D860  2               ; do A<<6, save as FAC1 rounding byte, normalise and return
00D860  2               
00D860  2               LAB_272B
00D860  2  4A           	LSR				; shift b1 - b0 ..
00D861  2  6A           	ROR				; ..
00D862  2  6A           	ROR				; .. to b7 - b6
00D863  2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00D865  2  28           	PLP				; dump FAC2-FAC1 compare status
00D866  2  4C 6E D8     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
00D869  2               
00D869  2               ; do "Divide by zero" error
00D869  2               
00D869  2               LAB_2737
00D869  2  A2 14        	LDX	#$14			; error code $14 ("Divide by zero" error)
00D86B  2  4C 3C C1     	JMP	LAB_XERR		; do error #X, then warm start
00D86E  2               
00D86E  2               ; copy temp to FAC1 and normalise
00D86E  2               
00D86E  2               LAB_273C
00D86E  2  A5 75        	LDA	FACt_1		; get temp mantissa1
00D870  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00D872  2  A5 76        	LDA	FACt_2		; get temp mantissa2
00D874  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00D876  2  A5 77        	LDA	FACt_3		; get temp mantissa3
00D878  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00D87A  2  4C 34 D6     	JMP	LAB_24D5		; normalise FAC1 and return
00D87D  2               
00D87D  2               ; unpack memory (AY) into FAC1
00D87D  2               
00D87D  2               LAB_UFAC
00D87D  2  85 71        	STA	ut1_pl		; save pointer low byte
00D87F  2  84 72        	STY	ut1_ph		; save pointer high byte
00D881  2  A0 03        	LDY	#$03			; 4 bytes to do
00D883  2  B1 71        	LDA	(ut1_pl),Y		; get last byte
00D885  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00D887  2  88           	DEY				; decrement index
00D888  2  B1 71        	LDA	(ut1_pl),Y		; get last-1 byte
00D88A  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00D88C  2  88           	DEY				; decrement index
00D88D  2  B1 71        	LDA	(ut1_pl),Y		; get second byte
00D88F  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00D891  2  09 80        	ORA	#$80			; set 1xxx xxxx (add normal bit)
00D893  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00D895  2  88           	DEY				; decrement index
00D896  2  B1 71        	LDA	(ut1_pl),Y		; get first byte (exponent)
00D898  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00D89A  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00D89C  2  60           	RTS
00D89D  2               
00D89D  2               ; pack FAC1 into Adatal
00D89D  2               
00D89D  2               LAB_276E
00D89D  2  A2 A4        	LDX	#<Adatal		; set pointer low byte
00D89F  2               LAB_2770
00D89F  2  A0 00        	LDY	#>Adatal		; set pointer high byte
00D8A1  2  F0 04        	BEQ	LAB_2778		; pack FAC1 into (XY) and return
00D8A3  2               
00D8A3  2               ; pack FAC1 into (Lvarpl)
00D8A3  2               
00D8A3  2               LAB_PFAC
00D8A3  2  A6 97        	LDX	Lvarpl		; get destination pointer low byte
00D8A5  2  A4 98        	LDY	Lvarph		; get destination pointer high byte
00D8A7  2               
00D8A7  2               ; pack FAC1 into (XY)
00D8A7  2               
00D8A7  2               LAB_2778
00D8A7  2  20 D9 D8     	JSR	LAB_27BA		; round FAC1
00D8AA  2  86 71        	STX	ut1_pl		; save pointer low byte
00D8AC  2  84 72        	STY	ut1_ph		; save pointer high byte
00D8AE  2  A0 03        	LDY	#$03			; set index
00D8B0  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00D8B2  2  91 71        	STA	(ut1_pl),Y		; store in destination
00D8B4  2  88           	DEY				; decrement index
00D8B5  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00D8B7  2  91 71        	STA	(ut1_pl),Y		; store in destination
00D8B9  2  88           	DEY				; decrement index
00D8BA  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00D8BC  2  09 7F        	ORA	#$7F			; set bits x111 1111
00D8BE  2  25 AD        	AND	FAC1_1		; AND in FAC1 mantissa1
00D8C0  2  91 71        	STA	(ut1_pl),Y		; store in destination
00D8C2  2  88           	DEY				; decrement index
00D8C3  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00D8C5  2  91 71        	STA	(ut1_pl),Y		; store in destination
00D8C7  2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00D8C9  2  60           	RTS
00D8CA  2               
00D8CA  2               ; round and copy FAC1 to FAC2
00D8CA  2               
00D8CA  2               LAB_27AB
00D8CA  2  20 D9 D8     	JSR	LAB_27BA		; round FAC1
00D8CD  2               
00D8CD  2               ; copy FAC1 to FAC2
00D8CD  2               
00D8CD  2               LAB_27AE
00D8CD  2  A2 05        	LDX	#$05			; 5 bytes to copy
00D8CF  2               LAB_27B0
00D8CF  2  B5 AB        	LDA	FAC1_e-1,X		; get byte from FAC1,X
00D8D1  2  95 B2        	STA	FAC1_o,X		; save byte at FAC2,X
00D8D3  2  CA           	DEX				; decrement count
00D8D4  2  D0 F9        	BNE	LAB_27B0		; loop if not all done
00D8D6  2               
00D8D6  2  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
00D8D8  2               LAB_27B9
00D8D8  2  60           	RTS
00D8D9  2               
00D8D9  2               ; round FAC1
00D8D9  2               
00D8D9  2               LAB_27BA
00D8D9  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00D8DB  2  F0 FB        	BEQ	LAB_27B9		; exit if zero
00D8DD  2               
00D8DD  2  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
00D8DF  2  90 F7        	BCC	LAB_27B9		; exit if no overflow
00D8E1  2               
00D8E1  2               ; round FAC1 (no check)
00D8E1  2               
00D8E1  2               LAB_27C2
00D8E1  2  20 B8 D6     	JSR	LAB_2559		; increment FAC1 mantissa
00D8E4  2  D0 F2        	BNE	LAB_27B9		; branch if no overflow
00D8E6  2               
00D8E6  2  4C 89 D6     	JMP	LAB_252A		; normalise FAC1 for C=1 and return
00D8E9  2               
00D8E9  2               ; get FAC1 sign
00D8E9  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00D8E9  2               
00D8E9  2               LAB_27CA
00D8E9  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00D8EB  2  F0 09        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
00D8ED  2               
00D8ED  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00D8ED  2               ; no = 0 check
00D8ED  2               
00D8ED  2               LAB_27CE
00D8ED  2  A5 B0        	LDA	FAC1_s		; else get FAC1 sign (b7)
00D8EF  2               
00D8EF  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00D8EF  2               ; no = 0 check, sign in A
00D8EF  2               
00D8EF  2               LAB_27D0
00D8EF  2  2A           	ROL				; move sign bit to carry
00D8F0  2  A9 FF        	LDA	#$FF			; set byte for -ve result
00D8F2  2  B0 02        	BCS	LAB_27D7		; return if sign was set (-ve)
00D8F4  2               
00D8F4  2  A9 01        	LDA	#$01			; else set byte for +ve result
00D8F6  2               LAB_27D7
00D8F6  2  60           	RTS
00D8F7  2               
00D8F7  2               ; perform SGN()
00D8F7  2               
00D8F7  2               LAB_SGN
00D8F7  2  20 E9 D8     	JSR	LAB_27CA		; get FAC1 sign
00D8FA  2               					; return A=$FF/-ve A=$01/+ve
00D8FA  2               ; save A as integer byte
00D8FA  2               
00D8FA  2               LAB_27DB
00D8FA  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00D8FC  2  A9 00        	LDA	#$00			; clear A
00D8FE  2  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
00D900  2  A2 88        	LDX	#$88			; set exponent
00D902  2               
00D902  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00D902  2               
00D902  2               LAB_27E3
00D902  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00D904  2  49 FF        	EOR	#$FF			; complement it
00D906  2  2A           	ROL				; sign bit into carry
00D907  2               
00D907  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00D907  2               
00D907  2               LAB_STFA
00D907  2  A9 00        	LDA	#$00			; clear A
00D909  2  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
00D90B  2  86 AC        	STX	FAC1_e		; set FAC1 exponent
00D90D  2  85 B9        	STA	FAC1_r		; clear FAC1 rounding byte
00D90F  2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
00D911  2  4C 2F D6     	JMP	LAB_24D0		; do ABS and normalise FAC1
00D914  2               
00D914  2               ; perform ABS()
00D914  2               
00D914  2               LAB_ABS
00D914  2  46 B0        	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
00D916  2  60           	RTS
00D917  2               
00D917  2               ; compare FAC1 with (AY)
00D917  2               ; returns A=$00 if FAC1 = (AY)
00D917  2               ; returns A=$01 if FAC1 > (AY)
00D917  2               ; returns A=$FF if FAC1 < (AY)
00D917  2               
00D917  2               LAB_27F8
00D917  2  85 73        	STA	ut2_pl		; save pointer low byte
00D919  2               LAB_27FA
00D919  2  84 74        	STY	ut2_ph		; save pointer high byte
00D91B  2  A0 00        	LDY	#$00			; clear index
00D91D  2  B1 73        	LDA	(ut2_pl),Y		; get exponent
00D91F  2  C8           	INY				; increment index
00D920  2  AA           	TAX				; copy (AY) exponent to X
00D921  2  F0 C6        	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
00D923  2               					; A=FF,C=1/-ve A=01,C=0/+ve
00D923  2               
00D923  2  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
00D925  2  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
00D927  2  30 C4        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
00D929  2               					; A=01,C=0/+ve and return
00D929  2               
00D929  2  E4 AC        	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
00D92B  2  D0 1A        	BNE	LAB_2828		; branch if different
00D92D  2               
00D92D  2  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
00D92F  2  09 80        	ORA	#$80			; normalise top bit
00D931  2  C5 AD        	CMP	FAC1_1		; compare with FAC1 mantissa1
00D933  2  D0 12        	BNE	LAB_2828		; branch if different
00D935  2               
00D935  2  C8           	INY				; increment index
00D936  2  B1 73        	LDA	(ut2_pl),Y		; get mantissa2
00D938  2  C5 AE        	CMP	FAC1_2		; compare with FAC1 mantissa2
00D93A  2  D0 0B        	BNE	LAB_2828		; branch if different
00D93C  2               
00D93C  2  C8           	INY				; increment index
00D93D  2  A9 7F        	LDA	#$7F			; set for 1/2 value rounding byte
00D93F  2  C5 B9        	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
00D941  2  B1 73        	LDA	(ut2_pl),Y		; get mantissa3
00D943  2  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
00D945  2  F0 28        	BEQ	LAB_2850		; exit if mantissa3 equal
00D947  2               
00D947  2               ; gets here if number <> FAC1
00D947  2               
00D947  2               LAB_2828
00D947  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00D949  2  90 02        	BCC	LAB_282E		; branch if FAC1 > (AY)
00D94B  2               
00D94B  2  49 FF        	EOR	#$FF			; else toggle FAC1 sign
00D94D  2               LAB_282E
00D94D  2  4C EF D8     	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
00D950  2               
00D950  2               ; convert FAC1 floating-to-fixed
00D950  2               
00D950  2               LAB_2831
00D950  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00D952  2  F0 4A        	BEQ	LAB_287F		; if zero go clear FAC1 and return
00D954  2               
00D954  2  38           	SEC				; set carry for subtract
00D955  2  E9 98        	SBC	#$98			; subtract maximum integer range exponent
00D957  2  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
00D959  2  10 09        	BPL	LAB_2845		; branch if FAC1 +ve
00D95B  2               
00D95B  2               					; FAC1 was -ve
00D95B  2  AA           	TAX				; copy subtracted exponent
00D95C  2  A9 FF        	LDA	#$FF			; overflow for -ve number
00D95E  2  85 B2        	STA	FAC1_o		; set FAC1 overflow byte
00D960  2  20 9C D6     	JSR	LAB_253D		; twos complement FAC1 mantissa
00D963  2  8A           	TXA				; restore subtracted exponent
00D964  2               LAB_2845
00D964  2  A2 AC        	LDX	#FAC1_e		; set index to FAC1
00D966  2  C9 F9        	CMP	#$F9			; compare exponent result
00D968  2  10 06        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
00D96A  2               
00D96A  2  20 DA D6     	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
00D96D  2  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
00D96F  2               LAB_2850
00D96F  2  60           	RTS
00D970  2               
00D970  2               ; shift FAC1 A times right
00D970  2               
00D970  2               LAB_2851
00D970  2  A8           	TAY				; copy shift count
00D971  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00D973  2  29 80        	AND	#$80			; mask sign bit only (x000 0000)
00D975  2  46 AD        	LSR	FAC1_1		; shift FAC1 mantissa1
00D977  2  05 AD        	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
00D979  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00D97B  2  20 F1 D6     	JSR	LAB_2592		; shift FAC1 Y times right
00D97E  2  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
00D980  2  60           	RTS
00D981  2               
00D981  2               ; perform INT()
00D981  2               
00D981  2               LAB_INT
00D981  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00D983  2  C9 98        	CMP	#$98			; compare with max int
00D985  2  B0 1E        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
00D987  2               
00D987  2  20 50 D9     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
00D98A  2  84 B9        	STY	FAC1_r		; save FAC1 rounding byte
00D98C  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00D98E  2  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
00D990  2  49 80        	EOR	#$80			; toggle FAC1 sign
00D992  2  2A           	ROL				; shift into carry
00D993  2  A9 98        	LDA	#$98			; set new exponent
00D995  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00D997  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00D999  2  85 5B        	STA	Temp3			; save for EXP() function
00D99B  2  4C 2F D6     	JMP	LAB_24D0		; do ABS and normalise FAC1
00D99E  2               
00D99E  2               ; clear FAC1 and return
00D99E  2               
00D99E  2               LAB_287F
00D99E  2  85 AD        	STA	FAC1_1		; clear FAC1 mantissa1
00D9A0  2  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
00D9A2  2  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
00D9A4  2  A8           	TAY				; clear Y
00D9A5  2               LAB_2886
00D9A5  2  60           	RTS
00D9A6  2               
00D9A6  2               ; get FAC1 from string
00D9A6  2               ; this routine now handles hex and binary values from strings
00D9A6  2               ; starting with "$" and "%" respectively
00D9A6  2               
00D9A6  2               LAB_2887
00D9A6  2  A0 00        	LDY	#$00			; clear Y
00D9A8  2  84 5F        	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
00D9AA  2  A2 09        	LDX	#$09			; set index
00D9AC  2               LAB_288B
00D9AC  2  94 A8        	STY	numexp,X		; clear byte
00D9AE  2  CA           	DEX				; decrement index
00D9AF  2  10 FB        	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
00D9B1  2               
00D9B1  2  90 7F        	BCC	LAB_28FE		; branch if 1st character numeric
00D9B3  2               
00D9B3  2               ; get FAC1 from string .. first character wasn't numeric
00D9B3  2               
00D9B3  2  C9 2D        	CMP	#'-'			; else compare with "-"
00D9B5  2  D0 04        	BNE	LAB_289A		; branch if not "-"
00D9B7  2               
00D9B7  2  86 B1        	STX	negnum		; set flag for -ve number (X = $FF)
00D9B9  2  F0 04        	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
00D9BB  2               
00D9BB  2               ; get FAC1 from string .. first character wasn't numeric or -
00D9BB  2               
00D9BB  2               LAB_289A
00D9BB  2  C9 2B        	CMP	#'+'			; else compare with "+"
00D9BD  2  D0 05        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
00D9BF  2               
00D9BF  2               ; was "+" or "-" to start, so get next character
00D9BF  2               
00D9BF  2               LAB_289C
00D9BF  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00D9C2  2  90 6E        	BCC	LAB_28FE		; branch if numeric character
00D9C4  2               
00D9C4  2               ; code here for hex and binary numbers
00D9C4  2               
00D9C4  2               LAB_289D
00D9C4  2  C9 24        	CMP	#'$'			; else compare with "$"
00D9C6  2  D0 03        	BNE	LAB_NHEX		; branch if not "$"
00D9C8  2               
00D9C8  2  4C 6E DE     	JMP	LAB_CHEX		; branch if "$"
00D9CB  2               
00D9CB  2               LAB_NHEX
00D9CB  2  C9 25        	CMP	#'%'			; else compare with "%"
00D9CD  2  D0 08        	BNE	LAB_28A3		; branch if not "%" (continue original code)
00D9CF  2               
00D9CF  2  4C 9C DE     	JMP	LAB_CBIN		; branch if "%"
00D9D2  2               
00D9D2  2               LAB_289E
00D9D2  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
00D9D5  2               LAB_28A1
00D9D5  2  90 5B        	BCC	LAB_28FE		; branch if numeric character
00D9D7  2               
00D9D7  2               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
00D9D7  2               
00D9D7  2               LAB_28A3
00D9D7  2  C9 2E        	CMP	#'.'			; else compare with "."
00D9D9  2  F0 2E        	BEQ	LAB_28D5		; branch if "."
00D9DB  2               
00D9DB  2               ; get FAC1 from string .. character wasn't numeric, -, + or .
00D9DB  2               
00D9DB  2  C9 45        	CMP	#'E'			; else compare with "E"
00D9DD  2  D0 30        	BNE	LAB_28DB		; branch if not "E"
00D9DF  2               
00D9DF  2               					; was "E" so evaluate exponential part
00D9DF  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00D9E2  2  90 17        	BCC	LAB_28C7		; branch if numeric character
00D9E4  2               
00D9E4  2  C9 B7        	CMP	#TK_MINUS		; else compare with token for -
00D9E6  2  F0 0E        	BEQ	LAB_28C2		; branch if token for -
00D9E8  2               
00D9E8  2  C9 2D        	CMP	#'-'			; else compare with "-"
00D9EA  2  F0 0A        	BEQ	LAB_28C2		; branch if "-"
00D9EC  2               
00D9EC  2  C9 B6        	CMP	#TK_PLUS		; else compare with token for +
00D9EE  2  F0 08        	BEQ	LAB_28C4		; branch if token for +
00D9F0  2               
00D9F0  2  C9 2B        	CMP	#'+'			; else compare with "+"
00D9F2  2  F0 04        	BEQ	LAB_28C4		; branch if "+"
00D9F4  2               
00D9F4  2  D0 07        	BNE	LAB_28C9		; branch always
00D9F6  2               
00D9F6  2               LAB_28C2
00D9F6  2  66 AB        	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
00D9F8  2               LAB_28C4
00D9F8  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00D9FB  2               LAB_28C7
00D9FB  2  90 5B        	BCC	LAB_2925		; branch if numeric character
00D9FD  2               
00D9FD  2               LAB_28C9
00D9FD  2  24 AB        	BIT	expneg		; test exponent -ve flag
00D9FF  2  10 0E        	BPL	LAB_28DB		; if +ve go evaluate exponent
00DA01  2               
00DA01  2               					; else do exponent = -exponent
00DA01  2  A9 00        	LDA	#$00			; clear result
00DA03  2  38           	SEC				; set carry for subtract
00DA04  2  E5 A9        	SBC	expcnt		; subtract exponent byte
00DA06  2  4C 11 DA     	JMP	LAB_28DD		; go evaluate exponent
00DA09  2               
00DA09  2               LAB_28D5
00DA09  2  66 AA        	ROR	numdpf		; set decimal point flag
00DA0B  2  24 AA        	BIT	numdpf		; test decimal point flag
00DA0D  2  50 C3        	BVC	LAB_289E		; branch if only one decimal point so far
00DA0F  2               
00DA0F  2               					; evaluate exponent
00DA0F  2               LAB_28DB
00DA0F  2  A5 A9        	LDA	expcnt		; get exponent count byte
00DA11  2               LAB_28DD
00DA11  2  38           	SEC				; set carry for subtract
00DA12  2  E5 A8        	SBC	numexp		; subtract numerator exponent
00DA14  2  85 A9        	STA	expcnt		; save exponent count byte
00DA16  2  F0 12        	BEQ	LAB_28F6		; branch if no adjustment
00DA18  2               
00DA18  2  10 09        	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
00DA1A  2               
00DA1A  2               					; else go do FAC1/10^(0-expcnt)
00DA1A  2               LAB_28E6
00DA1A  2  20 F0 D7     	JSR	LAB_26B9		; divide by 10
00DA1D  2  E6 A9        	INC	expcnt		; increment exponent count byte
00DA1F  2  D0 F9        	BNE	LAB_28E6		; loop until all done
00DA21  2               
00DA21  2  F0 07        	BEQ	LAB_28F6		; branch always
00DA23  2               
00DA23  2               LAB_28EF
00DA23  2  20 D7 D7     	JSR	LAB_269E		; multiply by 10
00DA26  2  C6 A9        	DEC	expcnt		; decrement exponent count byte
00DA28  2  D0 F9        	BNE	LAB_28EF		; loop until all done
00DA2A  2               
00DA2A  2               LAB_28F6
00DA2A  2  A5 B1        	LDA	negnum		; get -ve flag
00DA2C  2  30 01        	BMI	LAB_28FB		; if -ve do - FAC1 and return
00DA2E  2               
00DA2E  2  60           	RTS
00DA2F  2               
00DA2F  2               ; do - FAC1 and return
00DA2F  2               
00DA2F  2               LAB_28FB
00DA2F  2  4C F4 DB     	JMP	LAB_GTHAN		; do - FAC1 and return
00DA32  2               
00DA32  2               ; do unsigned FAC1*10+number
00DA32  2               
00DA32  2               LAB_28FE
00DA32  2  48           	PHA				; save character
00DA33  2  24 AA        	BIT	numdpf		; test decimal point flag
00DA35  2  10 02        	BPL	LAB_2905		; skip exponent increment if not set
00DA37  2               
00DA37  2  E6 A8        	INC	numexp		; else increment number exponent
00DA39  2               LAB_2905
00DA39  2  20 D7 D7     	JSR	LAB_269E		; multiply FAC1 by 10
00DA3C  2  68           	PLA				; restore character
00DA3D  2  29 0F        	AND	#$0F			; convert to binary
00DA3F  2  20 45 DA     	JSR	LAB_2912		; evaluate new ASCII digit
00DA42  2  4C D2 D9     	JMP	LAB_289E		; go do next character
00DA45  2               
00DA45  2               ; evaluate new ASCII digit
00DA45  2               
00DA45  2               LAB_2912
00DA45  2  48           	PHA				; save digit
00DA46  2  20 CA D8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
00DA49  2  68           	PLA				; restore digit
00DA4A  2  20 FA D8     	JSR	LAB_27DB		; save A as integer byte
00DA4D  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
00DA4F  2  45 B0        	EOR	FAC1_s		; toggle with FAC1 sign (b7)
00DA51  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00DA53  2  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
00DA55  2  4C C1 D5     	JMP	LAB_ADD		; add FAC2 to FAC1 and return
00DA58  2               
00DA58  2               ; evaluate next character of exponential part of number
00DA58  2               
00DA58  2               LAB_2925
00DA58  2  A5 A9        	LDA	expcnt		; get exponent count byte
00DA5A  2  C9 0A        	CMP	#$0A			; compare with 10 decimal
00DA5C  2  90 09        	BCC	LAB_2934		; branch if less
00DA5E  2               
00DA5E  2  A9 64        	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
00DA60  2  24 AB        	BIT	expneg		; test exponent -ve flag
00DA62  2  30 0E        	BMI	LAB_2942		; branch if -ve
00DA64  2               
00DA64  2  4C C3 D6     	JMP	LAB_2564		; else do overflow error
00DA67  2               
00DA67  2               LAB_2934
00DA67  2  0A           	ASL				; * 2
00DA68  2  0A           	ASL				; * 4
00DA69  2  65 A9        	ADC	expcnt		; * 5
00DA6B  2  0A           	ASL				; * 10
00DA6C  2  A0 00        	LDY	#$00			; set index
00DA6E  2  71 C3        	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
00DA70  2  E9 2F        	SBC	#'0'-1		; convert character to binary
00DA72  2               LAB_2942
00DA72  2  85 A9        	STA	expcnt		; save exponent count byte
00DA74  2  4C F8 D9     	JMP	LAB_28C4		; go get next character
00DA77  2               
00DA77  2               ; print " in line [LINE #]"
00DA77  2               
00DA77  2               LAB_2953
00DA77  2  A9 ED        	LDA	#<LAB_LMSG		; point to " in line " message low byte
00DA79  2  A0 E7        	LDY	#>LAB_LMSG		; point to " in line " message high byte
00DA7B  2  20 D3 C8     	JSR	LAB_18C3		; print null terminated string from memory
00DA7E  2               
00DA7E  2               					; print Basic line #
00DA7E  2  A5 88        	LDA	Clineh		; get current line high byte
00DA80  2  A6 87        	LDX	Clinel		; get current line low byte
00DA82  2               
00DA82  2               ; print XA as unsigned integer
00DA82  2               
00DA82  2               LAB_295E
00DA82  2  85 AD        	STA	FAC1_1		; save low byte as FAC1 mantissa1
00DA84  2  86 AE        	STX	FAC1_2		; save high byte as FAC1 mantissa2
00DA86  2  A2 90        	LDX	#$90			; set exponent to 16d bits
00DA88  2  38           	SEC				; set integer is +ve flag
00DA89  2  20 07 D9     	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
00DA8C  2  A0 00        	LDY	#$00			; clear index
00DA8E  2  98           	TYA				; clear A
00DA8F  2  20 A2 DA     	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
00DA92  2  4C D3 C8     	JMP	LAB_18C3		; print null terminated string from memory and return
00DA95  2               
00DA95  2               ; convert FAC1 to ASCII string result in (AY)
00DA95  2               ; not any more, moved scratchpad to page 0
00DA95  2               
00DA95  2               LAB_296E
00DA95  2  A0 01        	LDY	#$01			; set index = 1
00DA97  2  A9 20        	LDA	#$20			; character = " " (assume +ve)
00DA99  2  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
00DA9B  2  10 02        	BPL	LAB_2978		; branch if +ve
00DA9D  2               
00DA9D  2  A9 2D        	LDA	#$2D			; else character = "-"
00DA9F  2               LAB_2978
00DA9F  2  99 EF 00     	STA	Decss,Y		; save leading character (" " or "-")
00DAA2  2               LAB_297B
00DAA2  2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
00DAA4  2  84 BA        	STY	Sendl			; save index
00DAA6  2  C8           	INY				; increment index
00DAA7  2  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
00DAA9  2  D0 05        	BNE	LAB_2989		; branch if FAC1<>0
00DAAB  2               
00DAAB  2               					; exponent was $00 so FAC1 is 0
00DAAB  2  A9 30        	LDA	#'0'			; set character = "0"
00DAAD  2  4C AE DB     	JMP	LAB_2A89		; save last character, [EOT] and exit
00DAB0  2               
00DAB0  2               					; FAC1 is some non zero value
00DAB0  2               LAB_2989
00DAB0  2  A9 00        	LDA	#$00			; clear (number exponent count)
00DAB2  2  E0 81        	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
00DAB4  2               
00DAB4  2  B0 09        	BCS	LAB_299A		; branch if FAC1=>1
00DAB6  2               
00DAB6  2               					; FAC1<1
00DAB6  2  A9 81        	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
00DAB8  2  A0 E1        	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
00DABA  2  20 39 D7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
00DABD  2  A9 FA        	LDA	#$FA			; set number exponent count (-6)
00DABF  2               LAB_299A
00DABF  2  85 A8        	STA	numexp		; save number exponent count
00DAC1  2               LAB_299C
00DAC1  2  A9 7D        	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
00DAC3  2  A0 E1        	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
00DAC5  2  20 17 D9     	JSR	LAB_27F8		; compare FAC1 with (AY)
00DAC8  2  F0 1E        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
00DACA  2               
00DACA  2  10 12        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
00DACC  2               
00DACC  2               					; FAC1 < (AY)
00DACC  2               LAB_29A7
00DACC  2  A9 79        	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
00DACE  2  A0 E1        	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
00DAD0  2  20 17 D9     	JSR	LAB_27F8		; compare FAC1 with (AY)
00DAD3  2  F0 02        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
00DAD5  2               
00DAD5  2  10 0E        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
00DAD7  2               
00DAD7  2               					; FAC1 <= (AY)
00DAD7  2               LAB_29B2
00DAD7  2  20 D7 D7     	JSR	LAB_269E		; multiply by 10
00DADA  2  C6 A8        	DEC	numexp		; decrement number exponent count
00DADC  2  D0 EE        	BNE	LAB_29A7		; go test again (branch always)
00DADE  2               
00DADE  2               LAB_29B9
00DADE  2  20 F0 D7     	JSR	LAB_26B9		; divide by 10
00DAE1  2  E6 A8        	INC	numexp		; increment number exponent count
00DAE3  2  D0 DC        	BNE	LAB_299C		; go test again (branch always)
00DAE5  2               
00DAE5  2               ; now we have just the digits to do
00DAE5  2               
00DAE5  2               LAB_29C0
00DAE5  2  20 BA D5     	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
00DAE8  2               LAB_29C3
00DAE8  2  20 50 D9     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
00DAEB  2  A2 01        	LDX	#$01			; set default digits before dp = 1
00DAED  2  A5 A8        	LDA	numexp		; get number exponent count
00DAEF  2  18           	CLC				; clear carry for add
00DAF0  2  69 07        	ADC	#$07			; up to 6 digits before point
00DAF2  2  30 09        	BMI	LAB_29D8		; if -ve then 1 digit before dp
00DAF4  2               
00DAF4  2  C9 08        	CMP	#$08			; A>=8 if n>=1E6
00DAF6  2  B0 06        	BCS	LAB_29D9		; branch if >= $08
00DAF8  2               
00DAF8  2               					; carry is clear
00DAF8  2  69 FF        	ADC	#$FF			; take 1 from digit count
00DAFA  2  AA           	TAX				; copy to A
00DAFB  2  A9 02        	LDA	#$02			;.set exponent adjust
00DAFD  2               LAB_29D8
00DAFD  2  38           	SEC				; set carry for subtract
00DAFE  2               LAB_29D9
00DAFE  2  E9 02        	SBC	#$02			; -2
00DB00  2  85 A9        	STA	expcnt		;.save exponent adjust
00DB02  2  86 A8        	STX	numexp		; save digits before dp count
00DB04  2  8A           	TXA				; copy to A
00DB05  2  F0 02        	BEQ	LAB_29E4		; branch if no digits before dp
00DB07  2               
00DB07  2  10 13        	BPL	LAB_29F7		; branch if digits before dp
00DB09  2               
00DB09  2               LAB_29E4
00DB09  2  A4 BA        	LDY	Sendl			; get output string index
00DB0B  2  A9 2E        	LDA	#$2E			; character "."
00DB0D  2  C8           	INY				; increment index
00DB0E  2  99 EF 00     	STA	Decss,Y		; save to output string
00DB11  2  8A           	TXA				;.
00DB12  2  F0 06        	BEQ	LAB_29F5		;.
00DB14  2               
00DB14  2  A9 30        	LDA	#'0'			; character "0"
00DB16  2  C8           	INY				; increment index
00DB17  2  99 EF 00     	STA	Decss,Y		; save to output string
00DB1A  2               LAB_29F5
00DB1A  2  84 BA        	STY	Sendl			; save output string index
00DB1C  2               LAB_29F7
00DB1C  2  A0 00        	LDY	#$00			; clear index (point to 100,000)
00DB1E  2  A2 80        	LDX	#$80			;
00DB20  2               LAB_29FB
00DB20  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00DB22  2  18           	CLC				; clear carry for add
00DB23  2  79 F7 E1     	ADC	LAB_2A9C,Y		; add -ve LSB
00DB26  2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00DB28  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00DB2A  2  79 F6 E1     	ADC	LAB_2A9B,Y		; add -ve NMSB
00DB2D  2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00DB2F  2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00DB31  2  79 F5 E1     	ADC	LAB_2A9A,Y		; add -ve MSB
00DB34  2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00DB36  2  E8           	INX				;
00DB37  2  B0 04        	BCS	LAB_2A18		;
00DB39  2               
00DB39  2  10 E5        	BPL	LAB_29FB		; not -ve so try again
00DB3B  2               
00DB3B  2  30 02        	BMI	LAB_2A1A		;
00DB3D  2               
00DB3D  2               LAB_2A18
00DB3D  2  30 E1        	BMI	LAB_29FB		;
00DB3F  2               
00DB3F  2               LAB_2A1A
00DB3F  2  8A           	TXA				;
00DB40  2  90 04        	BCC	LAB_2A21		;
00DB42  2               
00DB42  2  49 FF        	EOR	#$FF			;
00DB44  2  69 0A        	ADC	#$0A			;
00DB46  2               LAB_2A21
00DB46  2  69 2F        	ADC	#'0'-1		; add "0"-1 to result
00DB48  2  C8           	INY				; increment index ..
00DB49  2  C8           	INY				; .. to next less ..
00DB4A  2  C8           	INY				; .. power of ten
00DB4B  2  84 95        	STY	Cvaral		; save as current var address low byte
00DB4D  2  A4 BA        	LDY	Sendl			; get output string index
00DB4F  2  C8           	INY				; increment output string index
00DB50  2  AA           	TAX				; copy character to X
00DB51  2  29 7F        	AND	#$7F			; mask out top bit
00DB53  2  99 EF 00     	STA	Decss,Y		; save to output string
00DB56  2  C6 A8        	DEC	numexp		; decrement # of characters before the dp
00DB58  2  D0 06        	BNE	LAB_2A3B		; branch if still characters to do
00DB5A  2               
00DB5A  2               					; else output the point
00DB5A  2  A9 2E        	LDA	#$2E			; character "."
00DB5C  2  C8           	INY				; increment output string index
00DB5D  2  99 EF 00     	STA	Decss,Y		; save to output string
00DB60  2               LAB_2A3B
00DB60  2  84 BA        	STY	Sendl			; save output string index
00DB62  2  A4 95        	LDY	Cvaral		; get current var address low byte
00DB64  2  8A           	TXA				; get character back
00DB65  2  49 FF        	EOR	#$FF			;
00DB67  2  29 80        	AND	#$80			;
00DB69  2  AA           	TAX				;
00DB6A  2  C0 12        	CPY	#$12			; compare index with max
00DB6C  2  D0 B2        	BNE	LAB_29FB		; loop if not max
00DB6E  2               
00DB6E  2               					; now remove trailing zeroes
00DB6E  2  A4 BA        	LDY	Sendl			; get output string index
00DB70  2               LAB_2A4B
00DB70  2  B9 EF 00     	LDA	Decss,Y		; get character from output string
00DB73  2  88           	DEY				; decrement output string index
00DB74  2  C9 30        	CMP	#'0'			; compare with "0"
00DB76  2  F0 F8        	BEQ	LAB_2A4B		; loop until non "0" character found
00DB78  2               
00DB78  2  C9 2E        	CMP	#'.'			; compare with "."
00DB7A  2  F0 01        	BEQ	LAB_2A58		; branch if was dp
00DB7C  2               
00DB7C  2               					; restore last character
00DB7C  2  C8           	INY				; increment output string index
00DB7D  2               LAB_2A58
00DB7D  2  A9 2B        	LDA	#$2B			; character "+"
00DB7F  2  A6 A9        	LDX	expcnt		; get exponent count
00DB81  2  F0 2E        	BEQ	LAB_2A8C		; if zero go set null terminator and exit
00DB83  2               
00DB83  2               					; exponent isn't zero so write exponent
00DB83  2  10 08        	BPL	LAB_2A68		; branch if exponent count +ve
00DB85  2               
00DB85  2  A9 00        	LDA	#$00			; clear A
00DB87  2  38           	SEC				; set carry for subtract
00DB88  2  E5 A9        	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
00DB8A  2  AA           	TAX				; copy exponent count to X
00DB8B  2  A9 2D        	LDA	#'-'			; character "-"
00DB8D  2               LAB_2A68
00DB8D  2  99 F1 00     	STA	Decss+2,Y		; save to output string
00DB90  2  A9 45        	LDA	#$45			; character "E"
00DB92  2  99 F0 00     	STA	Decss+1,Y		; save exponent sign to output string
00DB95  2  8A           	TXA				; get exponent count back
00DB96  2  A2 2F        	LDX	#'0'-1		; one less than "0" character
00DB98  2  38           	SEC				; set carry for subtract
00DB99  2               LAB_2A74
00DB99  2  E8           	INX				; increment 10's character
00DB9A  2  E9 0A        	SBC	#$0A			;.subtract 10 from exponent count
00DB9C  2  B0 FB        	BCS	LAB_2A74		; loop while still >= 0
00DB9E  2               
00DB9E  2  69 3A        	ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
00DBA0  2  99 F3 00     	STA	Decss+4,Y		; save to output string
00DBA3  2  8A           	TXA				; copy 10's character
00DBA4  2  99 F2 00     	STA	Decss+3,Y		; save to output string
00DBA7  2  A9 00        	LDA	#$00			; set null terminator
00DBA9  2  99 F4 00     	STA	Decss+5,Y		; save to output string
00DBAC  2  F0 08        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
00DBAE  2               
00DBAE  2               					; save last character, [EOT] and exit
00DBAE  2               LAB_2A89
00DBAE  2  99 EF 00     	STA	Decss,Y		; save last character to output string
00DBB1  2               
00DBB1  2               					; set null terminator and exit
00DBB1  2               LAB_2A8C
00DBB1  2  A9 00        	LDA	#$00			; set null terminator
00DBB3  2  99 F0 00     	STA	Decss+1,Y		; save after last character
00DBB6  2               
00DBB6  2               					; set string pointer (AY) and exit
00DBB6  2               LAB_2A91
00DBB6  2  A9 F0        	LDA	#<Decssp1		; set result string low pointer
00DBB8  2  A0 00        	LDY	#>Decssp1		; set result string high pointer
00DBBA  2  60           	RTS
00DBBB  2               
00DBBB  2               ; perform power function
00DBBB  2               
00DBBB  2               LAB_POWER
00DBBB  2  F0 42        	BEQ	LAB_EXP		; go do  EXP()
00DBBD  2               
00DBBD  2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
00DBBF  2  D0 03        	BNE	LAB_2ABF		; branch if FAC2<>0
00DBC1  2               
00DBC1  2  4C 52 D6     	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
00DBC4  2               
00DBC4  2               LAB_2ABF
00DBC4  2  A2 9C        	LDX	#<func_l		; set destination pointer low byte
00DBC6  2  A0 00        	LDY	#>func_l		; set destination pointer high byte
00DBC8  2  20 A7 D8     	JSR	LAB_2778		; pack FAC1 into (XY)
00DBCB  2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
00DBCD  2  10 0F        	BPL	LAB_2AD9		; branch if FAC2>0
00DBCF  2               
00DBCF  2               					; else FAC2 is -ve and can only be raised to an
00DBCF  2               					; integer power which gives an x +j0 result
00DBCF  2  20 81 D9     	JSR	LAB_INT		; perform INT
00DBD2  2  A9 9C        	LDA	#<func_l		; set source pointer low byte
00DBD4  2  A0 00        	LDY	#>func_l		; set source pointer high byte
00DBD6  2  20 17 D9     	JSR	LAB_27F8		; compare FAC1 with (AY)
00DBD9  2  D0 03        	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
00DBDB  2               					; this will leave FAC1 -ve and cause a Function Call
00DBDB  2               					; error when LOG() is called
00DBDB  2               
00DBDB  2  98           	TYA				; clear sign b7
00DBDC  2  A4 5B        	LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
00DBDE  2               					; for possible later negation, b0
00DBDE  2               LAB_2AD9
00DBDE  2  20 C5 D5     	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
00DBE1  2  98           	TYA				; copy sign back ..
00DBE2  2  48           	PHA				; .. and save it
00DBE3  2  20 FB D6     	JSR	LAB_LOG		; do LOG(n)
00DBE6  2  A9 9C        	LDA	#<garb_l		; set pointer low byte
00DBE8  2  A0 00        	LDY	#>garb_l		; set pointer high byte
00DBEA  2  20 39 D7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
00DBED  2  20 FF DB     	JSR	LAB_EXP		; go do EXP(n)
00DBF0  2  68           	PLA				; pull sign from stack
00DBF1  2  4A           	LSR				; b0 is to be tested, shift to Cb
00DBF2  2  90 0A        	BCC	LAB_2AF9		; if no bit then exit
00DBF4  2               
00DBF4  2               					; Perform negation
00DBF4  2               ; do - FAC1
00DBF4  2               
00DBF4  2               LAB_GTHAN
00DBF4  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00DBF6  2  F0 06        	BEQ	LAB_2AF9		; exit if FAC1_e = $00
00DBF8  2               
00DBF8  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00DBFA  2  49 FF        	EOR	#$FF			; complement it
00DBFC  2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00DBFE  2               LAB_2AF9
00DBFE  2  60           	RTS
00DBFF  2               
00DBFF  2               ; perform EXP()	(x^e)
00DBFF  2               
00DBFF  2               LAB_EXP
00DBFF  2  A9 85        	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
00DC01  2  A0 E1        	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
00DC03  2  20 39 D7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
00DC06  2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00DC08  2  69 50        	ADC	#$50			; +$50/$100
00DC0A  2  90 03        	BCC	LAB_2B2B		; skip rounding if no carry
00DC0C  2               
00DC0C  2  20 E1 D8     	JSR	LAB_27C2		; round FAC1 (no check)
00DC0F  2               LAB_2B2B
00DC0F  2  85 A3        	STA	FAC2_r		; save FAC2 rounding byte
00DC11  2  20 CD D8     	JSR	LAB_27AE		; copy FAC1 to FAC2
00DC14  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00DC16  2  C9 88        	CMP	#$88			; compare with EXP limit (256d)
00DC18  2  90 03        	BCC	LAB_2B39		; branch if less
00DC1A  2               
00DC1A  2               LAB_2B36
00DC1A  2  20 CE D7     	JSR	LAB_2690		; handle overflow and underflow
00DC1D  2               LAB_2B39
00DC1D  2  20 81 D9     	JSR	LAB_INT		; perform INT
00DC20  2  A5 5B        	LDA	Temp3			; get mantissa 3 from INT() function
00DC22  2  18           	CLC				; clear carry for add
00DC23  2  69 81        	ADC	#$81			; normalise +1
00DC25  2  F0 F3        	BEQ	LAB_2B36		; if $00 go handle overflow
00DC27  2               
00DC27  2  38           	SEC				; set carry for subtract
00DC28  2  E9 01        	SBC	#$01			; now correct for exponent
00DC2A  2  48           	PHA				; save FAC2 exponent
00DC2B  2               
00DC2B  2               					; swap FAC1 and FAC2
00DC2B  2  A2 04        	LDX	#$04			; 4 bytes to do
00DC2D  2               LAB_2B49
00DC2D  2  B5 B3        	LDA	FAC2_e,X		; get FAC2,X
00DC2F  2  B4 AC        	LDY	FAC1_e,X		; get FAC1,X
00DC31  2  95 AC        	STA	FAC1_e,X		; save FAC1,X
00DC33  2  94 B3        	STY	FAC2_e,X		; save FAC2,X
00DC35  2  CA           	DEX				; decrement count/index
00DC36  2  10 F5        	BPL	LAB_2B49		; loop if not all done
00DC38  2               
00DC38  2  A5 A3        	LDA	FAC2_r		; get FAC2 rounding byte
00DC3A  2  85 B9        	STA	FAC1_r		; save as FAC1 rounding byte
00DC3C  2  20 A6 D5     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
00DC3F  2  20 F4 DB     	JSR	LAB_GTHAN		; do - FAC1
00DC42  2  A9 89        	LDA	#<LAB_2AFE		; set counter pointer low byte
00DC44  2  A0 E1        	LDY	#>LAB_2AFE		; set counter pointer high byte
00DC46  2  20 67 DC     	JSR	LAB_2B84		; go do series evaluation
00DC49  2  A9 00        	LDA	#$00			; clear A
00DC4B  2  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
00DC4D  2  68           	PLA				;.get saved FAC2 exponent
00DC4E  2  4C B3 D7     	JMP	LAB_2675		; test and adjust accumulators and return
00DC51  2               
00DC51  2               ; ^2 then series evaluation
00DC51  2               
00DC51  2               LAB_2B6E
00DC51  2  85 BA        	STA	Cptrl			; save count pointer low byte
00DC53  2  84 BB        	STY	Cptrh			; save count pointer high byte
00DC55  2  20 9D D8     	JSR	LAB_276E		; pack FAC1 into Adatal
00DC58  2  A9 A4        	LDA	#<Adatal		; set pointer low byte (Y already $00)
00DC5A  2  20 39 D7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
00DC5D  2  20 6B DC     	JSR	LAB_2B88		; go do series evaluation
00DC60  2  A9 A4        	LDA	#<Adatal		; pointer to original # low byte
00DC62  2  A0 00        	LDY	#>Adatal		; pointer to original # high byte
00DC64  2  4C 39 D7     	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
00DC67  2               
00DC67  2               ; series evaluation
00DC67  2               
00DC67  2               LAB_2B84
00DC67  2  85 BA        	STA	Cptrl			; save count pointer low byte
00DC69  2  84 BB        	STY	Cptrh			; save count pointer high byte
00DC6B  2               LAB_2B88
00DC6B  2  A2 A8        	LDX	#<numexp		; set pointer low byte
00DC6D  2  20 9F D8     	JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
00DC70  2  B1 BA        	LDA	(Cptrl),Y		; get constants count
00DC72  2  85 B1        	STA	numcon		; save constants count
00DC74  2  A4 BA        	LDY	Cptrl			; get count pointer low byte
00DC76  2  C8           	INY				; increment it (now constants pointer)
00DC77  2  98           	TYA				; copy it
00DC78  2  D0 02        	BNE	LAB_2B97		; skip next if no overflow
00DC7A  2               
00DC7A  2  E6 BB        	INC	Cptrh			; else increment high byte
00DC7C  2               LAB_2B97
00DC7C  2  85 BA        	STA	Cptrl			; save low byte
00DC7E  2  A4 BB        	LDY	Cptrh			; get high byte
00DC80  2               LAB_2B9B
00DC80  2  20 39 D7     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
00DC83  2  A5 BA        	LDA	Cptrl			; get constants pointer low byte
00DC85  2  A4 BB        	LDY	Cptrh			; get constants pointer high byte
00DC87  2  18           	CLC				; clear carry for add
00DC88  2  69 04        	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
00DC8A  2  90 01        	BCC	LAB_2BA8		; skip next if no overflow
00DC8C  2               
00DC8C  2  C8           	INY				; increment high byte
00DC8D  2               LAB_2BA8
00DC8D  2  85 BA        	STA	Cptrl			; save pointer low byte
00DC8F  2  84 BB        	STY	Cptrh			; save pointer high byte
00DC91  2  20 BE D5     	JSR	LAB_246C		; add (AY) to FAC1
00DC94  2  A9 A8        	LDA	#<numexp		; set pointer low byte to partial @ numexp
00DC96  2  A0 00        	LDY	#>numexp		; set pointer high byte to partial @ numexp
00DC98  2  C6 B1        	DEC	numcon		; decrement constants count
00DC9A  2  D0 E4        	BNE	LAB_2B9B		; loop until all done
00DC9C  2               
00DC9C  2  60           	RTS
00DC9D  2               
00DC9D  2               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
00DC9D  2               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
00DC9D  2               ; the Galois method and a sample of 65536 bytes produced gives the following values.
00DC9D  2               
00DC9D  2               ; Entropy = 7.997442 bits per byte
00DC9D  2               ; Optimum compression would reduce these 65536 bytes by 0 percent
00DC9D  2               
00DC9D  2               ; Chi square distribution for 65536 samples is 232.01, and
00DC9D  2               ; randomly would exceed this value 75.00 percent of the time
00DC9D  2               
00DC9D  2               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00DC9D  2               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00DC9D  2               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00DC9D  2               
00DC9D  2               LAB_RND
00DC9D  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00DC9F  2  F0 07        	BEQ	NextPRN		; do next random # if zero
00DCA1  2               
00DCA1  2               					; else get seed into random number store
00DCA1  2  A2 D8        	LDX	#Rbyte4		; set PRNG pointer low byte
00DCA3  2  A0 00        	LDY	#$00			; set PRNG pointer high byte
00DCA5  2  20 A7 D8     	JSR	LAB_2778		; pack FAC1 into (XY)
00DCA8  2               NextPRN
00DCA8  2  A2 AF        	LDX	#$AF			; set EOR byte
00DCAA  2  A0 13        	LDY	#$13			; do this nineteen times
00DCAC  2               LoopPRN
00DCAC  2  06 D9        	ASL	Rbyte1		; shift PRNG most significant byte
00DCAE  2  26 DA        	ROL	Rbyte2		; shift PRNG middle byte
00DCB0  2  26 DB        	ROL	Rbyte3		; shift PRNG least significant byte
00DCB2  2  26 D8        	ROL	Rbyte4		; shift PRNG extra byte
00DCB4  2  90 05        	BCC	Ninc1			; branch if bit 32 clear
00DCB6  2               
00DCB6  2  8A           	TXA				; set EOR byte
00DCB7  2  45 D9        	EOR	Rbyte1		; EOR PRNG extra byte
00DCB9  2  85 D9        	STA	Rbyte1		; save new PRNG extra byte
00DCBB  2               Ninc1
00DCBB  2  88           	DEY				; decrement loop count
00DCBC  2  D0 EE        	BNE	LoopPRN		; loop if not all done
00DCBE  2               
00DCBE  2  A2 02        	LDX	#$02			; three bytes to copy
00DCC0  2               CopyPRNG
00DCC0  2  B5 D9        	LDA	Rbyte1,X		; get PRNG byte
00DCC2  2  95 AD        	STA	FAC1_1,X		; save FAC1 byte
00DCC4  2  CA           	DEX
00DCC5  2  10 F9        	BPL	CopyPRNG		; loop if not complete
00DCC7  2               
00DCC7  2  A9 80        	LDA	#$80			; set the exponent
00DCC9  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00DCCB  2               
00DCCB  2  0A           	ASL				; clear A
00DCCC  2  85 B0        	STA	FAC1_s		; save FAC1 sign
00DCCE  2               
00DCCE  2  4C 34 D6     	JMP	LAB_24D5		; normalise FAC1 and return
00DCD1  2               
00DCD1  2               ; perform COS()
00DCD1  2               
00DCD1  2               LAB_COS
00DCD1  2  A9 A6        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
00DCD3  2  A0 E1        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
00DCD5  2  20 BE D5     	JSR	LAB_246C		; add (AY) to FAC1
00DCD8  2               
00DCD8  2               ; perform SIN()
00DCD8  2               
00DCD8  2               LAB_SIN
00DCD8  2  20 CA D8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
00DCDB  2  A9 BB        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
00DCDD  2  A0 E1        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
00DCDF  2  A6 B7        	LDX	FAC2_s		; get FAC2 sign (b7)
00DCE1  2  20 F9 D7     	JSR	LAB_26C2		; divide by (AY) (X=sign)
00DCE4  2  20 CA D8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
00DCE7  2  20 81 D9     	JSR	LAB_INT		; perform INT
00DCEA  2  A9 00        	LDA	#$00			; clear byte
00DCEC  2  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
00DCEE  2  20 A6 D5     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
00DCF1  2  A9 ED        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
00DCF3  2  A0 E1        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
00DCF5  2  20 A3 D5     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
00DCF8  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00DCFA  2  48           	PHA				; save FAC1 sign
00DCFB  2  10 0D        	BPL	LAB_2C35		; branch if +ve
00DCFD  2               
00DCFD  2               					; FAC1 sign was -ve
00DCFD  2  20 BA D5     	JSR	LAB_244E		; add 0.5 to FAC1
00DD00  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00DD02  2  30 09        	BMI	LAB_2C38		; branch if -ve
00DD04  2               
00DD04  2  A5 63        	LDA	Cflag			; get comparison evaluation flag
00DD06  2  49 FF        	EOR	#$FF			; toggle flag
00DD08  2  85 63        	STA	Cflag			; save comparison evaluation flag
00DD0A  2               LAB_2C35
00DD0A  2  20 F4 DB     	JSR	LAB_GTHAN		; do - FAC1
00DD0D  2               LAB_2C38
00DD0D  2  A9 ED        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
00DD0F  2  A0 E1        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
00DD11  2  20 BE D5     	JSR	LAB_246C		; add (AY) to FAC1
00DD14  2  68           	PLA				; restore FAC1 sign
00DD15  2  10 03        	BPL	LAB_2C45		; branch if was +ve
00DD17  2               
00DD17  2               					; else correct FAC1
00DD17  2  20 F4 DB     	JSR	LAB_GTHAN		; do - FAC1
00DD1A  2               LAB_2C45
00DD1A  2  A9 AA        	LDA	#<LAB_2C84		; set pointer low byte to counter
00DD1C  2  A0 E1        	LDY	#>LAB_2C84		; set pointer high byte to counter
00DD1E  2  4C 51 DC     	JMP	LAB_2B6E		; ^2 then series evaluation and return
00DD21  2               
00DD21  2               ; perform TAN()
00DD21  2               
00DD21  2               LAB_TAN
00DD21  2  20 9D D8     	JSR	LAB_276E		; pack FAC1 into Adatal
00DD24  2  A9 00        	LDA	#$00			; clear byte
00DD26  2  85 63        	STA	Cflag			; clear comparison evaluation flag
00DD28  2  20 D8 DC     	JSR	LAB_SIN		; go do SIN(n)
00DD2B  2  A2 9C        	LDX	#<func_l		; set sin(n) pointer low byte
00DD2D  2  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
00DD2F  2  20 A7 D8     	JSR	LAB_2778		; pack FAC1 into (XY)
00DD32  2  A9 A4        	LDA	#<Adatal		; set n pointer low addr
00DD34  2  A0 00        	LDY	#>Adatal		; set n pointer high addr
00DD36  2  20 7D D8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
00DD39  2  A9 00        	LDA	#$00			; clear byte
00DD3B  2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
00DD3D  2  A5 63        	LDA	Cflag			; get comparison evaluation flag
00DD3F  2  20 49 DD     	JSR	LAB_2C74		; save flag and go do series evaluation
00DD42  2               
00DD42  2  A9 9C        	LDA	#<func_l		; set sin(n) pointer low byte
00DD44  2  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
00DD46  2  4C 01 D8     	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
00DD49  2               
00DD49  2               LAB_2C74
00DD49  2  48           	PHA				; save comparison evaluation flag
00DD4A  2  4C 0A DD     	JMP	LAB_2C35		; go do series evaluation
00DD4D  2               
00DD4D  2               ; perform USR()
00DD4D  2               
00DD4D  2               LAB_USR
00DD4D  2  20 0A 00     	JSR	Usrjmp		; call user code
00DD50  2  4C EF CB     	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
00DD53  2               
00DD53  2               ; perform ATN()
00DD53  2               
00DD53  2               LAB_ATN
00DD53  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00DD55  2  48           	PHA				; save sign
00DD56  2  10 03        	BPL	LAB_2CA1		; branch if +ve
00DD58  2               
00DD58  2  20 F4 DB     	JSR	LAB_GTHAN		; else do - FAC1
00DD5B  2               LAB_2CA1
00DD5B  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00DD5D  2  48           	PHA				; push exponent
00DD5E  2  C9 81        	CMP	#$81			; compare with 1
00DD60  2  90 07        	BCC	LAB_2CAF		; branch if FAC1<1
00DD62  2               
00DD62  2  A9 E0        	LDA	#<LAB_259C		; set 1 pointer low byte
00DD64  2  A0 E1        	LDY	#>LAB_259C		; set 1 pointer high byte
00DD66  2  20 01 D8     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
00DD69  2               LAB_2CAF
00DD69  2  A9 BF        	LDA	#<LAB_2CC9		; set pointer low byte to counter
00DD6B  2  A0 E1        	LDY	#>LAB_2CC9		; set pointer high byte to counter
00DD6D  2  20 51 DC     	JSR	LAB_2B6E		; ^2 then series evaluation
00DD70  2  68           	PLA				; restore old FAC1 exponent
00DD71  2  C9 81        	CMP	#$81			; compare with 1
00DD73  2  90 07        	BCC	LAB_2CC2		; branch if FAC1<1
00DD75  2               
00DD75  2  A9 A6        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
00DD77  2  A0 E1        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
00DD79  2  20 A3 D5     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
00DD7C  2               LAB_2CC2
00DD7C  2  68           	PLA				; restore FAC1 sign
00DD7D  2  10 16        	BPL	LAB_2D04		; exit if was +ve
00DD7F  2               
00DD7F  2  4C F4 DB     	JMP	LAB_GTHAN		; else do - FAC1 and return
00DD82  2               
00DD82  2               ; perform BITSET
00DD82  2               
00DD82  2               LAB_BITSET
00DD82  2  20 D8 D4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
00DD85  2  E0 08        	CPX	#$08			; only 0 to 7 are allowed
00DD87  2  B0 20        	BCS	FCError		; branch if > 7
00DD89  2               
00DD89  2  A9 00        	LDA	#$00			; clear A
00DD8B  2  38           	SEC				; set the carry
00DD8C  2               S_Bits
00DD8C  2  2A           	ROL				; shift bit
00DD8D  2  CA           	DEX				; decrement bit number
00DD8E  2  10 FC        	BPL	S_Bits		; loop if still +ve
00DD90  2               
00DD90  2  E8           	INX				; make X = $00
00DD91  2  01 11        	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
00DD93  2  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
00DD95  2               LAB_2D04
00DD95  2  60           	RTS
00DD96  2               
00DD96  2               ; perform BITCLR
00DD96  2               
00DD96  2               LAB_BITCLR
00DD96  2  20 D8 D4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
00DD99  2  E0 08        	CPX	#$08			; only 0 to 7 are allowed
00DD9B  2  B0 0C        	BCS	FCError		; branch if > 7
00DD9D  2               
00DD9D  2  A9 FF        	LDA	#$FF			; set A
00DD9F  2               S_Bitc
00DD9F  2  2A           	ROL				; shift bit
00DDA0  2  CA           	DEX				; decrement bit number
00DDA1  2  10 FC        	BPL	S_Bitc		; loop if still +ve
00DDA3  2               
00DDA3  2  E8           	INX				; make X = $00
00DDA4  2  21 11        	AND	(Itempl,X)		; and with byte via temporary integer (addr)
00DDA6  2  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
00DDA8  2  60           	RTS
00DDA9  2               
00DDA9  2               FCError
00DDA9  2  4C 29 CF     	JMP	LAB_FCER		; do function call error then warm start
00DDAC  2               
00DDAC  2               ; perform BITTST()
00DDAC  2               
00DDAC  2               LAB_BTST
00DDAC  2  20 BC 00     	JSR	LAB_IGBY		; increment BASIC pointer
00DDAF  2  20 D8 D4     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
00DDB2  2  E0 08        	CPX	#$08			; only 0 to 7 are allowed
00DDB4  2  B0 F3        	BCS	FCError		; branch if > 7
00DDB6  2               
00DDB6  2  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
00DDB9  2  C9 29        	CMP	#')'			; is next character ")"
00DDBB  2  F0 03        	BEQ	TST_OK		; if ")" go do rest of function
00DDBD  2               
00DDBD  2  4C 02 CC     	JMP	LAB_SNER		; do syntax error then warm start
00DDC0  2               
00DDC0  2               TST_OK
00DDC0  2  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
00DDC3  2  A9 00        	LDA	#$00			; clear A
00DDC5  2  38           	SEC				; set the carry
00DDC6  2               T_Bits
00DDC6  2  2A           	ROL				; shift bit
00DDC7  2  CA           	DEX				; decrement bit number
00DDC8  2  10 FC        	BPL	T_Bits		; loop if still +ve
00DDCA  2               
00DDCA  2  E8           	INX				; make X = $00
00DDCB  2  21 11        	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
00DDCD  2  F0 02        	BEQ	LAB_NOTT		; branch if zero (already correct)
00DDCF  2               
00DDCF  2  A9 FF        	LDA	#$FF			; set for -1 result
00DDD1  2               LAB_NOTT
00DDD1  2  4C FA D8     	JMP	LAB_27DB		; go do SGN tail
00DDD4  2               
00DDD4  2               ; perform BIN$()
00DDD4  2               
00DDD4  2               LAB_BINS
00DDD4  2  E0 19        	CPX	#$19			; max + 1
00DDD6  2  B0 48        	BCS	BinFErr		; exit if too big ( > or = )
00DDD8  2               
00DDD8  2  86 78        	STX	TempB			; save # of characters ($00 = leading zero remove)
00DDDA  2  A9 18        	LDA	#$18			; need A byte long space
00DDDC  2  20 3A D1     	JSR	LAB_MSSP		; make string space A bytes long
00DDDF  2  A0 17        	LDY	#$17			; set index
00DDE1  2  A2 18        	LDX	#$18			; character count
00DDE3  2               NextB1
00DDE3  2  46 11        	LSR	nums_1		; shift highest byte
00DDE5  2  66 12        	ROR	nums_2		; shift middle byte
00DDE7  2  66 13        	ROR	nums_3		; shift lowest byte bit 0 to carry
00DDE9  2  8A           	TXA				; load with "0"/2
00DDEA  2  2A           	ROL				; shift in carry
00DDEB  2  91 AD        	STA	(str_pl),Y		; save to temp string + index
00DDED  2  88           	DEY				; decrement index
00DDEE  2  10 F3        	BPL	NextB1		; loop if not done
00DDF0  2               
00DDF0  2  A5 78        	LDA	TempB			; get # of characters
00DDF2  2  F0 0A        	BEQ	EndBHS		; branch if truncate
00DDF4  2               
00DDF4  2  AA           	TAX				; copy length to X
00DDF5  2  38           	SEC				; set carry for add !
00DDF6  2  49 FF        	EOR	#$FF			; 1's complement
00DDF8  2  69 18        	ADC	#$18			; add 24d
00DDFA  2  F0 1C        	BEQ	GoPr2			; if zero print whole string
00DDFC  2               
00DDFC  2  D0 0F        	BNE	GoPr1			; else go make output string
00DDFE  2               
00DDFE  2               ; this is the exit code and is also used by HEX$()
00DDFE  2               ; truncate string to remove leading "0"s
00DDFE  2               
00DDFE  2               EndBHS
00DDFE  2  A8           	TAY				; clear index (A=0, X=length here)
00DDFF  2               NextB2
00DDFF  2  B1 AD        	LDA	(str_pl),Y		; get character from string
00DE01  2  C9 30        	CMP	#'0'			; compare with "0"
00DE03  2  D0 07        	BNE	GoPr			; if not "0" then go print string from here
00DE05  2               
00DE05  2  CA           	DEX				; decrement character count
00DE06  2  F0 03        	BEQ	GoPr3			; if zero then end of string so go print it
00DE08  2               
00DE08  2  C8           	INY				; else increment index
00DE09  2  10 F4        	BPL	NextB2		; loop always
00DE0B  2               
00DE0B  2               ; make fixed length output string - ignore overflows!
00DE0B  2               
00DE0B  2               GoPr3
00DE0B  2  E8           	INX				; need at least 1 character
00DE0C  2               GoPr
00DE0C  2  98           	TYA				; copy result
00DE0D  2               GoPr1
00DE0D  2  18           	CLC				; clear carry for add
00DE0E  2  65 AD        	ADC	str_pl		; add low address
00DE10  2  85 AD        	STA	str_pl		; save low address
00DE12  2  A9 00        	LDA	#$00			; do high byte
00DE14  2  65 AE        	ADC	str_ph		; add high address
00DE16  2  85 AE        	STA	str_ph		; save high address
00DE18  2               GoPr2
00DE18  2  86 AC        	STX	str_ln		; X holds string length
00DE1A  2  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
00DE1D  2  4C 85 D1     	JMP	LAB_RTST		; check for space on descriptor stack then put address
00DE20  2               					; and length on descriptor stack and update stack pointers
00DE20  2               
00DE20  2               BinFErr
00DE20  2  4C 29 CF     	JMP	LAB_FCER		; do function call error then warm start
00DE23  2               
00DE23  2               ; perform HEX$()
00DE23  2               
00DE23  2               LAB_HEXS
00DE23  2  E0 07        	CPX	#$07			; max + 1
00DE25  2  B0 F9        	BCS	BinFErr		; exit if too big ( > or = )
00DE27  2               
00DE27  2  86 78        	STX	TempB			; save # of characters
00DE29  2               
00DE29  2  A9 06        	LDA	#$06			; need 6 bytes for string
00DE2B  2  20 3A D1     	JSR	LAB_MSSP		; make string space A bytes long
00DE2E  2  A0 05        	LDY	#$05			; set string index
00DE30  2               
00DE30  2  F8           	SED				; need decimal mode for nibble convert
00DE31  2  A5 13        	LDA	nums_3		; get lowest byte
00DE33  2  20 51 DE     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
00DE36  2  A5 12        	LDA	nums_2		; get middle byte
00DE38  2  20 51 DE     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
00DE3B  2  A5 11        	LDA	nums_1		; get highest byte
00DE3D  2  20 51 DE     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
00DE40  2  D8           	CLD				; back to binary
00DE41  2               
00DE41  2  A2 06        	LDX	#$06			; character count
00DE43  2  A5 78        	LDA	TempB			; get # of characters
00DE45  2  F0 B7        	BEQ	EndBHS		; branch if truncate
00DE47  2               
00DE47  2  AA           	TAX				; copy length to X
00DE48  2  38           	SEC				; set carry for add !
00DE49  2  49 FF        	EOR	#$FF			; 1's complement
00DE4B  2  69 06        	ADC	#$06			; add 6d
00DE4D  2  F0 C9        	BEQ	GoPr2			; if zero print whole string
00DE4F  2               
00DE4F  2  D0 BC        	BNE	GoPr1			; else go make output string (branch always)
00DE51  2               
00DE51  2               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
00DE51  2               
00DE51  2               LAB_A2HX
00DE51  2  AA           	TAX				; save byte
00DE52  2  29 0F        	AND	#$0F			; mask off top bits
00DE54  2  20 5C DE     	JSR	LAB_AL2X		; convert low nibble to ASCII and output
00DE57  2  8A           	TXA				; get byte back
00DE58  2  4A           	LSR				; /2	shift high nibble to low nibble
00DE59  2  4A           	LSR				; /4
00DE5A  2  4A           	LSR				; /8
00DE5B  2  4A           	LSR				; /16
00DE5C  2               LAB_AL2X
00DE5C  2  C9 0A        	CMP	#$0A			; set carry for +1 if >9
00DE5E  2  69 30        	ADC	#'0'			; add ASCII "0"
00DE60  2  91 AD        	STA	(str_pl),Y		; save to temp string
00DE62  2  88           	DEY				; decrement counter
00DE63  2  60           	RTS
00DE64  2               
00DE64  2               LAB_NLTO
00DE64  2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00DE66  2  A9 00        	LDA	#$00			; clear sign compare
00DE68  2               LAB_MLTE
00DE68  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00DE6A  2  8A           	TXA				; restore character
00DE6B  2  20 45 DA     	JSR	LAB_2912		; evaluate new ASCII digit
00DE6E  2               
00DE6E  2               ; gets here if the first character was "$" for hex
00DE6E  2               ; get hex number
00DE6E  2               
00DE6E  2               LAB_CHEX
00DE6E  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00DE71  2  90 0A        	BCC	LAB_ISHN		; branch if numeric character
00DE73  2               
00DE73  2  09 20        	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
00DE75  2  E9 61        	SBC	#'a'			; subtract "a" (carry set here)
00DE77  2  C9 06        	CMP	#$06			; compare normalised with $06 (max+1)
00DE79  2  B0 2A        	BCS	LAB_EXCH		; exit if >"f" or <"0"
00DE7B  2               
00DE7B  2  69 0A        	ADC	#$0A			; convert to nibble
00DE7D  2               LAB_ISHN
00DE7D  2  29 0F        	AND	#$0F			; convert to binary
00DE7F  2  AA           	TAX				; save nibble
00DE80  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00DE82  2  F0 E4        	BEQ	LAB_MLTE		; skip multiply if zero
00DE84  2               
00DE84  2  69 04        	ADC	#$04			; add four to exponent (*16 - carry clear here)
00DE86  2  90 DC        	BCC	LAB_NLTO		; if no overflow do evaluate digit
00DE88  2               
00DE88  2               LAB_MLTO
00DE88  2  4C C3 D6     	JMP	LAB_2564		; do overflow error and warm start
00DE8B  2               
00DE8B  2               LAB_NXCH
00DE8B  2  AA           	TAX				; save bit
00DE8C  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00DE8E  2  F0 06        	BEQ	LAB_MLBT		; skip multiply if zero
00DE90  2               
00DE90  2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*2)
00DE92  2  F0 F4        	BEQ	LAB_MLTO		; do overflow error if = $00
00DE94  2               
00DE94  2  A9 00        	LDA	#$00			; clear sign compare
00DE96  2               LAB_MLBT
00DE96  2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
00DE98  2  8A           	TXA				; restore bit
00DE99  2  20 45 DA     	JSR	LAB_2912		; evaluate new ASCII digit
00DE9C  2               
00DE9C  2               ; gets here if the first character was  "%" for binary
00DE9C  2               ; get binary number
00DE9C  2               
00DE9C  2               LAB_CBIN
00DE9C  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00DE9F  2  49 30        	EOR	#'0'			; convert "0" to 0 etc.
00DEA1  2  C9 02        	CMP	#$02			; compare with max+1
00DEA3  2  90 E6        	BCC	LAB_NXCH		; branch exit if < 2
00DEA5  2               
00DEA5  2               LAB_EXCH
00DEA5  2  4C 2A DA     	JMP	LAB_28F6		; evaluate -ve flag and return
00DEA8  2               
00DEA8  2               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
00DEA8  2               ; now also the code that checks to see if an interrupt has occurred
00DEA8  2               
00DEA8  2               CTRLC
00DEA8  2  AD 00 02     	LDA	ccflag		; get [CTRL-C] check flag
00DEAB  2  D0 18        	BNE	LAB_FBA2		; exit if inhibited
00DEAD  2               
00DEAD  2  20 EA E0     	JSR	V_INPT		; scan input device
00DEB0  2  90 0B        	BCC	LAB_FBA0		; exit if buffer empty
00DEB2  2               
00DEB2  2  8D 01 02     	STA	ccbyte		; save received byte
00DEB5  2  A2 20        	LDX	#$20			; "life" timer for bytes
00DEB7  2  8E 02 02     	STX	ccnull		; set countdown
00DEBA  2  4C 17 C5     	JMP	LAB_1636		; return to BASIC
00DEBD  2               
00DEBD  2               LAB_FBA0
00DEBD  2  AE 02 02     	LDX	ccnull		; get countdown byte
00DEC0  2  F0 03        	BEQ	LAB_FBA2		; exit if finished
00DEC2  2               
00DEC2  2  CE 02 02     	DEC	ccnull		; else decrement countdown
00DEC5  2               LAB_FBA2
00DEC5  2  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
00DEC7  2  20 D0 DE     	JSR	LAB_CKIN		; go check interrupt
00DECA  2  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
00DECC  2  20 D0 DE     	JSR	LAB_CKIN		; go check interrupt
00DECF  2               LAB_CRTS
00DECF  2  60           	RTS
00DED0  2               
00DED0  2               ; check whichever interrupt is indexed by X
00DED0  2               
00DED0  2               LAB_CKIN
00DED0  2  B5 00        	LDA	PLUS_0,X		; get interrupt flag byte
00DED2  2  10 FB        	BPL	LAB_CRTS		; branch if interrupt not enabled
00DED4  2               
00DED4  2               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
00DED4  2               ; automatically enable the interrupt when we exit
00DED4  2               
00DED4  2  0A           	ASL				; move happened bit to setup bit
00DED5  2  29 40        	AND	#$40			; mask happened bits
00DED7  2  F0 F6        	BEQ	LAB_CRTS		; if no interrupt then exit
00DED9  2               
00DED9  2  95 00        	STA	PLUS_0,X		; save interrupt flag byte
00DEDB  2               
00DEDB  2  8A           	TXA				; copy index ..
00DEDC  2  A8           	TAY				; .. to Y
00DEDD  2               
00DEDD  2  68           	PLA				; dump return address low byte, call from CTRL-C
00DEDE  2  68           	PLA				; dump return address high byte
00DEDF  2               
00DEDF  2  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
00DEE1  2  20 03 C1     	JSR	LAB_1212		; check room on stack for A bytes
00DEE4  2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00DEE6  2  48           	PHA				; push on stack
00DEE7  2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00DEE9  2  48           	PHA				; push on stack
00DEEA  2  A5 88        	LDA	Clineh		; get current line high byte
00DEEC  2  48           	PHA				; push on stack
00DEED  2  A5 87        	LDA	Clinel		; get current line low byte
00DEEF  2  48           	PHA				; push on stack
00DEF0  2  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
00DEF2  2  48           	PHA				; push on stack
00DEF3  2               
00DEF3  2  B9 01 00     	LDA	PLUS_1,Y		; get interrupt code pointer low byte
00DEF6  2  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
00DEF8  2  B9 02 00     	LDA	PLUS_2,Y		; get interrupt code pointer high byte
00DEFB  2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
00DEFD  2               
00DEFD  2  4C BC C4     	JMP	LAB_15C2		; go do interpreter inner loop
00DF00  2               					; can't RTS, we used the stack! the RTS from the ctrl-c
00DF00  2               					; check will be taken when the RETIRQ/RETNMI/RETURN is
00DF00  2               					; executed at the end of the subroutine
00DF00  2               
00DF00  2               ; get byte from input device, no waiting
00DF00  2               ; returns with carry set if byte in A
00DF00  2               
00DF00  2               INGET
00DF00  2  20 EA E0     	JSR	V_INPT		; call scan input device
00DF03  2  B0 09        	BCS	LAB_FB95		; if byte go reset timer
00DF05  2               
00DF05  2  AD 02 02     	LDA	ccnull		; get countdown
00DF08  2  F0 09        	BEQ	LAB_FB96		; exit if empty
00DF0A  2               
00DF0A  2  AD 01 02     	LDA	ccbyte		; get last received byte
00DF0D  2  38           	SEC				; flag we got a byte
00DF0E  2               LAB_FB95
00DF0E  2  A2 00        	LDX	#$00			; clear X
00DF10  2  8E 02 02     	STX	ccnull		; clear timer because we got a byte
00DF13  2               LAB_FB96
00DF13  2  60           	RTS
00DF14  2               
00DF14  2               ; these routines only enable the interrupts if the set-up flag is set
00DF14  2               ; if not they have no effect
00DF14  2               
00DF14  2               ; perform IRQ {ON|OFF|CLEAR}
00DF14  2               
00DF14  2               LAB_IRQ
00DF14  2  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
00DF16  2  2C           	.byte	$2C			; make next line BIT abs.
00DF17  2               
00DF17  2               ; perform NMI {ON|OFF|CLEAR}
00DF17  2               
00DF17  2               LAB_NMI
00DF17  2  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
00DF19  2  C9 93        	CMP	#TK_ON		; compare with token for ON
00DF1B  2  F0 11        	BEQ	LAB_INON		; go turn on interrupt
00DF1D  2               
00DF1D  2  C9 B5        	CMP	#TK_OFF		; compare with token for OFF
00DF1F  2  F0 07        	BEQ	LAB_IOFF		; go turn off interrupt
00DF21  2               
00DF21  2  49 A2        	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
00DF23  2  F0 0E        	BEQ	LAB_INEX		; go clear interrupt flags and return
00DF25  2               
00DF25  2  4C 02 CC     	JMP	LAB_SNER		; do syntax error then warm start
00DF28  2               
00DF28  2               LAB_IOFF
00DF28  2  A9 7F        	LDA	#$7F			; clear A
00DF2A  2  35 00        	AND	PLUS_0,X		; AND with interrupt setup flag
00DF2C  2  10 05        	BPL	LAB_INEX		; go clear interrupt enabled flag and return
00DF2E  2               
00DF2E  2               LAB_INON
00DF2E  2  B5 00        	LDA	PLUS_0,X		; get interrupt setup flag
00DF30  2  0A           	ASL				; Shift bit to enabled flag
00DF31  2  15 00        	ORA	PLUS_0,X		; OR with flag byte
00DF33  2               LAB_INEX
00DF33  2  95 00        	STA	PLUS_0,X		; save interrupt flag byte
00DF35  2  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer and return
00DF38  2               
00DF38  2               ; these routines set up the pointers and flags for the interrupt routines
00DF38  2               ; note that the interrupts are also enabled by these commands
00DF38  2               
00DF38  2               ; perform ON IRQ
00DF38  2               
00DF38  2               LAB_SIRQ
00DF38  2  58           	CLI				; enable interrupts
00DF39  2  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
00DF3B  2  2C           	.byte	$2C			; make next line BIT abs.
00DF3C  2               
00DF3C  2               ; perform ON NMI
00DF3C  2               
00DF3C  2               LAB_SNMI
00DF3C  2  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
00DF3E  2               
00DF3E  2  86 78        	STX	TempB			; save interrupt pointer
00DF40  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (past token)
00DF43  2  20 55 C7     	JSR	LAB_GFPN		; get fixed-point number into temp integer
00DF46  2  A5 79        	LDA	Smeml			; get start of mem low byte
00DF48  2  A6 7A        	LDX	Smemh			; get start of mem high byte
00DF4A  2  20 28 C3     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
00DF4D  2  B0 03        	BCS	LAB_LFND		; if carry set go set-up interrupt
00DF4F  2               
00DF4F  2  4C 72 C6     	JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
00DF52  2               
00DF52  2               LAB_LFND
00DF52  2  A6 78        	LDX	TempB			; get interrupt pointer
00DF54  2  A5 AA        	LDA	Baslnl		; get pointer low byte
00DF56  2  E9 01        	SBC	#$01			; -1 (carry already set for subtract)
00DF58  2  95 01        	STA	PLUS_1,X		; save as interrupt pointer low byte
00DF5A  2  A5 AB        	LDA	Baslnh		; get pointer high byte
00DF5C  2  E9 00        	SBC	#$00			; subtract carry
00DF5E  2  95 02        	STA	PLUS_2,X		; save as interrupt pointer high byte
00DF60  2               
00DF60  2  A9 C0        	LDA	#$C0			; set interrupt enabled/setup bits
00DF62  2  95 00        	STA	PLUS_0,X		; set interrupt flags
00DF64  2               LAB_IRTS
00DF64  2  60           	RTS
00DF65  2               
00DF65  2               ; return from IRQ service, restores the enabled flag.
00DF65  2               
00DF65  2               ; perform RETIRQ
00DF65  2               
00DF65  2               LAB_RETIRQ
00DF65  2  D0 FD        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
00DF67  2               
00DF67  2  A5 DF        	LDA	IrqBase		; get interrupt flags
00DF69  2  0A           	ASL				; copy setup to enabled (b7)
00DF6A  2  05 DF        	ORA	IrqBase		; OR in setup flag
00DF6C  2  85 DF        	STA	IrqBase		; save enabled flag
00DF6E  2  4C 79 C6     	JMP	LAB_16E8		; go do rest of RETURN
00DF71  2               
00DF71  2               ; return from NMI service, restores the enabled flag.
00DF71  2               
00DF71  2               ; perform RETNMI
00DF71  2               
00DF71  2               LAB_RETNMI
00DF71  2  D0 F1        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
00DF73  2               
00DF73  2  A5 DC        	LDA	NmiBase		; get set-up flag
00DF75  2  0A           	ASL				; copy setup to enabled (b7)
00DF76  2  05 DC        	ORA	NmiBase		; OR in setup flag
00DF78  2  85 DC        	STA	NmiBase		; save enabled flag
00DF7A  2  4C 79 C6     	JMP	LAB_16E8		; go do rest of RETURN
00DF7D  2               
00DF7D  2               ; MAX() MIN() pre process
00DF7D  2               
00DF7D  2               LAB_MMPP
00DF7D  2  20 E9 CA     	JSR	LAB_EVEZ		; process expression
00DF80  2  4C D0 CA     	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
00DF83  2               
00DF83  2               ; perform MAX()
00DF83  2               
00DF83  2               LAB_MAX
00DF83  2  20 B1 DF     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
00DF86  2               					; pull FAC2 and compare with FAC1
00DF86  2  10 FB        	BPL	LAB_MAX		; branch if no swap to do
00DF88  2               
00DF88  2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
00DF8A  2  09 80        	ORA	#$80			; set top bit (clear sign from compare)
00DF8C  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00DF8E  2  20 C3 D5     	JSR	LAB_279B		; copy FAC2 to FAC1
00DF91  2  F0 F0        	BEQ	LAB_MAX		; go do next (branch always)
00DF93  2               
00DF93  2               ; perform MIN()
00DF93  2               
00DF93  2               LAB_MIN
00DF93  2  20 B1 DF     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
00DF96  2               					; pull FAC2 and compare with FAC1
00DF96  2  30 FB        	BMI	LAB_MIN		; branch if no swap to do
00DF98  2               
00DF98  2  F0 F9        	BEQ	LAB_MIN		; branch if no swap to do
00DF9A  2               
00DF9A  2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
00DF9C  2  09 80        	ORA	#$80			; set top bit (clear sign from compare)
00DF9E  2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
00DFA0  2  20 C3 D5     	JSR	LAB_279B		; copy FAC2 to FAC1
00DFA3  2  F0 EE        	BEQ	LAB_MIN		; go do next (branch always)
00DFA5  2               
00DFA5  2               ; exit routine. don't bother returning to the loop code
00DFA5  2               ; check for correct exit, else so syntax error
00DFA5  2               
00DFA5  2               LAB_MMEC
00DFA5  2  C9 29        	CMP	#')'			; is it end of function?
00DFA7  2  D0 05        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
00DFA9  2               
00DFA9  2  68           	PLA				; dump return address low byte
00DFAA  2  68           	PLA				; dump return address high byte
00DFAB  2  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
00DFAE  2               
00DFAE  2               LAB_MMSE
00DFAE  2  4C 02 CC     	JMP	LAB_SNER		; do syntax error then warm start
00DFB1  2               
00DFB1  2               ; check for next, evaluate and return or exit
00DFB1  2               ; this is the routine that does most of the work
00DFB1  2               
00DFB1  2               LAB_PHFA
00DFB1  2  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
00DFB4  2  C9 2C        	CMP	#','			; is there more ?
00DFB6  2  D0 ED        	BNE	LAB_MMEC		; if not go do end check
00DFB8  2               
00DFB8  2               					; push FAC1
00DFB8  2  20 D9 D8     	JSR	LAB_27BA		; round FAC1
00DFBB  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign
00DFBD  2  09 7F        	ORA	#$7F			; set all non sign bits
00DFBF  2  25 AD        	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
00DFC1  2  48           	PHA				; push on stack
00DFC2  2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
00DFC4  2  48           	PHA				; push on stack
00DFC5  2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00DFC7  2  48           	PHA				; push on stack
00DFC8  2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
00DFCA  2  48           	PHA				; push on stack
00DFCB  2               
00DFCB  2  20 BC 00     	JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
00DFCE  2  20 CD CA     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00DFD1  2               					; else do type mismatch
00DFD1  2               
00DFD1  2               					; pop FAC2 (MAX/MIN expression so far)
00DFD1  2  68           	PLA				; pop exponent
00DFD2  2  85 B3        	STA	FAC2_e		; save FAC2 exponent
00DFD4  2  68           	PLA				; pop mantissa3
00DFD5  2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
00DFD7  2  68           	PLA				; pop mantissa1
00DFD8  2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00DFDA  2  68           	PLA				; pop sign/mantissa1
00DFDB  2  85 B4        	STA	FAC2_1		; save FAC2 sign/mantissa1
00DFDD  2  85 B7        	STA	FAC2_s		; save FAC2 sign
00DFDF  2               
00DFDF  2               					; compare FAC1 with (packed) FAC2
00DFDF  2  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
00DFE1  2  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
00DFE3  2  4C 17 D9     	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
00DFE6  2               					; returns A=$00 if FAC1 = (AY)
00DFE6  2               					; returns A=$01 if FAC1 > (AY)
00DFE6  2               					; returns A=$FF if FAC1 < (AY)
00DFE6  2               
00DFE6  2               ; perform WIDTH
00DFE6  2               
00DFE6  2               LAB_WDTH
00DFE6  2  C9 2C        	CMP	#','			; is next byte ","
00DFE8  2  F0 1B        	BEQ	LAB_TBSZ		; if so do tab size
00DFEA  2               
00DFEA  2  20 8C D4     	JSR	LAB_GTBY		; get byte parameter
00DFED  2  8A           	TXA				; copy width to A
00DFEE  2  F0 0A        	BEQ	LAB_NSTT		; branch if set for infinite line
00DFF0  2               
00DFF0  2  E0 10        	CPX	#$10			; else make min width = 16d
00DFF2  2  90 45        	BCC	TabErr		; if less do function call error and exit
00DFF4  2               
00DFF4  2               ; this next compare ensures that we can't exit WIDTH via an error leaving the
00DFF4  2               ; tab size greater than the line length.
00DFF4  2               
00DFF4  2  E4 64        	CPX	TabSiz		; compare with tab size
00DFF6  2  B0 02        	BCS	LAB_NSTT		; branch if >= tab size
00DFF8  2               
00DFF8  2  86 64        	STX	TabSiz		; else make tab size = terminal width
00DFFA  2               LAB_NSTT
00DFFA  2  86 0F        	STX	TWidth		; set the terminal width
00DFFC  2  20 C2 00     	JSR	LAB_GBYT		; get BASIC byte back
00DFFF  2  F0 1A        	BEQ	WExit			; exit if no following
00E001  2               
00E001  2  C9 2C        	CMP	#','			; else is it ","
00E003  2  D0 A9        	BNE	LAB_MMSE		; if not do syntax error
00E005  2               
00E005  2               LAB_TBSZ
00E005  2  20 89 D4     	JSR	LAB_SGBY		; scan and get byte parameter
00E008  2  8A           	TXA				; copy TAB size
00E009  2  30 2E        	BMI	TabErr		; if >127 do function call error and exit
00E00B  2               
00E00B  2  E0 01        	CPX	#$01			; compare with min-1
00E00D  2  90 2A        	BCC	TabErr		; if <=1 do function call error and exit
00E00F  2               
00E00F  2  A5 0F        	LDA	TWidth		; set flags for width
00E011  2  F0 06        	BEQ	LAB_SVTB		; skip check if infinite line
00E013  2               
00E013  2  E4 0F        	CPX	TWidth		; compare TAB with width
00E015  2  F0 02        	BEQ	LAB_SVTB		; ok if =
00E017  2               
00E017  2  B0 20        	BCS	TabErr		; branch if too big
00E019  2               
00E019  2               LAB_SVTB
00E019  2  86 64        	STX	TabSiz		; save TAB size
00E01B  2               
00E01B  2               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
00E01B  2               ; position on a line that still has at least one whole tab width between it
00E01B  2               ; and the end of the line.
00E01B  2               
00E01B  2               WExit
00E01B  2  A5 0F        	LDA	TWidth		; get width
00E01D  2  F0 06        	BEQ	LAB_SULP		; branch if infinite line
00E01F  2               
00E01F  2  C5 64        	CMP	TabSiz		; compare with tab size
00E021  2  B0 03        	BCS	LAB_WDLP		; branch if >= tab size
00E023  2               
00E023  2  85 64        	STA	TabSiz		; else make tab size = terminal width
00E025  2               LAB_SULP
00E025  2  38           	SEC				; set carry for subtract
00E026  2               LAB_WDLP
00E026  2  E5 64        	SBC	TabSiz		; subtract tab size
00E028  2  B0 FC        	BCS	LAB_WDLP		; loop while no borrow
00E02A  2               
00E02A  2  65 64        	ADC	TabSiz		; add tab size back
00E02C  2  18           	CLC				; clear carry for add
00E02D  2  65 64        	ADC	TabSiz		; add tab size back again
00E02F  2  85 10        	STA	Iclim			; save for now
00E031  2  A5 0F        	LDA	TWidth		; get width back
00E033  2  38           	SEC				; set carry for subtract
00E034  2  E5 10        	SBC	Iclim			; subtract remainder
00E036  2  85 10        	STA	Iclim			; save tab column limit
00E038  2               LAB_NOSQ
00E038  2  60           	RTS
00E039  2               
00E039  2               TabErr
00E039  2  4C 29 CF     	JMP	LAB_FCER		; do function call error then warm start
00E03C  2               
00E03C  2               ; perform SQR()
00E03C  2               
00E03C  2               LAB_SQR
00E03C  2  A5 B0        	LDA	FAC1_s		; get FAC1 sign
00E03E  2  30 F9        	BMI	TabErr		; if -ve do function call error
00E040  2               
00E040  2  A5 AC        	LDA	FAC1_e		; get exponent
00E042  2  F0 F4        	BEQ	LAB_NOSQ		; if zero just return
00E044  2               
00E044  2               					; else do root
00E044  2  20 CA D8     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
00E047  2  A9 00        	LDA	#$00			; clear A
00E049  2               
00E049  2  85 77        	STA	FACt_3		; clear remainder
00E04B  2  85 76        	STA	FACt_2		; ..
00E04D  2  85 75        	STA	FACt_1		; ..
00E04F  2  85 78        	STA	TempB			; ..
00E051  2               
00E051  2  85 AF        	STA	FAC1_3		; clear root
00E053  2  85 AE        	STA	FAC1_2		; ..
00E055  2  85 AD        	STA	FAC1_1		; ..
00E057  2               
00E057  2  A2 18        	LDX	#$18			; 24 pairs of bits to do
00E059  2  A5 B3        	LDA	FAC2_e		; get exponent
00E05B  2  4A           	LSR				; check odd/even
00E05C  2  B0 0E        	BCS	LAB_SQE2		; if odd only 1 shift first time
00E05E  2               
00E05E  2               LAB_SQE1
00E05E  2  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
00E060  2  26 B5        	ROL	FAC2_2		; ..
00E062  2  26 B4        	ROL	FAC2_1		; ..
00E064  2  26 77        	ROL	FACt_3		; .. into remainder
00E066  2  26 76        	ROL	FACt_2		; ..
00E068  2  26 75        	ROL	FACt_1		; ..
00E06A  2  26 78        	ROL	TempB			; .. never overflows
00E06C  2               LAB_SQE2
00E06C  2  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
00E06E  2  26 B5        	ROL	FAC2_2		; ..
00E070  2  26 B4        	ROL	FAC2_1		; ..
00E072  2  26 77        	ROL	FACt_3		; .. into remainder
00E074  2  26 76        	ROL	FACt_2		; ..
00E076  2  26 75        	ROL	FACt_1		; ..
00E078  2  26 78        	ROL	TempB			; .. never overflows
00E07A  2               
00E07A  2  06 AF        	ASL	FAC1_3		; root = root * 2
00E07C  2  26 AE        	ROL	FAC1_2		; ..
00E07E  2  26 AD        	ROL	FAC1_1		; .. never overflows
00E080  2               
00E080  2  A5 AF        	LDA	FAC1_3		; get root low byte
00E082  2  2A           	ROL				; *2
00E083  2  85 5B        	STA	Temp3			; save partial low byte
00E085  2  A5 AE        	LDA	FAC1_2		; get root low mid byte
00E087  2  2A           	ROL				; *2
00E088  2  85 5C        	STA	Temp3+1		; save partial low mid byte
00E08A  2  A5 AD        	LDA	FAC1_1		; get root high mid byte
00E08C  2  2A           	ROL				; *2
00E08D  2  85 5D        	STA	Temp3+2		; save partial high mid byte
00E08F  2  A9 00        	LDA	#$00			; get root high byte (always $00)
00E091  2  2A           	ROL				; *2
00E092  2  85 5E        	STA	Temp3+3		; save partial high byte
00E094  2               
00E094  2               					; carry clear for subtract +1
00E094  2  A5 77        	LDA	FACt_3		; get remainder low byte
00E096  2  E5 5B        	SBC	Temp3			; subtract partial low byte
00E098  2  85 5B        	STA	Temp3			; save partial low byte
00E09A  2               
00E09A  2  A5 76        	LDA	FACt_2		; get remainder low mid byte
00E09C  2  E5 5C        	SBC	Temp3+1		; subtract partial low mid byte
00E09E  2  85 5C        	STA	Temp3+1		; save partial low mid byte
00E0A0  2               
00E0A0  2  A5 75        	LDA	FACt_1		; get remainder high mid byte
00E0A2  2  E5 5D        	SBC	Temp3+2		; subtract partial high mid byte
00E0A4  2  A8           	TAY				; copy partial high mid byte
00E0A5  2               
00E0A5  2  A5 78        	LDA	TempB			; get remainder high byte
00E0A7  2  E5 5E        	SBC	Temp3+3		; subtract partial high byte
00E0A9  2  90 0E        	BCC	LAB_SQNS		; skip sub if remainder smaller
00E0AB  2               
00E0AB  2  85 78        	STA	TempB			; save remainder high byte
00E0AD  2               
00E0AD  2  84 75        	STY	FACt_1		; save remainder high mid byte
00E0AF  2               
00E0AF  2  A5 5C        	LDA	Temp3+1		; get remainder low mid byte
00E0B1  2  85 76        	STA	FACt_2		; save remainder low mid byte
00E0B3  2               
00E0B3  2  A5 5B        	LDA	Temp3			; get partial low byte
00E0B5  2  85 77        	STA	FACt_3		; save remainder low byte
00E0B7  2               
00E0B7  2  E6 AF        	INC	FAC1_3		; increment root low byte (never any rollover)
00E0B9  2               LAB_SQNS
00E0B9  2  CA           	DEX				; decrement bit pair count
00E0BA  2  D0 A2        	BNE	LAB_SQE1		; loop if not all done
00E0BC  2               
00E0BC  2  38           	SEC				; set carry for subtract
00E0BD  2  A5 B3        	LDA	FAC2_e		; get exponent
00E0BF  2  E9 80        	SBC	#$80			; normalise
00E0C1  2  6A           	ROR				; /2 and re-bias to $80
00E0C2  2  69 00        	ADC	#$00			; add bit zero back in (allow for half shift)
00E0C4  2  85 AC        	STA	FAC1_e		; save it
00E0C6  2  4C 34 D6     	JMP	LAB_24D5		; normalise FAC1 and return
00E0C9  2               
00E0C9  2               ; perform VARPTR()
00E0C9  2               
00E0C9  2               LAB_VARPTR
00E0C9  2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00E0CC  2  20 AA CD     	JSR	LAB_GVAR		; get var address
00E0CF  2  20 EF CB     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
00E0D2  2  A4 95        	LDY	Cvaral		; get var address low byte
00E0D4  2  A5 96        	LDA	Cvarah		; get var address high byte
00E0D6  2  4C 59 D0     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00E0D9  2               
00E0D9  2               ; perform PI
00E0D9  2               
00E0D9  2               LAB_PI
00E0D9  2  A9 BB        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
00E0DB  2  A0 E1        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
00E0DD  2  20 7D D8     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
00E0E0  2  C6 AC        	DEC	FAC1_e		; make result = PI
00E0E2  2  60           	RTS
00E0E3  2               
00E0E3  2               ; perform TWOPI
00E0E3  2               
00E0E3  2               LAB_TWOPI
00E0E3  2  A9 BB        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
00E0E5  2  A0 E1        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
00E0E7  2  4C 7D D8     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
00E0EA  2               
00E0EA  2               ; system dependant i/o vectors
00E0EA  2               ; these are in RAM and are set by the monitor at start-up
00E0EA  2               
00E0EA  2               V_INPT
00E0EA  2  6C 05 02     	JMP	(VEC_IN)		; non halting scan input device
00E0ED  2               V_OUTP
00E0ED  2  6C 07 02     	JMP	(VEC_OUT)		; send byte to output device
00E0F0  2               V_LOAD
00E0F0  2  6C 09 02     	JMP	(VEC_LD)		; load BASIC program
00E0F3  2               V_SAVE
00E0F3  2  6C 0B 02     	JMP	(VEC_SV)		; save BASIC program
00E0F6  2               
00E0F6  2               ; The rest are tables messages and code for RAM
00E0F6  2               
00E0F6  2               ; the rest of the code is tables and BASIC start-up code
00E0F6  2               
00E0F6  2               PG2_TABS
00E0F6  2  00           	.byte	$00			; ctrl-c flag		-	$00 = enabled
00E0F7  2  00           	.byte	$00			; ctrl-c byte		-	GET needs this
00E0F8  2  00           	.byte	$00			; ctrl-c byte timeout	-	GET needs this
00E0F9  2  A8 DE        	.word	CTRLC			; ctrl c check vector
00E0FB  2               ;	.word	xxxx			; non halting key input	-	monitor to set this
00E0FB  2               ;	.word	xxxx			; output vector		-	monitor to set this
00E0FB  2               ;	.word	xxxx			; load vector		-	monitor to set this
00E0FB  2               ;	.word	xxxx			; save vector		-	monitor to set this
00E0FB  2               PG2_TABE
00E0FB  2               
00E0FB  2               ; character get subroutine for zero page
00E0FB  2               
00E0FB  2               ; For a 1.8432MHz 6502 including the JSR and RTS
00E0FB  2               ; fastest (>=":")	=  29 cycles =  15.7uS
00E0FB  2               ; slowest (<":")	=  40 cycles =  21.7uS
00E0FB  2               ; space skip	= +21 cycles = +11.4uS
00E0FB  2               ; inc across page	=  +4 cycles =  +2.2uS
00E0FB  2               
00E0FB  2               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
00E0FB  2               ; block is copied to it's destination, any non zero page address will do at assembly
00E0FB  2               ; time, to assemble a three byte instruction.
00E0FB  2               
00E0FB  2               ; page 0 initialisation table from $BC
00E0FB  2               ; increment and scan memory
00E0FB  2               
00E0FB  2               LAB_2CEE
00E0FB  2  E6 C3        	INC	Bpntrl		; increment BASIC execute pointer low byte
00E0FD  2  D0 02        	BNE	LAB_2CF4		; branch if no carry
00E0FF  2               					; else
00E0FF  2  E6 C4        	INC	Bpntrh		; increment BASIC execute pointer high byte
00E101  2               
00E101  2               ; page 0 initialisation table from $C2
00E101  2               ; scan memory
00E101  2               
00E101  2               LAB_2CF4
00E101  2  AD FF FF     	LDA	$FFFF			; get byte to scan (addr set by call routine)
00E104  2  C9 AC        	CMP	#TK_ELSE		; compare with the token for ELSE
00E106  2  F0 0E        	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
00E108  2               
00E108  2  C9 3A        	CMP	#':'			; compare with ":"
00E10A  2  B0 0A        	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
00E10C  2               
00E10C  2  C9 20        	CMP	#' '			; compare with " "
00E10E  2  F0 EB        	BEQ	LAB_2CEE		; if " " go do next
00E110  2               
00E110  2  38           	SEC				; set carry for SBC
00E111  2  E9 30        	SBC	#'0'			; subtract "0"
00E113  2  38           	SEC				; set carry for SBC
00E114  2  E9 D0        	SBC	#$D0			; subtract -"0"
00E116  2               					; clear carry if byte = "0"-"9"
00E116  2               LAB_2D05
00E116  2  60           	RTS
00E117  2               
00E117  2               ; page zero initialisation table $00-$12 inclusive
00E117  2               
00E117  2               StrTab
00E117  2  4C           	.byte	$4C			; JMP opcode
00E118  2  00 C0        	.word LAB_COLD		; initial warm start vector (cold start)
00E11A  2               
00E11A  2  00           	.byte	$00			; these bytes are not used by BASIC
00E11B  2  00 00        	.word	$0000			;
00E11D  2  00 00        	.word	$0000			;
00E11F  2  00 00        	.word	$0000			;
00E121  2               
00E121  2  4C           	.byte	$4C			; JMP opcode
00E122  2  29 CF        	.word	LAB_FCER		; initial user function vector ("Function call" error)
00E124  2  00           	.byte	$00			; default NULL count
00E125  2  00           	.byte	$00			; clear terminal position
00E126  2  00           	.byte	$00			; default terminal width byte
00E127  2  F2           	.byte	$F2			; default limit for TAB = 14
00E128  2  00 03        	.word	Ram_base		; start of user RAM
00E12A  2               EndTab
00E12A  2               
00E12A  2               LAB_MSZM
00E12A  2  0D 0A 4D 65  	.byte	$0D,$0A,"Memory size ",$00
00E12E  2  6D 6F 72 79  
00E132  2  20 73 69 7A  
00E139  2               
00E139  2               LAB_SMSG
00E139  2  20 42 79 74  	.byte	" Bytes free",$0D,$0A,$0A
00E13D  2  65 73 20 66  
00E141  2  72 65 65 0D  
00E147  2  45 6E 68 61  	.byte	"Enhanced BASIC 2.22",$0A,$00
00E14B  2  6E 63 65 64  
00E14F  2  20 42 41 53  
00E15C  2               
00E15C  2               ; numeric constants and series
00E15C  2               
00E15C  2               					; constants and series for LOG(n)
00E15C  2               LAB_25A0
00E15C  2  02           	.byte	$02			; counter
00E15D  2  80 19 56 62  	.byte	$80,$19,$56,$62	; 0.59898
00E161  2  80 76 22 F3  	.byte	$80,$76,$22,$F3	; 0.96147
00E165  2               ;##	.byte	$80,$76,$22,$F1	; 0.96147
00E165  2  82 38 AA 40  	.byte	$82,$38,$AA,$40	; 2.88539
00E169  2               ;##	.byte	$82,$38,$AA,$45	; 2.88539
00E169  2               
00E169  2               LAB_25AD
00E169  2  80 35 04 F3  	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
00E16D  2               LAB_25B1
00E16D  2  81 35 04 F3  	.byte	$81,$35,$04,$F3	; 1.41421	root 2
00E171  2               LAB_25B5
00E171  2  80 80 00 00  	.byte	$80,$80,$00,$00	; -0.5
00E175  2               LAB_25B9
00E175  2  80 31 72 18  	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
00E179  2               
00E179  2               					; numeric PRINT constants
00E179  2               LAB_2947
00E179  2  91 43 4F F8  	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
00E17D  2               LAB_294B
00E17D  2  94 74 23 F7  	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
00E181  2               LAB_294F
00E181  2  94 74 24 00  	.byte	$94,$74,$24,$00	; 1000000
00E185  2               
00E185  2               					; EXP(n) constants and series
00E185  2               LAB_2AFA
00E185  2  81 38 AA 3B  	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
00E189  2               LAB_2AFE
00E189  2  06           	.byte	$06			; counter
00E18A  2  74 63 90 8C  	.byte	$74,$63,$90,$8C	; 2.17023e-4
00E18E  2  77 23 0C AB  	.byte	$77,$23,$0C,$AB	; 0.00124
00E192  2  7A 1E 94 00  	.byte	$7A,$1E,$94,$00	; 0.00968
00E196  2  7C 63 42 80  	.byte	$7C,$63,$42,$80	; 0.05548
00E19A  2  7E 75 FE D0  	.byte	$7E,$75,$FE,$D0	; 0.24023
00E19E  2  80 31 72 15  	.byte	$80,$31,$72,$15	; 0.69315
00E1A2  2  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.00000
00E1A6  2               
00E1A6  2               ;##	.byte	$07			; counter
00E1A6  2               ;##	.byte	$74,$94,$2E,$40	; -1/7! (-1/5040)
00E1A6  2               ;##	.byte	$77,$2E,$4F,$70	;  1/6! ( 1/720)
00E1A6  2               ;##	.byte	$7A,$88,$02,$6E	; -1/5! (-1/120)
00E1A6  2               ;##	.byte	$7C,$2A,$A0,$E6	;  1/4! ( 1/24)
00E1A6  2               ;##	.byte	$7E,$AA,$AA,$50	; -1/3! (-1/6)
00E1A6  2               ;##	.byte	$7F,$7F,$FF,$FF	;  1/2! ( 1/2)
00E1A6  2               ;##	.byte	$81,$80,$00,$00	; -1/1! (-1/1)
00E1A6  2               ;##	.byte	$81,$00,$00,$00	;  1/0! ( 1/1)
00E1A6  2               
00E1A6  2               					; trigonometric constants and series
00E1A6  2               LAB_2C78
00E1A6  2  81 49 0F DB  	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
00E1AA  2               LAB_2C84
00E1AA  2  04           	.byte	$04			; counter
00E1AB  2  86 1E D7 FB  	.byte	$86,$1E,$D7,$FB	; 39.7109
00E1AF  2               ;##	.byte	$86,$1E,$D7,$BA	; 39.7109
00E1AF  2  87 99 26 65  	.byte	$87,$99,$26,$65	;-76.575
00E1B3  2               ;##	.byte	$87,$99,$26,$64	;-76.575
00E1B3  2  87 23 34 58  	.byte	$87,$23,$34,$58	; 81.6022
00E1B7  2  86 A5 5D E1  	.byte	$86,$A5,$5D,$E1	;-41.3417
00E1BB  2               ;##	.byte	$86,$A5,$5D,$E0	;-41.3417
00E1BB  2               LAB_2C7C
00E1BB  2  83 49 0F DB  	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
00E1BF  2               ;##	.byte	$83,$49,$0F,$DA	; 6.28319 (2*pi) as floating #
00E1BF  2               
00E1BF  2               LAB_2CC9
00E1BF  2  08           	.byte	$08			; counter
00E1C0  2  78 3A C5 37  	.byte	$78,$3A,$C5,$37	; 0.00285
00E1C4  2  7B 83 A2 5C  	.byte	$7B,$83,$A2,$5C	;-0.0160686
00E1C8  2  7C 2E DD 4D  	.byte	$7C,$2E,$DD,$4D	; 0.0426915
00E1CC  2  7D 99 B0 1E  	.byte	$7D,$99,$B0,$1E	;-0.0750429
00E1D0  2  7D 59 ED 24  	.byte	$7D,$59,$ED,$24	; 0.106409
00E1D4  2  7E 91 72 00  	.byte	$7E,$91,$72,$00	;-0.142036
00E1D8  2  7E 4C B9 73  	.byte	$7E,$4C,$B9,$73	; 0.199926
00E1DC  2  7F AA AA 53  	.byte	$7F,$AA,$AA,$53	;-0.333331
00E1E0  2               
00E1E0  2               ;##	.byte	$08			; counter
00E1E0  2               ;##	.byte	$78,$3B,$D7,$4A	; 1/17
00E1E0  2               ;##	.byte	$7B,$84,$6E,$02	;-1/15
00E1E0  2               ;##	.byte	$7C,$2F,$C1,$FE	; 1/13
00E1E0  2               ;##	.byte	$7D,$9A,$31,$74	;-1/11
00E1E0  2               ;##	.byte	$7D,$5A,$3D,$84	; 1/9
00E1E0  2               ;##	.byte	$7E,$91,$7F,$C8	;-1/7
00E1E0  2               ;##	.byte	$7E,$4C,$BB,$E4	; 1/5
00E1E0  2               ;##	.byte	$7F,$AA,$AA,$6C	;-1/3
00E1E0  2               
00E1E0  2               LAB_1D96	= *+1			; $00,$00 used for undefined variables
00E1E0  2               LAB_259C
00E1E0  2  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.000000, used for INC
00E1E4  2               LAB_2AFD
00E1E4  2  81 80 00 00  	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
00E1E8  2               
00E1E8  2               					; misc constants
00E1E8  2               LAB_1DF7
00E1E8  2  90           	.byte	$90			;-32768 (uses first three bytes from 0.5)
00E1E9  2               LAB_2A96
00E1E9  2  80 00 00 00  	.byte	$80,$00,$00,$00	; 0.5
00E1ED  2               LAB_2C80
00E1ED  2  7F 00 00 00  	.byte	$7F,$00,$00,$00	; 0.25
00E1F1  2               LAB_26B5
00E1F1  2  84 20 00 00  	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
00E1F5  2               
00E1F5  2               ; This table is used in converting numbers to ASCII.
00E1F5  2               
00E1F5  2               LAB_2A9A
00E1F5  2               LAB_2A9B = LAB_2A9A+1
00E1F5  2               LAB_2A9C = LAB_2A9B+1
00E1F5  2  FE 79 60     	.byte	$FE,$79,$60		; -100000
00E1F8  2  00 27 10     	.byte	$00,$27,$10		; 10000
00E1FB  2  FF FC 18     	.byte	$FF,$FC,$18		; -1000
00E1FE  2  00 00 64     	.byte	$00,$00,$64		; 100
00E201  2  FF FF F6     	.byte	$FF,$FF,$F6		; -10
00E204  2  00 00 01     	.byte	$00,$00,$01		; 1
00E207  2               
00E207  2               LAB_CTBL
00E207  2  1A C5        	.word	LAB_END-1		; END
00E209  2  57 C4        	.word	LAB_FOR-1		; FOR
00E20B  2  64 CA        	.word	LAB_NEXT-1		; NEXT
00E20D  2  8B C6        	.word	LAB_DATA-1		; DATA
00E20F  2  46 C9        	.word	LAB_INPUT-1		; INPUT
00E211  2  5E CD        	.word	LAB_DIM-1		; DIM
00E213  2  66 C9        	.word	LAB_READ-1		; READ
00E215  2  B3 C7        	.word	LAB_LET-1		; LET
00E217  2  85 C7        	.word	LAB_DEC-1		; DEC			new command
00E219  2  EA C5        	.word	LAB_GOTO-1		; GOTO
00E21B  2  A9 C5        	.word	LAB_RUN-1		; RUN
00E21D  2  B9 C6        	.word	LAB_IF-1		; IF
00E21F  2  41 C5        	.word	LAB_RESTORE-1	; RESTORE		modified command
00E221  2  CD C5        	.word	LAB_GOSUB-1		; GOSUB
00E223  2  64 DF        	.word	LAB_RETIRQ-1	; RETIRQ		new command
00E225  2  70 DF        	.word	LAB_RETNMI-1	; RETNMI		new command
00E227  2  76 C6        	.word	LAB_RETURN-1	; RETURN
00E229  2  1D C7        	.word	LAB_REM-1		; REM
00E22B  2  18 C5        	.word	LAB_STOP-1		; STOP
00E22D  2  26 C7        	.word	LAB_ON-1		; ON			modified command
00E22F  2  7F C5        	.word	LAB_NULL-1		; NULL		modified command
00E231  2  88 C7        	.word	LAB_INC-1		; INC			new command
00E233  2  88 D5        	.word	LAB_WAIT-1		; WAIT
00E235  2  EF E0        	.word	V_LOAD-1		; LOAD
00E237  2  F2 E0        	.word	V_SAVE-1		; SAVE
00E239  2  73 D0        	.word	LAB_DEF-1		; DEF
00E23B  2  0D D5        	.word	LAB_POKE-1		; POKE
00E23D  2  29 D5        	.word	LAB_DOKE-1		; DOKE		new command
00E23F  2  76 D5        	.word	LAB_CALL-1		; CALL		new command
00E241  2  B3 C5        	.word	LAB_DO-1		; DO			new command
00E243  2  1C C6        	.word	LAB_LOOP-1		; LOOP		new command
00E245  2  54 C8        	.word	LAB_PRINT-1		; PRINT
00E247  2  85 C5        	.word	LAB_CONT-1		; CONT
00E249  2  A2 C3        	.word	LAB_LIST-1		; LIST
00E24B  2  9F C3        	.word	LAB_CLEAR-1		; CLEAR
00E24D  2  4D C3        	.word	LAB_NEW-1		; NEW
00E24F  2  E5 DF        	.word	LAB_WDTH-1		; WIDTH		new command
00E251  2  23 C8        	.word	LAB_GET-1		; GET			new command
00E253  2  4E D5        	.word	LAB_SWAP-1		; SWAP		new command
00E255  2  81 DD        	.word	LAB_BITSET-1	; BITSET		new command
00E257  2  95 DD        	.word	LAB_BITCLR-1	; BITCLR		new command
00E259  2  13 DF        	.word	LAB_IRQ-1		; IRQ			new command
00E25B  2  16 DF        	.word	LAB_NMI-1		; NMI			new command
00E25D  2               
00E25D  2               ; function pre process routine table
00E25D  2               
00E25D  2               LAB_FTPL
00E25D  2               LAB_FTPM	= LAB_FTPL+$01
00E25D  2  64 CC        	.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
00E25F  2  64 CC        	.word	LAB_PPFN-1		; INT(n)		"
00E261  2  64 CC        	.word	LAB_PPFN-1		; ABS(n)		"
00E263  2  E8 CA        	.word	LAB_EVEZ-1		; USR(x)	process any expression
00E265  2  EB CB        	.word	LAB_1BF7-1		; FRE(x)		"
00E267  2  EB CB        	.word	LAB_1BF7-1		; POS(x)		"
00E269  2  64 CC        	.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
00E26B  2  64 CC        	.word	LAB_PPFN-1		; RND(n)		"
00E26D  2  64 CC        	.word	LAB_PPFN-1		; LOG(n)		"
00E26F  2  64 CC        	.word	LAB_PPFN-1		; EXP(n)		"
00E271  2  64 CC        	.word	LAB_PPFN-1		; COS(n)		"
00E273  2  64 CC        	.word	LAB_PPFN-1		; SIN(n)		"
00E275  2  64 CC        	.word	LAB_PPFN-1		; TAN(n)		"
00E277  2  64 CC        	.word	LAB_PPFN-1		; ATN(n)		"
00E279  2  64 CC        	.word	LAB_PPFN-1		; PEEK(n)		"
00E27B  2  64 CC        	.word	LAB_PPFN-1		; DEEK(n)		"
00E27D  2  00 00        	.word	$0000			; SADD()	none
00E27F  2  5E CC        	.word	LAB_PPFS-1		; LEN($)	process string expression in ()
00E281  2  64 CC        	.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
00E283  2  5E CC        	.word	LAB_PPFS-1		; VAL($)	process string expression in ()
00E285  2  5E CC        	.word	LAB_PPFS-1		; ASC($)		"
00E287  2  5E CC        	.word	LAB_PPFS-1		; UCASE$($)		"
00E289  2  5E CC        	.word	LAB_PPFS-1		; LCASE$($)		"
00E28B  2  64 CC        	.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
00E28D  2  8B CC        	.word	LAB_BHSS-1		; HEX$(n)		"
00E28F  2  8B CC        	.word	LAB_BHSS-1		; BIN$(n)		"
00E291  2  00 00        	.word	$0000			; BITTST()	none
00E293  2  7C DF        	.word	LAB_MMPP-1		; MAX()	process numeric expression
00E295  2  7C DF        	.word	LAB_MMPP-1		; MIN()		"
00E297  2  6A CC        	.word	LAB_PPBI-1		; PI		advance pointer
00E299  2  6A CC        	.word	LAB_PPBI-1		; TWOPI		"
00E29B  2  00 00        	.word	$0000			; VARPTR()	none
00E29D  2  6F CC        	.word	LAB_LRMS-1		; LEFT$()	process string expression
00E29F  2  6F CC        	.word	LAB_LRMS-1		; RIGHT$()		"
00E2A1  2  6F CC        	.word	LAB_LRMS-1		; MID$()		"
00E2A3  2               
00E2A3  2               ; action addresses for functions
00E2A3  2               
00E2A3  2               LAB_FTBL
00E2A3  2               LAB_FTBM	= LAB_FTBL+$01
00E2A3  2  F6 D8        	.word	LAB_SGN-1		; SGN()
00E2A5  2  80 D9        	.word	LAB_INT-1		; INT()
00E2A7  2  13 D9        	.word	LAB_ABS-1		; ABS()
00E2A9  2  4C DD        	.word	LAB_USR-1		; USR()
00E2AB  2  44 D0        	.word	LAB_FRE-1		; FRE()
00E2AD  2  63 D0        	.word	LAB_POS-1		; POS()
00E2AF  2  3B E0        	.word	LAB_SQR-1		; SQR()
00E2B1  2  9C DC        	.word	LAB_RND-1		; RND()		modified function
00E2B3  2  FA D6        	.word	LAB_LOG-1		; LOG()
00E2B5  2  FE DB        	.word	LAB_EXP-1		; EXP()
00E2B7  2  D0 DC        	.word	LAB_COS-1		; COS()
00E2B9  2  D7 DC        	.word	LAB_SIN-1		; SIN()
00E2BB  2  20 DD        	.word	LAB_TAN-1		; TAN()
00E2BD  2  52 DD        	.word	LAB_ATN-1		; ATN()
00E2BF  2  02 D5        	.word	LAB_PEEK-1		; PEEK()
00E2C1  2  16 D5        	.word	LAB_DEEK-1		; DEEK()		new function
00E2C3  2  54 D4        	.word	LAB_SADD-1		; SADD()		new function
00E2C5  2  6D D4        	.word	LAB_LENS-1		; LEN()
00E2C7  2  25 D1        	.word	LAB_STRS-1		; STR$()
00E2C9  2  9A D4        	.word	LAB_VAL-1		; VAL()
00E2CB  2  78 D4        	.word	LAB_ASC-1		; ASC()
00E2CD  2  32 D4        	.word	LAB_UCASE-1		; UCASE$()		new function
00E2CF  2  11 D4        	.word	LAB_LCASE-1		; LCASE$()		new function
00E2D1  2  83 D3        	.word	LAB_CHRS-1		; CHR$()
00E2D3  2  22 DE        	.word	LAB_HEXS-1		; HEX$()		new function
00E2D5  2  D3 DD        	.word	LAB_BINS-1		; BIN$()		new function
00E2D7  2  AB DD        	.word	LAB_BTST-1		; BITTST()		new function
00E2D9  2  82 DF        	.word	LAB_MAX-1		; MAX()		new function
00E2DB  2  92 DF        	.word	LAB_MIN-1		; MIN()		new function
00E2DD  2  D8 E0        	.word	LAB_PI-1		; PI			new function
00E2DF  2  E2 E0        	.word	LAB_TWOPI-1		; TWOPI		new function
00E2E1  2  C8 E0        	.word	LAB_VARPTR-1	; VARPTR()		new function
00E2E3  2  95 D3        	.word	LAB_LEFT-1		; LEFT$()
00E2E5  2  9E D3        	.word	LAB_RIGHT-1		; RIGHT$()
00E2E7  2  CD D3        	.word	LAB_MIDS-1		; MID$()
00E2E9  2               
00E2E9  2               ; hierarchy and action addresses for operator
00E2E9  2               
00E2E9  2               LAB_OPPT
00E2E9  2  79           	.byte	$79			; +
00E2EA  2  C0 D5        	.word	LAB_ADD-1
00E2EC  2  79           	.byte	$79			; -
00E2ED  2  A5 D5        	.word	LAB_SUBTRACT-1
00E2EF  2  7B           	.byte	$7B			; *
00E2F0  2  3B D7        	.word	LAB_MULTIPLY-1
00E2F2  2  7B           	.byte	$7B			; /
00E2F3  2  03 D8        	.word	LAB_DIVIDE-1
00E2F5  2  7F           	.byte	$7F			; ^
00E2F6  2  BA DB        	.word	LAB_POWER-1
00E2F8  2  50           	.byte	$50			; AND
00E2F9  2  D4 CC        	.word	LAB_AND-1
00E2FB  2  46           	.byte	$46			; EOR			new operator
00E2FC  2  BA CC        	.word	LAB_EOR-1
00E2FE  2  46           	.byte	$46			; OR
00E2FF  2  C7 CC        	.word	LAB_OR-1
00E301  2  56           	.byte	$56			; >>			new operator
00E302  2  80 CD        	.word	LAB_RSHIFT-1
00E304  2  56           	.byte	$56			; <<			new operator
00E305  2  68 CD        	.word	LAB_LSHIFT-1
00E307  2  7D           	.byte	$7D			; >
00E308  2  F3 DB        	.word	LAB_GTHAN-1
00E30A  2  5A           	.byte	$5A			; =
00E30B  2  16 CC        	.word	LAB_EQUAL-1
00E30D  2  64           	.byte	$64			; <
00E30E  2  F5 CC        	.word	LAB_LTHAN-1
00E310  2               
00E310  2               ; keywords start with ..
00E310  2               ; this is the first character table and must be in alphabetic order
00E310  2               
00E310  2               TAB_1STC
00E310  2  2A           	.byte	"*"
00E311  2  2B           	.byte	"+"
00E312  2  2D           	.byte	"-"
00E313  2  2F           	.byte	"/"
00E314  2  3C           	.byte	"<"
00E315  2  3D           	.byte	"="
00E316  2  3E           	.byte	">"
00E317  2  3F           	.byte	"?"
00E318  2  41           	.byte	"A"
00E319  2  42           	.byte	"B"
00E31A  2  43           	.byte	"C"
00E31B  2  44           	.byte	"D"
00E31C  2  45           	.byte	"E"
00E31D  2  46           	.byte	"F"
00E31E  2  47           	.byte	"G"
00E31F  2  48           	.byte	"H"
00E320  2  49           	.byte	"I"
00E321  2  4C           	.byte	"L"
00E322  2  4D           	.byte	"M"
00E323  2  4E           	.byte	"N"
00E324  2  4F           	.byte	"O"
00E325  2  50           	.byte	"P"
00E326  2  52           	.byte	"R"
00E327  2  53           	.byte	"S"
00E328  2  54           	.byte	"T"
00E329  2  55           	.byte	"U"
00E32A  2  56           	.byte	"V"
00E32B  2  57           	.byte	"W"
00E32C  2  5E           	.byte	"^"
00E32D  2  00           	.byte	$00			; table terminator
00E32E  2               
00E32E  2               ; pointers to keyword tables
00E32E  2               
00E32E  2               TAB_CHRT
00E32E  2  68 E3        	.word	TAB_STAR		; table for "*"
00E330  2  6A E3        	.word	TAB_PLUS		; table for "+"
00E332  2  6C E3        	.word	TAB_MNUS		; table for "-"
00E334  2  6E E3        	.word	TAB_SLAS		; table for "/"
00E336  2  70 E3        	.word	TAB_LESS		; table for "<"
00E338  2  74 E3        	.word	TAB_EQUL		; table for "="
00E33A  2  76 E3        	.word	TAB_MORE		; table for ">"
00E33C  2  7A E3        	.word	TAB_QEST		; table for "?"
00E33E  2  7C E3        	.word	TAB_ASCA		; table for "A"
00E340  2  8C E3        	.word	TAB_ASCB		; table for "B"
00E342  2  A5 E3        	.word	TAB_ASCC		; table for "C"
00E344  2  BC E3        	.word	TAB_ASCD		; table for "D"
00E346  2  D5 E3        	.word	TAB_ASCE		; table for "E"
00E348  2  E4 E3        	.word	TAB_ASCF		; table for "F"
00E34A  2  EE E3        	.word	TAB_ASCG		; table for "G"
00E34C  2  FB E3        	.word	TAB_ASCH		; table for "H"
00E34E  2  01 E4        	.word	TAB_ASCI		; table for "I"
00E350  2  13 E4        	.word	TAB_ASCL		; table for "L"
00E352  2  38 E4        	.word	TAB_ASCM		; table for "M"
00E354  2  46 E4        	.word	TAB_ASCN		; table for "N"
00E356  2  58 E4        	.word	TAB_ASCO		; table for "O"
00E358  2  60 E4        	.word	TAB_ASCP		; table for "P"
00E35A  2  75 E4        	.word	TAB_ASCR		; table for "R"
00E35C  2  A4 E4        	.word	TAB_ASCS		; table for "S"
00E35E  2  CF E4        	.word	TAB_ASCT		; table for "T"
00E360  2  E3 E4        	.word	TAB_ASCU		; table for "U"
00E362  2  F4 E4        	.word	TAB_ASCV		; table for "V"
00E364  2  00 E5        	.word	TAB_ASCW		; table for "W"
00E366  2  0F E5        	.word	TAB_POWR		; table for "^"
00E368  2               
00E368  2               ; tables for each start character, note if a longer keyword with the same start
00E368  2               ; letters as a shorter one exists then it must come first, else the list is in
00E368  2               ; alphabetical order as follows ..
00E368  2               
00E368  2               ; [keyword,token
00E368  2               ; [keyword,token]]
00E368  2               ; end marker (#$00)
00E368  2               
00E368  2               TAB_STAR
00E368  2  B8 00        	.byte TK_MUL,$00		; *
00E36A  2               TAB_PLUS
00E36A  2  B6 00        	.byte TK_PLUS,$00		; +
00E36C  2               TAB_MNUS
00E36C  2  B7 00        	.byte TK_MINUS,$00	; -
00E36E  2               TAB_SLAS
00E36E  2  B9 00        	.byte TK_DIV,$00		; /
00E370  2               TAB_LESS
00E370  2               LBB_LSHIFT
00E370  2  3C BF        	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
00E372  2  C2           	.byte TK_LT			; <
00E373  2  00           	.byte	$00
00E374  2               TAB_EQUL
00E374  2  C1 00        	.byte TK_EQUAL,$00	; =
00E376  2               TAB_MORE
00E376  2               LBB_RSHIFT
00E376  2  3E BE        	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
00E378  2  C0           	.byte TK_GT			; >
00E379  2  00           	.byte	$00
00E37A  2               TAB_QEST
00E37A  2  9F 00        	.byte TK_PRINT,$00	; ?
00E37C  2               TAB_ASCA
00E37C  2               LBB_ABS
00E37C  2  42 53 28 C5  	.byte	"BS(",TK_ABS	; ABS(
00E380  2               LBB_AND
00E380  2  4E 44 BB     	.byte	"ND",TK_AND		; AND
00E383  2               LBB_ASC
00E383  2  53 43 28 D7  	.byte	"SC(",TK_ASC	; ASC(
00E387  2               LBB_ATN
00E387  2  54 4E 28 D0  	.byte	"TN(",TK_ATN	; ATN(
00E38B  2  00           	.byte	$00
00E38C  2               TAB_ASCB
00E38C  2               LBB_BINS
00E38C  2  49 4E 24 28  	.byte	"IN$(",TK_BINS	; BIN$(
00E390  2  DC           
00E391  2               LBB_BITCLR
00E391  2  49 54 43 4C  	.byte	"ITCLR",TK_BITCLR	; BITCLR
00E395  2  52 A8        
00E397  2               LBB_BITSET
00E397  2  49 54 53 45  	.byte	"ITSET",TK_BITSET	; BITSET
00E39B  2  54 A7        
00E39D  2               LBB_BITTST
00E39D  2  49 54 54 53  	.byte	"ITTST(",TK_BITTST
00E3A1  2  54 28 DD     
00E3A4  2               					; BITTST(
00E3A4  2  00           	.byte	$00
00E3A5  2               TAB_ASCC
00E3A5  2               LBB_CALL
00E3A5  2  41 4C 4C 9C  	.byte	"ALL",TK_CALL	; CALL
00E3A9  2               LBB_CHRS
00E3A9  2  48 52 24 28  	.byte	"HR$(",TK_CHRS	; CHR$(
00E3AD  2  DA           
00E3AE  2               LBB_CLEAR
00E3AE  2  4C 45 41 52  	.byte	"LEAR",TK_CLEAR	; CLEAR
00E3B2  2  A2           
00E3B3  2               LBB_CONT
00E3B3  2  4F 4E 54 A0  	.byte	"ONT",TK_CONT	; CONT
00E3B7  2               LBB_COS
00E3B7  2  4F 53 28 CD  	.byte	"OS(",TK_COS	; COS(
00E3BB  2  00           	.byte	$00
00E3BC  2               TAB_ASCD
00E3BC  2               LBB_DATA
00E3BC  2  41 54 41 83  	.byte	"ATA",TK_DATA	; DATA
00E3C0  2               LBB_DEC
00E3C0  2  45 43 88     	.byte	"EC",TK_DEC		; DEC
00E3C3  2               LBB_DEEK
00E3C3  2  45 45 4B 28  	.byte	"EEK(",TK_DEEK	; DEEK(
00E3C7  2  D2           
00E3C8  2               LBB_DEF
00E3C8  2  45 46 99     	.byte	"EF",TK_DEF		; DEF
00E3CB  2               LBB_DIM
00E3CB  2  49 4D 85     	.byte	"IM",TK_DIM		; DIM
00E3CE  2               LBB_DOKE
00E3CE  2  4F 4B 45 9B  	.byte	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
00E3D2  2               LBB_DO
00E3D2  2  4F 9D        	.byte	"O",TK_DO		; DO
00E3D4  2  00           	.byte	$00
00E3D5  2               TAB_ASCE
00E3D5  2               LBB_ELSE
00E3D5  2  4C 53 45 AC  	.byte	"LSE",TK_ELSE	; ELSE
00E3D9  2               LBB_END
00E3D9  2  4E 44 80     	.byte	"ND",TK_END		; END
00E3DC  2               LBB_EOR
00E3DC  2  4F 52 BC     	.byte	"OR",TK_EOR		; EOR
00E3DF  2               LBB_EXP
00E3DF  2  58 50 28 CC  	.byte	"XP(",TK_EXP	; EXP(
00E3E3  2  00           	.byte	$00
00E3E4  2               TAB_ASCF
00E3E4  2               LBB_FN
00E3E4  2  4E AE        	.byte	"N",TK_FN		; FN
00E3E6  2               LBB_FOR
00E3E6  2  4F 52 81     	.byte	"OR",TK_FOR		; FOR
00E3E9  2               LBB_FRE
00E3E9  2  52 45 28 C7  	.byte	"RE(",TK_FRE	; FRE(
00E3ED  2  00           	.byte	$00
00E3EE  2               TAB_ASCG
00E3EE  2               LBB_GET
00E3EE  2  45 54 A5     	.byte	"ET",TK_GET		; GET
00E3F1  2               LBB_GOSUB
00E3F1  2  4F 53 55 42  	.byte	"OSUB",TK_GOSUB	; GOSUB
00E3F5  2  8D           
00E3F6  2               LBB_GOTO
00E3F6  2  4F 54 4F 89  	.byte	"OTO",TK_GOTO	; GOTO
00E3FA  2  00           	.byte	$00
00E3FB  2               TAB_ASCH
00E3FB  2               LBB_HEXS
00E3FB  2  45 58 24 28  	.byte	"EX$(",TK_HEXS	; HEX$(
00E3FF  2  DB           
00E400  2  00           	.byte	$00
00E401  2               TAB_ASCI
00E401  2               LBB_IF
00E401  2  46 8B        	.byte	"F",TK_IF		; IF
00E403  2               LBB_INC
00E403  2  4E 43 95     	.byte	"NC",TK_INC		; INC
00E406  2               LBB_INPUT
00E406  2  4E 50 55 54  	.byte	"NPUT",TK_INPUT	; INPUT
00E40A  2  84           
00E40B  2               LBB_INT
00E40B  2  4E 54 28 C4  	.byte	"NT(",TK_INT	; INT(
00E40F  2               LBB_IRQ
00E40F  2  52 51 A9     	.byte	"RQ",TK_IRQ		; IRQ
00E412  2  00           	.byte	$00
00E413  2               TAB_ASCL
00E413  2               LBB_LCASES
00E413  2  43 41 53 45  	.byte	"CASE$(",TK_LCASES
00E417  2  24 28 D9     
00E41A  2               					; LCASE$(
00E41A  2               LBB_LEFTS
00E41A  2  45 46 54 24  	.byte	"EFT$(",TK_LEFTS	; LEFT$(
00E41E  2  28 E3        
00E420  2               LBB_LEN
00E420  2  45 4E 28 D4  	.byte	"EN(",TK_LEN	; LEN(
00E424  2               LBB_LET
00E424  2  45 54 87     	.byte	"ET",TK_LET		; LET
00E427  2               LBB_LIST
00E427  2  49 53 54 A1  	.byte	"IST",TK_LIST	; LIST
00E42B  2               LBB_LOAD
00E42B  2  4F 41 44 97  	.byte	"OAD",TK_LOAD	; LOAD
00E42F  2               LBB_LOG
00E42F  2  4F 47 28 CB  	.byte	"OG(",TK_LOG	; LOG(
00E433  2               LBB_LOOP
00E433  2  4F 4F 50 9E  	.byte	"OOP",TK_LOOP	; LOOP
00E437  2  00           	.byte	$00
00E438  2               TAB_ASCM
00E438  2               LBB_MAX
00E438  2  41 58 28 DE  	.byte	"AX(",TK_MAX	; MAX(
00E43C  2               LBB_MIDS
00E43C  2  49 44 24 28  	.byte	"ID$(",TK_MIDS	; MID$(
00E440  2  E5           
00E441  2               LBB_MIN
00E441  2  49 4E 28 DF  	.byte	"IN(",TK_MIN	; MIN(
00E445  2  00           	.byte	$00
00E446  2               TAB_ASCN
00E446  2               LBB_NEW
00E446  2  45 57 A3     	.byte	"EW",TK_NEW		; NEW
00E449  2               LBB_NEXT
00E449  2  45 58 54 82  	.byte	"EXT",TK_NEXT	; NEXT
00E44D  2               LBB_NMI
00E44D  2  4D 49 AA     	.byte	"MI",TK_NMI		; NMI
00E450  2               LBB_NOT
00E450  2  4F 54 B1     	.byte	"OT",TK_NOT		; NOT
00E453  2               LBB_NULL
00E453  2  55 4C 4C 94  	.byte	"ULL",TK_NULL	; NULL
00E457  2  00           	.byte	$00
00E458  2               TAB_ASCO
00E458  2               LBB_OFF
00E458  2  46 46 B5     	.byte	"FF",TK_OFF		; OFF
00E45B  2               LBB_ON
00E45B  2  4E 93        	.byte	"N",TK_ON		; ON
00E45D  2               LBB_OR
00E45D  2  52 BD        	.byte	"R",TK_OR		; OR
00E45F  2  00           	.byte	$00
00E460  2               TAB_ASCP
00E460  2               LBB_PEEK
00E460  2  45 45 4B 28  	.byte	"EEK(",TK_PEEK	; PEEK(
00E464  2  D1           
00E465  2               LBB_PI
00E465  2  49 E0        	.byte	"I",TK_PI		; PI
00E467  2               LBB_POKE
00E467  2  4F 4B 45 9A  	.byte	"OKE",TK_POKE	; POKE
00E46B  2               LBB_POS
00E46B  2  4F 53 28 C8  	.byte	"OS(",TK_POS	; POS(
00E46F  2               LBB_PRINT
00E46F  2  52 49 4E 54  	.byte	"RINT",TK_PRINT	; PRINT
00E473  2  9F           
00E474  2  00           	.byte	$00
00E475  2               TAB_ASCR
00E475  2               LBB_READ
00E475  2  45 41 44 86  	.byte	"EAD",TK_READ	; READ
00E479  2               LBB_REM
00E479  2  45 4D 91     	.byte	"EM",TK_REM		; REM
00E47C  2               LBB_RESTORE
00E47C  2  45 53 54 4F  	.byte	"ESTORE",TK_RESTORE
00E480  2  52 45 8C     
00E483  2               					; RESTORE
00E483  2               LBB_RETIRQ
00E483  2  45 54 49 52  	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
00E487  2  51 8E        
00E489  2               LBB_RETNMI
00E489  2  45 54 4E 4D  	.byte	"ETNMI",TK_RETNMI	; RETNMI
00E48D  2  49 8F        
00E48F  2               LBB_RETURN
00E48F  2  45 54 55 52  	.byte	"ETURN",TK_RETURN	; RETURN
00E493  2  4E 90        
00E495  2               LBB_RIGHTS
00E495  2  49 47 48 54  	.byte	"IGHT$(",TK_RIGHTS
00E499  2  24 28 E4     
00E49C  2               					; RIGHT$(
00E49C  2               LBB_RND
00E49C  2  4E 44 28 CA  	.byte	"ND(",TK_RND	; RND(
00E4A0  2               LBB_RUN
00E4A0  2  55 4E 8A     	.byte	"UN",TK_RUN		; RUN
00E4A3  2  00           	.byte	$00
00E4A4  2               TAB_ASCS
00E4A4  2               LBB_SADD
00E4A4  2  41 44 44 28  	.byte	"ADD(",TK_SADD	; SADD(
00E4A8  2  D3           
00E4A9  2               LBB_SAVE
00E4A9  2  41 56 45 98  	.byte	"AVE",TK_SAVE	; SAVE
00E4AD  2               LBB_SGN
00E4AD  2  47 4E 28 C3  	.byte	"GN(",TK_SGN	; SGN(
00E4B1  2               LBB_SIN
00E4B1  2  49 4E 28 CE  	.byte	"IN(",TK_SIN	; SIN(
00E4B5  2               LBB_SPC
00E4B5  2  50 43 28 AF  	.byte	"PC(",TK_SPC	; SPC(
00E4B9  2               LBB_SQR
00E4B9  2  51 52 28 C9  	.byte	"QR(",TK_SQR	; SQR(
00E4BD  2               LBB_STEP
00E4BD  2  54 45 50 B2  	.byte	"TEP",TK_STEP	; STEP
00E4C1  2               LBB_STOP
00E4C1  2  54 4F 50 92  	.byte	"TOP",TK_STOP	; STOP
00E4C5  2               LBB_STRS
00E4C5  2  54 52 24 28  	.byte	"TR$(",TK_STRS	; STR$(
00E4C9  2  D5           
00E4CA  2               LBB_SWAP
00E4CA  2  57 41 50 A6  	.byte	"WAP",TK_SWAP	; SWAP
00E4CE  2  00           	.byte	$00
00E4CF  2               TAB_ASCT
00E4CF  2               LBB_TAB
00E4CF  2  41 42 28 AB  	.byte	"AB(",TK_TAB	; TAB(
00E4D3  2               LBB_TAN
00E4D3  2  41 4E 28 CF  	.byte	"AN(",TK_TAN	; TAN(
00E4D7  2               LBB_THEN
00E4D7  2  48 45 4E B0  	.byte	"HEN",TK_THEN	; THEN
00E4DB  2               LBB_TO
00E4DB  2  4F AD        	.byte	"O",TK_TO		; TO
00E4DD  2               LBB_TWOPI
00E4DD  2  57 4F 50 49  	.byte	"WOPI",TK_TWOPI	; TWOPI
00E4E1  2  E1           
00E4E2  2  00           	.byte	$00
00E4E3  2               TAB_ASCU
00E4E3  2               LBB_UCASES
00E4E3  2  43 41 53 45  	.byte	"CASE$(",TK_UCASES
00E4E7  2  24 28 D8     
00E4EA  2               					; UCASE$(
00E4EA  2               LBB_UNTIL
00E4EA  2  4E 54 49 4C  	.byte	"NTIL",TK_UNTIL	; UNTIL
00E4EE  2  B3           
00E4EF  2               LBB_USR
00E4EF  2  53 52 28 C6  	.byte	"SR(",TK_USR	; USR(
00E4F3  2  00           	.byte	$00
00E4F4  2               TAB_ASCV
00E4F4  2               LBB_VAL
00E4F4  2  41 4C 28 D6  	.byte	"AL(",TK_VAL	; VAL(
00E4F8  2               LBB_VPTR
00E4F8  2  41 52 50 54  	.byte	"ARPTR(",TK_VPTR	; VARPTR(
00E4FC  2  52 28 E2     
00E4FF  2  00           	.byte	$00
00E500  2               TAB_ASCW
00E500  2               LBB_WAIT
00E500  2  41 49 54 96  	.byte	"AIT",TK_WAIT	; WAIT
00E504  2               LBB_WHILE
00E504  2  48 49 4C 45  	.byte	"HILE",TK_WHILE	; WHILE
00E508  2  B4           
00E509  2               LBB_WIDTH
00E509  2  49 44 54 48  	.byte	"IDTH",TK_WIDTH	; WIDTH
00E50D  2  A4           
00E50E  2  00           	.byte	$00
00E50F  2               TAB_POWR
00E50F  2  BA 00        	.byte	TK_POWER,$00	; ^
00E511  2               
00E511  2               ; new decode table for LIST
00E511  2               ; Table is ..
00E511  2               ; byte - keyword length, keyword first character
00E511  2               ; word - pointer to rest of keyword from dictionary
00E511  2               
00E511  2               ; note if length is 1 then the pointer is ignored
00E511  2               
00E511  2               LAB_KEYT
00E511  2  03 45        	.byte	3,'E'
00E513  2  D9 E3        	.word	LBB_END		; END
00E515  2  03 46        	.byte	3,'F'
00E517  2  E6 E3        	.word	LBB_FOR		; FOR
00E519  2  04 4E        	.byte	4,'N'
00E51B  2  49 E4        	.word	LBB_NEXT		; NEXT
00E51D  2  04 44        	.byte	4,'D'
00E51F  2  BC E3        	.word	LBB_DATA		; DATA
00E521  2  05 49        	.byte	5,'I'
00E523  2  06 E4        	.word	LBB_INPUT		; INPUT
00E525  2  03 44        	.byte	3,'D'
00E527  2  CB E3        	.word	LBB_DIM		; DIM
00E529  2  04 52        	.byte	4,'R'
00E52B  2  75 E4        	.word	LBB_READ		; READ
00E52D  2  03 4C        	.byte	3,'L'
00E52F  2  24 E4        	.word	LBB_LET		; LET
00E531  2  03 44        	.byte	3,'D'
00E533  2  C0 E3        	.word	LBB_DEC		; DEC
00E535  2  04 47        	.byte	4,'G'
00E537  2  F6 E3        	.word	LBB_GOTO		; GOTO
00E539  2  03 52        	.byte	3,'R'
00E53B  2  A0 E4        	.word	LBB_RUN		; RUN
00E53D  2  02 49        	.byte	2,'I'
00E53F  2  01 E4        	.word	LBB_IF		; IF
00E541  2  07 52        	.byte	7,'R'
00E543  2  7C E4        	.word	LBB_RESTORE		; RESTORE
00E545  2  05 47        	.byte	5,'G'
00E547  2  F1 E3        	.word	LBB_GOSUB		; GOSUB
00E549  2  06 52        	.byte	6,'R'
00E54B  2  83 E4        	.word	LBB_RETIRQ		; RETIRQ
00E54D  2  06 52        	.byte	6,'R'
00E54F  2  89 E4        	.word	LBB_RETNMI		; RETNMI
00E551  2  06 52        	.byte	6,'R'
00E553  2  8F E4        	.word	LBB_RETURN		; RETURN
00E555  2  03 52        	.byte	3,'R'
00E557  2  79 E4        	.word	LBB_REM		; REM
00E559  2  04 53        	.byte	4,'S'
00E55B  2  C1 E4        	.word	LBB_STOP		; STOP
00E55D  2  02 4F        	.byte	2,'O'
00E55F  2  5B E4        	.word	LBB_ON		; ON
00E561  2  04 4E        	.byte	4,'N'
00E563  2  53 E4        	.word	LBB_NULL		; NULL
00E565  2  03 49        	.byte	3,'I'
00E567  2  03 E4        	.word	LBB_INC		; INC
00E569  2  04 57        	.byte	4,'W'
00E56B  2  00 E5        	.word	LBB_WAIT		; WAIT
00E56D  2  04 4C        	.byte	4,'L'
00E56F  2  2B E4        	.word	LBB_LOAD		; LOAD
00E571  2  04 53        	.byte	4,'S'
00E573  2  A9 E4        	.word	LBB_SAVE		; SAVE
00E575  2  03 44        	.byte	3,'D'
00E577  2  C8 E3        	.word	LBB_DEF		; DEF
00E579  2  04 50        	.byte	4,'P'
00E57B  2  67 E4        	.word	LBB_POKE		; POKE
00E57D  2  04 44        	.byte	4,'D'
00E57F  2  CE E3        	.word	LBB_DOKE		; DOKE
00E581  2  04 43        	.byte	4,'C'
00E583  2  A5 E3        	.word	LBB_CALL		; CALL
00E585  2  02 44        	.byte	2,'D'
00E587  2  D2 E3        	.word	LBB_DO		; DO
00E589  2  04 4C        	.byte	4,'L'
00E58B  2  33 E4        	.word	LBB_LOOP		; LOOP
00E58D  2  05 50        	.byte	5,'P'
00E58F  2  6F E4        	.word	LBB_PRINT		; PRINT
00E591  2  04 43        	.byte	4,'C'
00E593  2  B3 E3        	.word	LBB_CONT		; CONT
00E595  2  04 4C        	.byte	4,'L'
00E597  2  27 E4        	.word	LBB_LIST		; LIST
00E599  2  05 43        	.byte	5,'C'
00E59B  2  AE E3        	.word	LBB_CLEAR		; CLEAR
00E59D  2  03 4E        	.byte	3,'N'
00E59F  2  46 E4        	.word	LBB_NEW		; NEW
00E5A1  2  05 57        	.byte	5,'W'
00E5A3  2  09 E5        	.word	LBB_WIDTH		; WIDTH
00E5A5  2  03 47        	.byte	3,'G'
00E5A7  2  EE E3        	.word	LBB_GET		; GET
00E5A9  2  04 53        	.byte	4,'S'
00E5AB  2  CA E4        	.word	LBB_SWAP		; SWAP
00E5AD  2  06 42        	.byte	6,'B'
00E5AF  2  97 E3        	.word	LBB_BITSET		; BITSET
00E5B1  2  06 42        	.byte	6,'B'
00E5B3  2  91 E3        	.word	LBB_BITCLR		; BITCLR
00E5B5  2  03 49        	.byte	3,'I'
00E5B7  2  0F E4        	.word	LBB_IRQ		; IRQ
00E5B9  2  03 4E        	.byte	3,'N'
00E5BB  2  4D E4        	.word	LBB_NMI		; NMI
00E5BD  2               
00E5BD  2               ; secondary commands (can't start a statement)
00E5BD  2               
00E5BD  2  04 54        	.byte	4,'T'
00E5BF  2  CF E4        	.word	LBB_TAB		; TAB
00E5C1  2  04 45        	.byte	4,'E'
00E5C3  2  D5 E3        	.word	LBB_ELSE		; ELSE
00E5C5  2  02 54        	.byte	2,'T'
00E5C7  2  DB E4        	.word	LBB_TO		; TO
00E5C9  2  02 46        	.byte	2,'F'
00E5CB  2  E4 E3        	.word	LBB_FN		; FN
00E5CD  2  04 53        	.byte	4,'S'
00E5CF  2  B5 E4        	.word	LBB_SPC		; SPC
00E5D1  2  04 54        	.byte	4,'T'
00E5D3  2  D7 E4        	.word	LBB_THEN		; THEN
00E5D5  2  03 4E        	.byte	3,'N'
00E5D7  2  50 E4        	.word	LBB_NOT		; NOT
00E5D9  2  04 53        	.byte	4,'S'
00E5DB  2  BD E4        	.word	LBB_STEP		; STEP
00E5DD  2  05 55        	.byte	5,'U'
00E5DF  2  EA E4        	.word	LBB_UNTIL		; UNTIL
00E5E1  2  05 57        	.byte	5,'W'
00E5E3  2  04 E5        	.word	LBB_WHILE		; WHILE
00E5E5  2  03 4F        	.byte	3,'O'
00E5E7  2  58 E4        	.word	LBB_OFF		; OFF
00E5E9  2               
00E5E9  2               ; opperators
00E5E9  2               
00E5E9  2  01 2B        	.byte	1,'+'
00E5EB  2  00 00        	.word	$0000			; +
00E5ED  2  01 2D        	.byte	1,'-'
00E5EF  2  00 00        	.word	$0000			; -
00E5F1  2  01 2A        	.byte	1,'*'
00E5F3  2  00 00        	.word	$0000			; *
00E5F5  2  01 2F        	.byte	1,'/'
00E5F7  2  00 00        	.word	$0000			; /
00E5F9  2  01 5E        	.byte	1,'^'
00E5FB  2  00 00        	.word	$0000			; ^
00E5FD  2  03 41        	.byte	3,'A'
00E5FF  2  80 E3        	.word	LBB_AND		; AND
00E601  2  03 45        	.byte	3,'E'
00E603  2  DC E3        	.word	LBB_EOR		; EOR
00E605  2  02 4F        	.byte	2,'O'
00E607  2  5D E4        	.word	LBB_OR		; OR
00E609  2  02 3E        	.byte	2,'>'
00E60B  2  76 E3        	.word	LBB_RSHIFT		; >>
00E60D  2  02 3C        	.byte	2,'<'
00E60F  2  70 E3        	.word	LBB_LSHIFT		; <<
00E611  2  01 3E        	.byte	1,'>'
00E613  2  00 00        	.word	$0000			; >
00E615  2  01 3D        	.byte	1,'='
00E617  2  00 00        	.word	$0000			; =
00E619  2  01 3C        	.byte	1,'<'
00E61B  2  00 00        	.word	$0000			; <
00E61D  2               
00E61D  2               ; functions
00E61D  2               
00E61D  2  04 53        	.byte	4,'S'			;
00E61F  2  AD E4        	.word	LBB_SGN		; SGN
00E621  2  04 49        	.byte	4,'I'			;
00E623  2  0B E4        	.word	LBB_INT		; INT
00E625  2  04 41        	.byte	4,'A'			;
00E627  2  7C E3        	.word	LBB_ABS		; ABS
00E629  2  04 55        	.byte	4,'U'			;
00E62B  2  EF E4        	.word	LBB_USR		; USR
00E62D  2  04 46        	.byte	4,'F'			;
00E62F  2  E9 E3        	.word	LBB_FRE		; FRE
00E631  2  04 50        	.byte	4,'P'			;
00E633  2  6B E4        	.word	LBB_POS		; POS
00E635  2  04 53        	.byte	4,'S'			;
00E637  2  B9 E4        	.word	LBB_SQR		; SQR
00E639  2  04 52        	.byte	4,'R'			;
00E63B  2  9C E4        	.word	LBB_RND		; RND
00E63D  2  04 4C        	.byte	4,'L'			;
00E63F  2  2F E4        	.word	LBB_LOG		; LOG
00E641  2  04 45        	.byte	4,'E'			;
00E643  2  DF E3        	.word	LBB_EXP		; EXP
00E645  2  04 43        	.byte	4,'C'			;
00E647  2  B7 E3        	.word	LBB_COS		; COS
00E649  2  04 53        	.byte	4,'S'			;
00E64B  2  B1 E4        	.word	LBB_SIN		; SIN
00E64D  2  04 54        	.byte	4,'T'			;
00E64F  2  D3 E4        	.word	LBB_TAN		; TAN
00E651  2  04 41        	.byte	4,'A'			;
00E653  2  87 E3        	.word	LBB_ATN		; ATN
00E655  2  05 50        	.byte	5,'P'			;
00E657  2  60 E4        	.word	LBB_PEEK		; PEEK
00E659  2  05 44        	.byte	5,'D'			;
00E65B  2  C3 E3        	.word	LBB_DEEK		; DEEK
00E65D  2  05 53        	.byte	5,'S'			;
00E65F  2  A4 E4        	.word	LBB_SADD		; SADD
00E661  2  04 4C        	.byte	4,'L'			;
00E663  2  20 E4        	.word	LBB_LEN		; LEN
00E665  2  05 53        	.byte	5,'S'			;
00E667  2  C5 E4        	.word	LBB_STRS		; STR$
00E669  2  04 56        	.byte	4,'V'			;
00E66B  2  F4 E4        	.word	LBB_VAL		; VAL
00E66D  2  04 41        	.byte	4,'A'			;
00E66F  2  83 E3        	.word	LBB_ASC		; ASC
00E671  2  07 55        	.byte	7,'U'			;
00E673  2  E3 E4        	.word	LBB_UCASES		; UCASE$
00E675  2  07 4C        	.byte	7,'L'			;
00E677  2  13 E4        	.word	LBB_LCASES		; LCASE$
00E679  2  05 43        	.byte	5,'C'			;
00E67B  2  A9 E3        	.word	LBB_CHRS		; CHR$
00E67D  2  05 48        	.byte	5,'H'			;
00E67F  2  FB E3        	.word	LBB_HEXS		; HEX$
00E681  2  05 42        	.byte	5,'B'			;
00E683  2  8C E3        	.word	LBB_BINS		; BIN$
00E685  2  07 42        	.byte	7,'B'			;
00E687  2  9D E3        	.word	LBB_BITTST		; BITTST
00E689  2  04 4D        	.byte	4,'M'			;
00E68B  2  38 E4        	.word	LBB_MAX		; MAX
00E68D  2  04 4D        	.byte	4,'M'			;
00E68F  2  41 E4        	.word	LBB_MIN		; MIN
00E691  2  02 50        	.byte	2,'P'			;
00E693  2  65 E4        	.word	LBB_PI		; PI
00E695  2  05 54        	.byte	5,'T'			;
00E697  2  DD E4        	.word	LBB_TWOPI		; TWOPI
00E699  2  07 56        	.byte	7,'V'			;
00E69B  2  F8 E4        	.word	LBB_VPTR		; VARPTR
00E69D  2  06 4C        	.byte	6,'L'			;
00E69F  2  1A E4        	.word	LBB_LEFTS		; LEFT$
00E6A1  2  07 52        	.byte	7,'R'			;
00E6A3  2  95 E4        	.word	LBB_RIGHTS		; RIGHT$
00E6A5  2  05 4D        	.byte	5,'M'			;
00E6A7  2  3C E4        	.word	LBB_MIDS		; MID$
00E6A9  2               
00E6A9  2               ; BASIC messages, mostly error messages
00E6A9  2               
00E6A9  2               LAB_BAER
00E6A9  2  CD E6        	.word	ERR_NF		;$00 NEXT without FOR
00E6AB  2  DE E6        	.word	ERR_SN		;$02 syntax
00E6AD  2  E5 E6        	.word	ERR_RG		;$04 RETURN without GOSUB
00E6AF  2  FA E6        	.word	ERR_OD		;$06 out of data
00E6B1  2  06 E7        	.word	ERR_FC		;$08 function call
00E6B3  2  14 E7        	.word	ERR_OV		;$0A overflow
00E6B5  2  1D E7        	.word	ERR_OM		;$0C out of memory
00E6B7  2  2B E7        	.word	ERR_US		;$0E undefined statement
00E6B9  2  3F E7        	.word	ERR_BS		;$10 array bounds
00E6BB  2  4C E7        	.word	ERR_DD		;$12 double dimension array
00E6BD  2  5D E7        	.word	ERR_D0		;$14 divide by 0
00E6BF  2  6C E7        	.word	ERR_ID		;$16 illegal direct
00E6C1  2  7B E7        	.word	ERR_TM		;$18 type mismatch
00E6C3  2  89 E7        	.word	ERR_LS		;$1A long string
00E6C5  2  99 E7        	.word	ERR_ST		;$1C string too complex
00E6C7  2  AC E7        	.word	ERR_CN		;$1E continue error
00E6C9  2  BB E7        	.word	ERR_UF		;$20 undefined function
00E6CB  2  CE E7        	.word ERR_LD		;$22 LOOP without DO
00E6CD  2               
00E6CD  2               ; I may implement these two errors to force definition of variables and
00E6CD  2               ; dimensioning of arrays before use.
00E6CD  2               
00E6CD  2               ;	.word ERR_UV		;$24 undefined variable
00E6CD  2               
00E6CD  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00E6CD  2               
00E6CD  2               ;	.word ERR_UA		;$26 undimensioned array
00E6CD  2               
00E6CD  2  4E 45 58 54  ERR_NF	.byte	"NEXT without FOR",$00
00E6D1  2  20 77 69 74  
00E6D5  2  68 6F 75 74  
00E6DE  2  53 79 6E 74  ERR_SN	.byte	"Syntax",$00
00E6E2  2  61 78 00     
00E6E5  2  52 45 54 55  ERR_RG	.byte	"RETURN without GOSUB",$00
00E6E9  2  52 4E 20 77  
00E6ED  2  69 74 68 6F  
00E6FA  2  4F 75 74 20  ERR_OD	.byte	"Out of DATA",$00
00E6FE  2  6F 66 20 44  
00E702  2  41 54 41 00  
00E706  2  46 75 6E 63  ERR_FC	.byte	"Function call",$00
00E70A  2  74 69 6F 6E  
00E70E  2  20 63 61 6C  
00E714  2  4F 76 65 72  ERR_OV	.byte	"Overflow",$00
00E718  2  66 6C 6F 77  
00E71C  2  00           
00E71D  2  4F 75 74 20  ERR_OM	.byte	"Out of memory",$00
00E721  2  6F 66 20 6D  
00E725  2  65 6D 6F 72  
00E72B  2  55 6E 64 65  ERR_US	.byte	"Undefined statement",$00
00E72F  2  66 69 6E 65  
00E733  2  64 20 73 74  
00E73F  2  41 72 72 61  ERR_BS	.byte	"Array bounds",$00
00E743  2  79 20 62 6F  
00E747  2  75 6E 64 73  
00E74C  2  44 6F 75 62  ERR_DD	.byte	"Double dimension",$00
00E750  2  6C 65 20 64  
00E754  2  69 6D 65 6E  
00E75D  2  44 69 76 69  ERR_D0	.byte	"Divide by zero",$00
00E761  2  64 65 20 62  
00E765  2  79 20 7A 65  
00E76C  2  49 6C 6C 65  ERR_ID	.byte	"Illegal direct",$00
00E770  2  67 61 6C 20  
00E774  2  64 69 72 65  
00E77B  2  54 79 70 65  ERR_TM	.byte	"Type mismatch",$00
00E77F  2  20 6D 69 73  
00E783  2  6D 61 74 63  
00E789  2  53 74 72 69  ERR_LS	.byte	"String too long",$00
00E78D  2  6E 67 20 74  
00E791  2  6F 6F 20 6C  
00E799  2  53 74 72 69  ERR_ST	.byte	"String too complex",$00
00E79D  2  6E 67 20 74  
00E7A1  2  6F 6F 20 63  
00E7AC  2  43 61 6E 27  ERR_CN	.byte	"Can't continue",$00
00E7B0  2  74 20 63 6F  
00E7B4  2  6E 74 69 6E  
00E7BB  2  55 6E 64 65  ERR_UF	.byte	"Undefined function",$00
00E7BF  2  66 69 6E 65  
00E7C3  2  64 20 66 75  
00E7CE  2  4C 4F 4F 50  ERR_LD	.byte	"LOOP without DO",$00
00E7D2  2  20 77 69 74  
00E7D6  2  68 6F 75 74  
00E7DE  2               
00E7DE  2               ;ERR_UV	.byte	"Undefined variable",$00
00E7DE  2               
00E7DE  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00E7DE  2               
00E7DE  2               ;ERR_UA	.byte	"Undimensioned array",$00
00E7DE  2               
00E7DE  2  0D 0A 42 72  LAB_BMSG	.byte	$0D,$0A,"Break",$00
00E7E2  2  65 61 6B 00  
00E7E6  2  20 45 72 72  LAB_EMSG	.byte	" Error",$00
00E7EA  2  6F 72 00     
00E7ED  2  20 69 6E 20  LAB_LMSG	.byte	" in line ",$00
00E7F1  2  6C 69 6E 65  
00E7F5  2  20 00        
00E7F7  2  0D 0A 52 65  LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
00E7FB  2  61 64 79 0D  
00E7FF  2  0A 00        
00E801  2               
00E801  2  20 45 78 74  LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
00E805  2  72 61 20 69  
00E809  2  67 6E 6F 72  
00E812  2  20 52 65 64  LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
00E816  2  6F 20 66 72  
00E81A  2  6F 6D 20 73  
00E825  2               
00E825  2               AA_end_basic
00E825  2               
00E825  1               
00E825  1               ; put the IRQ and MNI code in RAM so that it can be changed
00E825  1               
00E825  1               IRQ_vec	= VEC_SV+2		; IRQ code vector
00E825  1               NMI_vec	= IRQ_vec+$0A	; NMI code vector
00E825  1               
00E825  1               ; setup for the 6502 simulator environment
00E825  1               
00E825  1               IO_AREA = $A000
00E825  1               ACIAdata	= IO_AREA		; simulated ACIA r/w port
00E825  1               ACIAstatus  = IO_AREA+1
00E825  1               ACIAcommand = IO_AREA+2
00E825  1               ACIAcontrol = IO_AREA+3
00E825  1               
00E825  1               ; now the code. all this does is set up the vectors and interrupt code
00E825  1               ; and wait for the user to select [C]old or [W]arm start. nothing else
00E825  1               ; fits in less than 128 bytes
00E825  1               
00E825  1               .segment "MONITOR"
00E825  1               	.org	$FF00			; pretend this is in a 1/8K ROM
00FF00  1               
00FF00  1               ; reset vector points here
00FF00  1               
00FF00  1               RES_vec
00FF00  1  D8           	CLD				; clear decimal mode
00FF01  1  A2 FF        	LDX	#$FF			; empty stack
00FF03  1  9A           	TXS				; set the stack
00FF04  1               
00FF04  1               ; Initialize the ACIA
00FF04  1               ACIA_init
00FF04  1  A9 00        	LDA	#$00
00FF06  1  8D 01 A0     	STA	ACIAstatus		; Soft reset
00FF09  1  A9 0B        	LDA	#$0B
00FF0B  1  8D 02 A0     	STA	ACIAcommand		; Parity disabled, IRQ disabled
00FF0E  1  A9 1E        	LDA	#$1E
00FF10  1  8D 03 A0     	STA	ACIAcontrol		; Set output for 8-N-1 9600
00FF13  1               
00FF13  1               ; set up vectors and interrupt code, copy them to page 2
00FF13  1               
00FF13  1  A0 1C        	LDY	#END_CODE-LAB_vec	; set index/count
00FF15  1               LAB_stlp
00FF15  1  B9 62 FF     	LDA	LAB_vec-1,Y		; get byte from interrupt code
00FF18  1  99 04 02     	STA	VEC_IN-1,Y		; save to RAM
00FF1B  1  88           	DEY				; decrement index/count
00FF1C  1  D0 F7        	BNE	LAB_stlp		; loop if more to do
00FF1E  1               
00FF1E  1               ; now do the signon message, Y = $00 here
00FF1E  1               
00FF1E  1               LAB_signon
00FF1E  1  B9 7F FF     	LDA	LAB_mess,Y		; get byte from sign on message
00FF21  1  F0 06        	BEQ	LAB_nokey		; exit loop if done
00FF23  1               
00FF23  1  20 ED E0     	JSR	V_OUTP		; output character
00FF26  1  C8           	INY				; increment index
00FF27  1  D0 F5        	BNE	LAB_signon		; loop, branch always
00FF29  1               
00FF29  1               LAB_nokey
00FF29  1  20 EA E0     	JSR	V_INPT		; call scan input device
00FF2C  1  90 FB        	BCC	LAB_nokey		; loop if no key
00FF2E  1               
00FF2E  1  29 DF        	AND	#$DF			; mask xx0x xxxx, ensure upper case
00FF30  1  C9 57        	CMP	#'W'			; compare with [W]arm start
00FF32  1  F0 07        	BEQ	LAB_dowarm		; branch if [W]arm start
00FF34  1               
00FF34  1  C9 43        	CMP	#'C'			; compare with [C]old start
00FF36  1  D0 C8        	BNE	RES_vec		; loop if not [C]old start
00FF38  1               
00FF38  1  4C 00 C0     	JMP	LAB_COLD		; do EhBASIC cold start
00FF3B  1               
00FF3B  1               LAB_dowarm
00FF3B  1  4C 00 00     	JMP	LAB_WARM		; do EhBASIC warm start
00FF3E  1               
00FF3E  1               ; byte out to ACIA
00FF3E  1               ACIAout
00FF3E  1  48           	PHA				; save accumulator
00FF3F  1               @loop
00FF3F  1  AD 01 A0     	LDA	ACIAstatus		; Read 6551 status
00FF42  1  29 10        	AND	#$10			; Is tx buffer full?
00FF44  1  F0 F9        	BEQ	@loop			; if not, loop back
00FF46  1  68           	PLA				; Otherwise, restore accumulator
00FF47  1  8D 00 A0     	STA	ACIAdata		; write byte to 6551
00FF4A  1  60           	RTS
00FF4B  1               
00FF4B  1               ;
00FF4B  1               ; byte in from ACIA. This subroutine will also force
00FF4B  1               ; all lowercase letters to be uppercase.
00FF4B  1               ;
00FF4B  1               ACIAin
00FF4B  1  AD 01 A0     	LDA	ACIAstatus		; Read 6551 status
00FF4E  1  29 08        	AND	#$08			;
00FF50  1  F0 0F        	BEQ	LAB_nobyw		; If rx buffer empty, no byte
00FF52  1               
00FF52  1  AD 00 A0     	LDA	ACIAdata		; Read byte from 6551
00FF55  1  C9 61        	CMP	#'a'			; Is it < 'a'?
00FF57  1  90 06        	BCC	@done			; Yes, we're done
00FF59  1  C9 7B        	CMP	#'{'			; Is it >= '{'?
00FF5B  1  B0 02        	BCS	@done			; Yes, we're done
00FF5D  1  29 5F        	AND	#$5f			; Otherwise, mask to uppercase
00FF5F  1               @done
00FF5F  1  38           	SEC				; Flag byte received
00FF60  1  60           	RTS
00FF61  1               
00FF61  1               LAB_nobyw
00FF61  1  18           	CLC				; flag no byte received
00FF62  1               no_load				; empty load vector for EhBASIC
00FF62  1               no_save				; empty save vector for EhBASIC
00FF62  1  60           	RTS
00FF63  1               
00FF63  1               ; vector tables
00FF63  1               
00FF63  1               LAB_vec
00FF63  1  4B FF        	.word	ACIAin		; byte in from simulated ACIA
00FF65  1  3E FF        	.word	ACIAout		; byte out to simulated ACIA
00FF67  1  62 FF        	.word	no_load		; null load vector for EhBASIC
00FF69  1  62 FF        	.word	no_save		; null save vector for EhBASIC
00FF6B  1               
00FF6B  1               ; EhBASIC IRQ support
00FF6B  1               
00FF6B  1               IRQ_CODE
00FF6B  1  48           	PHA				; save A
00FF6C  1  A5 DF        	LDA	IrqBase		; get the IRQ flag byte
00FF6E  1  4A           	LSR				; shift the set b7 to b6, and on down ...
00FF6F  1  05 DF        	ORA	IrqBase		; OR the original back in
00FF71  1  85 DF        	STA	IrqBase		; save the new IRQ flag byte
00FF73  1  68           	PLA				; restore A
00FF74  1  40           	RTI
00FF75  1               
00FF75  1               ; EhBASIC NMI support
00FF75  1               
00FF75  1               NMI_CODE
00FF75  1  48           	PHA				; save A
00FF76  1  A5 DC        	LDA	NmiBase		; get the NMI flag byte
00FF78  1  4A           	LSR				; shift the set b7 to b6, and on down ...
00FF79  1  05 DC        	ORA	NmiBase		; OR the original back in
00FF7B  1  85 DC        	STA	NmiBase		; save the new NMI flag byte
00FF7D  1  68           	PLA				; restore A
00FF7E  1  40           	RTI
00FF7F  1               
00FF7F  1               END_CODE
00FF7F  1               
00FF7F  1               ; sign on string
00FF7F  1               
00FF7F  1               LAB_mess
00FF7F  1  0D 0A 53 79  	.byte	$0D,$0A,"Symon (c) 2008-2014, Seth Morabito"
00FF83  1  6D 6F 6E 20  
00FF87  1  28 63 29 20  
00FFA3  1  0D 0A 45 6E  	.byte   $0D,$0A,"Enhanced 6502 BASIC 2.22 (c) Lee Davison"
00FFA7  1  68 61 6E 63  
00FFAB  1  65 64 20 36  
00FFCD  1  0D 0A 5B 43  	.byte   $0D,$0A,"[C]old/[W]arm ?",$00
00FFD1  1  5D 6F 6C 64  
00FFD5  1  2F 5B 57 5D  
00FFDF  1               
00FFDF  1               
00FFDF  1               ; system vectors
00FFDF  1               
00FFDF  1               .segment "VECTORS"
00FFDF  1               	.org	$FFFA
00FFFA  1               
00FFFA  1  17 02        	.word	NMI_vec		; NMI vector
00FFFC  1  00 FF        	.word	RES_vec		; RESET vector
00FFFE  1  0D 02        	.word	IRQ_vec		; IRQ vector
010000  1               
010000  1               
